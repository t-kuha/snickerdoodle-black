circuit top_sd_blk :
  module Queue :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { opcode : UInt<4>, flags : UInt<4>, arguments : UInt<56>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { opcode : UInt<4>, flags : UInt<4>, arguments : UInt<56>}}, count : UInt<2>}

    cmem ram : { opcode : UInt<4>, flags : UInt<4>, arguments : UInt<56>} [2] @[Decoupled.scala 259:95]
    reg value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg value_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(value_1, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(value_1, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      value_1 <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      value <= UInt<1>("h0") @[Counter.scala 99:11]
      value_1 <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Queue_1 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { last : UInt<1>, bits : { opcode : UInt<4>, flags : UInt<4>, arguments : UInt<56>}}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { last : UInt<1>, bits : { opcode : UInt<4>, flags : UInt<4>, arguments : UInt<56>}}}, count : UInt<1>}

    cmem ram : { last : UInt<1>, bits : { opcode : UInt<4>, flags : UInt<4>, arguments : UInt<56>}} [1] @[Decoupled.scala 259:95]
    wire enq_ptr_value : UInt
    enq_ptr_value <= UInt<1>("h0")
    wire deq_ptr_value : UInt
    deq_ptr_value <= UInt<1>("h0")
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[UInt<1>("h0")], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
    when do_deq : @[Decoupled.scala 276:16]
      skip
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[UInt<1>("h0")], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<1>("h1"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Counter :
    input clock : Clock
    input reset : Reset
    output io : { value : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<20>}, flip resetValue : UInt<1>}

    reg value : UInt<20>, clock with :
      reset => (reset, UInt<20>("h0")) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h0")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<20>("hfffff")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h0") @[Counter.scala 22:13]
      else :
        node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h0") @[Counter.scala 28:11]

  module CountBy :
    input clock : Clock
    input reset : Reset
    output io : { value : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<20>}, flip step : UInt<20>, flip resetValue : UInt<1>}

    reg value : UInt<20>, clock with :
      reset => (reset, UInt<20>("h0")) @[CountBy.scala 17:22]
    io.value.bits <= value @[CountBy.scala 19:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h0")) @[CountBy.scala 20:21]
    io.value.valid <= _io_value_valid_T @[CountBy.scala 20:18]
    when io.value.ready : @[CountBy.scala 21:24]
      node _T = sub(UInt<21>("h100000"), io.step) @[CountBy.scala 22:24]
      node _T_1 = tail(_T, 1) @[CountBy.scala 22:24]
      node _T_2 = geq(value, _T_1) @[CountBy.scala 22:16]
      when _T_2 : @[CountBy.scala 22:36]
        value <= UInt<1>("h0") @[CountBy.scala 23:13]
      else :
        node _value_T = add(value, io.step) @[CountBy.scala 25:22]
        node _value_T_1 = tail(_value_T, 1) @[CountBy.scala 25:22]
        value <= _value_T_1 @[CountBy.scala 25:13]
    when io.resetValue : @[CountBy.scala 28:23]
      value <= UInt<1>("h0") @[CountBy.scala 29:11]

  module SizeAndStrideHandler :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>}}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>}}}

    node stride = dshl(UInt<1>("h1"), io.in.bits.stride) @[SizeAndStrideHandler.scala 30:20]
    inst sizeCounter of Counter @[Counter.scala 34:19]
    sizeCounter.clock <= clock
    sizeCounter.reset <= reset
    sizeCounter.io.resetValue <= UInt<1>("h0") @[Counter.scala 35:21]
    sizeCounter.io.value.ready <= UInt<1>("h0") @[Counter.scala 36:22]
    inst addressCounter of CountBy @[CountBy.scala 35:19]
    addressCounter.clock <= clock
    addressCounter.reset <= reset
    addressCounter.io.step <= stride @[CountBy.scala 36:15]
    addressCounter.io.resetValue <= UInt<1>("h0") @[CountBy.scala 37:21]
    addressCounter.io.value.ready <= UInt<1>("h0") @[CountBy.scala 38:22]
    io.out.valid <= io.in.valid @[SizeAndStrideHandler.scala 35:16]
    io.out.bits.size <= io.in.bits.size @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.address <= io.in.bits.address @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.write <= io.in.bits.write @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.size <= UInt<1>("h0") @[SizeAndStrideHandler.scala 43:34]
    when io.in.bits.reverse : @[SizeAndStrideHandler.scala 45:25]
      node _io_out_bits_address_T = sub(io.in.bits.address, addressCounter.io.value.bits) @[SizeAndStrideHandler.scala 46:44]
      node _io_out_bits_address_T_1 = tail(_io_out_bits_address_T, 1) @[SizeAndStrideHandler.scala 46:44]
      io.out.bits.address <= _io_out_bits_address_T_1 @[SizeAndStrideHandler.scala 46:25]
    else :
      node _io_out_bits_address_T_2 = add(io.in.bits.address, addressCounter.io.value.bits) @[SizeAndStrideHandler.scala 48:44]
      node _io_out_bits_address_T_3 = tail(_io_out_bits_address_T_2, 1) @[SizeAndStrideHandler.scala 48:44]
      io.out.bits.address <= _io_out_bits_address_T_3 @[SizeAndStrideHandler.scala 48:25]
    node fire = and(io.in.valid, io.out.ready) @[SizeAndStrideHandler.scala 51:23]
    node _T = eq(sizeCounter.io.value.bits, io.in.bits.size) @[SizeAndStrideHandler.scala 53:34]
    when _T : @[SizeAndStrideHandler.scala 53:52]
      io.in.ready <= io.out.ready @[SizeAndStrideHandler.scala 54:14]
      sizeCounter.io.resetValue <= fire @[SizeAndStrideHandler.scala 55:31]
      addressCounter.io.resetValue <= fire @[SizeAndStrideHandler.scala 56:34]
    else :
      io.in.ready <= UInt<1>("h0") @[SizeAndStrideHandler.scala 58:14]
      sizeCounter.io.value.ready <= fire @[SizeAndStrideHandler.scala 59:32]
      addressCounter.io.value.ready <= fire @[SizeAndStrideHandler.scala 60:35]

  module StrideHandler :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>}}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>}}}

    inst handler of SizeAndStrideHandler @[StrideHandler.scala 27:23]
    handler.clock <= clock
    handler.reset <= reset
    handler.io.in.valid <= UInt<1>("h0") @[StrideHandler.scala 37:23]
    wire _handler_io_in_bits_WIRE : { write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>} @[package.scala 75:57]
    _handler_io_in_bits_WIRE.reverse <= UInt<1>("h0") @[package.scala 75:57]
    _handler_io_in_bits_WIRE.stride <= UInt<3>("h0") @[package.scala 75:57]
    _handler_io_in_bits_WIRE.size <= UInt<20>("h0") @[package.scala 75:57]
    _handler_io_in_bits_WIRE.address <= UInt<20>("h0") @[package.scala 75:57]
    _handler_io_in_bits_WIRE.write <= UInt<1>("h0") @[package.scala 75:57]
    handler.io.in.bits.reverse <= _handler_io_in_bits_WIRE.reverse @[StrideHandler.scala 38:22]
    handler.io.in.bits.stride <= _handler_io_in_bits_WIRE.stride @[StrideHandler.scala 38:22]
    handler.io.in.bits.size <= _handler_io_in_bits_WIRE.size @[StrideHandler.scala 38:22]
    handler.io.in.bits.address <= _handler_io_in_bits_WIRE.address @[StrideHandler.scala 38:22]
    handler.io.in.bits.write <= _handler_io_in_bits_WIRE.write @[StrideHandler.scala 38:22]
    handler.io.out.ready <= UInt<1>("h0") @[StrideHandler.scala 39:24]
    node _T = eq(io.in.bits.stride, UInt<1>("h0")) @[StrideHandler.scala 41:23]
    when _T : @[StrideHandler.scala 41:32]
      io.out.bits.size <= io.in.bits.size @[StrideHandler.scala 44:36]
      io.out.bits.address <= io.in.bits.address @[StrideHandler.scala 44:36]
      io.out.bits.write <= io.in.bits.write @[StrideHandler.scala 44:36]
      io.out.bits.address <= io.in.bits.address @[StrideHandler.scala 47:25]
      io.out.bits.size <= io.in.bits.size @[StrideHandler.scala 48:22]
      io.in.ready <= io.out.ready @[StrideHandler.scala 49:14]
      io.out.valid <= io.in.valid @[StrideHandler.scala 50:18]
    else :
      handler.io.in <= io.in @[StrideHandler.scala 52:19]
      io.out.bits.size <= handler.io.out.bits.size @[StrideHandler.scala 55:36]
      io.out.bits.address <= handler.io.out.bits.address @[StrideHandler.scala 55:36]
      io.out.bits.write <= handler.io.out.bits.write @[StrideHandler.scala 55:36]
      io.out.bits.address <= handler.io.out.bits.address @[StrideHandler.scala 58:25]
      io.out.bits.size <= handler.io.out.bits.size @[StrideHandler.scala 59:22]
      handler.io.out.ready <= io.out.ready @[StrideHandler.scala 60:26]
      io.out.valid <= handler.io.out.valid @[StrideHandler.scala 61:18]

  module Counter_1 :
    input clock : Clock
    input reset : Reset
    output io : { value : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<20>}, flip resetValue : UInt<1>}

    reg value : UInt<20>, clock with :
      reset => (reset, UInt<20>("h0")) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h0")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<20>("hfffff")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h0") @[Counter.scala 22:13]
      else :
        node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h0") @[Counter.scala 28:11]

  module CountBy_1 :
    input clock : Clock
    input reset : Reset
    output io : { value : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<20>}, flip step : UInt<20>, flip resetValue : UInt<1>}

    reg value : UInt<20>, clock with :
      reset => (reset, UInt<20>("h0")) @[CountBy.scala 17:22]
    io.value.bits <= value @[CountBy.scala 19:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h0")) @[CountBy.scala 20:21]
    io.value.valid <= _io_value_valid_T @[CountBy.scala 20:18]
    when io.value.ready : @[CountBy.scala 21:24]
      node _T = sub(UInt<21>("h100000"), io.step) @[CountBy.scala 22:24]
      node _T_1 = tail(_T, 1) @[CountBy.scala 22:24]
      node _T_2 = geq(value, _T_1) @[CountBy.scala 22:16]
      when _T_2 : @[CountBy.scala 22:36]
        value <= UInt<1>("h0") @[CountBy.scala 23:13]
      else :
        node _value_T = add(value, io.step) @[CountBy.scala 25:22]
        node _value_T_1 = tail(_value_T, 1) @[CountBy.scala 25:22]
        value <= _value_T_1 @[CountBy.scala 25:13]
    when io.resetValue : @[CountBy.scala 28:23]
      value <= UInt<1>("h0") @[CountBy.scala 29:11]

  module SizeAndStrideHandler_1 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>}}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>}}}

    node stride = dshl(UInt<1>("h1"), io.in.bits.stride) @[SizeAndStrideHandler.scala 30:20]
    inst sizeCounter of Counter_1 @[Counter.scala 34:19]
    sizeCounter.clock <= clock
    sizeCounter.reset <= reset
    sizeCounter.io.resetValue <= UInt<1>("h0") @[Counter.scala 35:21]
    sizeCounter.io.value.ready <= UInt<1>("h0") @[Counter.scala 36:22]
    inst addressCounter of CountBy_1 @[CountBy.scala 35:19]
    addressCounter.clock <= clock
    addressCounter.reset <= reset
    addressCounter.io.step <= stride @[CountBy.scala 36:15]
    addressCounter.io.resetValue <= UInt<1>("h0") @[CountBy.scala 37:21]
    addressCounter.io.value.ready <= UInt<1>("h0") @[CountBy.scala 38:22]
    io.out.valid <= io.in.valid @[SizeAndStrideHandler.scala 35:16]
    io.out.bits.size <= io.in.bits.size @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.address <= io.in.bits.address @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.write <= io.in.bits.write @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.size <= UInt<1>("h0") @[SizeAndStrideHandler.scala 43:34]
    when io.in.bits.reverse : @[SizeAndStrideHandler.scala 45:25]
      node _io_out_bits_address_T = sub(io.in.bits.address, addressCounter.io.value.bits) @[SizeAndStrideHandler.scala 46:44]
      node _io_out_bits_address_T_1 = tail(_io_out_bits_address_T, 1) @[SizeAndStrideHandler.scala 46:44]
      io.out.bits.address <= _io_out_bits_address_T_1 @[SizeAndStrideHandler.scala 46:25]
    else :
      node _io_out_bits_address_T_2 = add(io.in.bits.address, addressCounter.io.value.bits) @[SizeAndStrideHandler.scala 48:44]
      node _io_out_bits_address_T_3 = tail(_io_out_bits_address_T_2, 1) @[SizeAndStrideHandler.scala 48:44]
      io.out.bits.address <= _io_out_bits_address_T_3 @[SizeAndStrideHandler.scala 48:25]
    node fire = and(io.in.valid, io.out.ready) @[SizeAndStrideHandler.scala 51:23]
    node _T = eq(sizeCounter.io.value.bits, io.in.bits.size) @[SizeAndStrideHandler.scala 53:34]
    when _T : @[SizeAndStrideHandler.scala 53:52]
      io.in.ready <= io.out.ready @[SizeAndStrideHandler.scala 54:14]
      sizeCounter.io.resetValue <= fire @[SizeAndStrideHandler.scala 55:31]
      addressCounter.io.resetValue <= fire @[SizeAndStrideHandler.scala 56:34]
    else :
      io.in.ready <= UInt<1>("h0") @[SizeAndStrideHandler.scala 58:14]
      sizeCounter.io.value.ready <= fire @[SizeAndStrideHandler.scala 59:32]
      addressCounter.io.value.ready <= fire @[SizeAndStrideHandler.scala 60:35]

  module StrideHandler_1 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>}}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>}}}

    inst handler of SizeAndStrideHandler_1 @[StrideHandler.scala 27:23]
    handler.clock <= clock
    handler.reset <= reset
    handler.io.in.valid <= UInt<1>("h0") @[StrideHandler.scala 37:23]
    wire _handler_io_in_bits_WIRE : { write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>} @[package.scala 75:57]
    _handler_io_in_bits_WIRE.reverse <= UInt<1>("h0") @[package.scala 75:57]
    _handler_io_in_bits_WIRE.stride <= UInt<3>("h0") @[package.scala 75:57]
    _handler_io_in_bits_WIRE.size <= UInt<20>("h0") @[package.scala 75:57]
    _handler_io_in_bits_WIRE.address <= UInt<20>("h0") @[package.scala 75:57]
    _handler_io_in_bits_WIRE.write <= UInt<1>("h0") @[package.scala 75:57]
    handler.io.in.bits.reverse <= _handler_io_in_bits_WIRE.reverse @[StrideHandler.scala 38:22]
    handler.io.in.bits.stride <= _handler_io_in_bits_WIRE.stride @[StrideHandler.scala 38:22]
    handler.io.in.bits.size <= _handler_io_in_bits_WIRE.size @[StrideHandler.scala 38:22]
    handler.io.in.bits.address <= _handler_io_in_bits_WIRE.address @[StrideHandler.scala 38:22]
    handler.io.in.bits.write <= _handler_io_in_bits_WIRE.write @[StrideHandler.scala 38:22]
    handler.io.out.ready <= UInt<1>("h0") @[StrideHandler.scala 39:24]
    node _T = eq(io.in.bits.stride, UInt<1>("h0")) @[StrideHandler.scala 41:23]
    when _T : @[StrideHandler.scala 41:32]
      io.out.bits.size <= io.in.bits.size @[StrideHandler.scala 44:36]
      io.out.bits.address <= io.in.bits.address @[StrideHandler.scala 44:36]
      io.out.bits.write <= io.in.bits.write @[StrideHandler.scala 44:36]
      io.out.bits.address <= io.in.bits.address @[StrideHandler.scala 47:25]
      io.out.bits.size <= io.in.bits.size @[StrideHandler.scala 48:22]
      io.in.ready <= io.out.ready @[StrideHandler.scala 49:14]
      io.out.valid <= io.in.valid @[StrideHandler.scala 50:18]
    else :
      handler.io.in <= io.in @[StrideHandler.scala 52:19]
      io.out.bits.size <= handler.io.out.bits.size @[StrideHandler.scala 55:36]
      io.out.bits.address <= handler.io.out.bits.address @[StrideHandler.scala 55:36]
      io.out.bits.write <= handler.io.out.bits.write @[StrideHandler.scala 55:36]
      io.out.bits.address <= handler.io.out.bits.address @[StrideHandler.scala 58:25]
      io.out.bits.size <= handler.io.out.bits.size @[StrideHandler.scala 59:22]
      handler.io.out.ready <= io.out.ready @[StrideHandler.scala 60:26]
      io.out.valid <= handler.io.out.valid @[StrideHandler.scala 61:18]

  module Queue_2 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>}}, count : UInt<1>}

    cmem ram : { write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>} [1] @[Decoupled.scala 259:95]
    wire enq_ptr_value : UInt
    enq_ptr_value <= UInt<1>("h0")
    wire deq_ptr_value : UInt
    deq_ptr_value <= UInt<1>("h0")
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[UInt<1>("h0")], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
    when do_deq : @[Decoupled.scala 276:16]
      skip
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[UInt<1>("h0")], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    when io.deq.ready : @[Decoupled.scala 309:24]
      io.enq.ready <= UInt<1>("h1") @[Decoupled.scala 309:39]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<1>("h1"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Queue_3 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>}}, count : UInt<1>}

    cmem ram : { write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>} [1] @[Decoupled.scala 259:95]
    wire enq_ptr_value : UInt
    enq_ptr_value <= UInt<1>("h0")
    wire deq_ptr_value : UInt
    deq_ptr_value <= UInt<1>("h0")
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[UInt<1>("h0")], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
    when do_deq : @[Decoupled.scala 276:16]
      skip
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[UInt<1>("h0")], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    when io.deq.ready : @[Decoupled.scala 309:24]
      io.enq.ready <= UInt<1>("h1") @[Decoupled.scala 309:39]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<1>("h1"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Counter_2 :
    input clock : Clock
    input reset : Reset
    output io : { value : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<13>}, flip resetValue : UInt<1>}

    reg value : UInt<13>, clock with :
      reset => (reset, UInt<13>("h0")) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h0")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<13>("h1fff")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h0") @[Counter.scala 22:13]
      else :
        node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h0") @[Counter.scala 28:11]

  module CountBy_2 :
    input clock : Clock
    input reset : Reset
    output io : { value : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<13>}, flip step : UInt<13>, flip resetValue : UInt<1>}

    reg value : UInt<13>, clock with :
      reset => (reset, UInt<13>("h0")) @[CountBy.scala 17:22]
    io.value.bits <= value @[CountBy.scala 19:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h0")) @[CountBy.scala 20:21]
    io.value.valid <= _io_value_valid_T @[CountBy.scala 20:18]
    when io.value.ready : @[CountBy.scala 21:24]
      node _T = sub(UInt<14>("h2000"), io.step) @[CountBy.scala 22:24]
      node _T_1 = tail(_T, 1) @[CountBy.scala 22:24]
      node _T_2 = geq(value, _T_1) @[CountBy.scala 22:16]
      when _T_2 : @[CountBy.scala 22:36]
        value <= UInt<1>("h0") @[CountBy.scala 23:13]
      else :
        node _value_T = add(value, io.step) @[CountBy.scala 25:22]
        node _value_T_1 = tail(_value_T, 1) @[CountBy.scala 25:22]
        value <= _value_T_1 @[CountBy.scala 25:13]
    when io.resetValue : @[CountBy.scala 28:23]
      value <= UInt<1>("h0") @[CountBy.scala 29:11]

  module SizeAndStrideHandler_2 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<13>, size : UInt<13>}}}

    node stride = dshl(UInt<1>("h1"), io.in.bits.stride) @[SizeAndStrideHandler.scala 30:20]
    inst sizeCounter of Counter_2 @[Counter.scala 34:19]
    sizeCounter.clock <= clock
    sizeCounter.reset <= reset
    sizeCounter.io.resetValue <= UInt<1>("h0") @[Counter.scala 35:21]
    sizeCounter.io.value.ready <= UInt<1>("h0") @[Counter.scala 36:22]
    inst addressCounter of CountBy_2 @[CountBy.scala 35:19]
    addressCounter.clock <= clock
    addressCounter.reset <= reset
    addressCounter.io.step <= stride @[CountBy.scala 36:15]
    addressCounter.io.resetValue <= UInt<1>("h0") @[CountBy.scala 37:21]
    addressCounter.io.value.ready <= UInt<1>("h0") @[CountBy.scala 38:22]
    io.out.valid <= io.in.valid @[SizeAndStrideHandler.scala 35:16]
    io.out.bits.size <= io.in.bits.size @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.address <= io.in.bits.address @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.write <= io.in.bits.write @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.size <= UInt<1>("h0") @[SizeAndStrideHandler.scala 43:34]
    when io.in.bits.reverse : @[SizeAndStrideHandler.scala 45:25]
      node _io_out_bits_address_T = sub(io.in.bits.address, addressCounter.io.value.bits) @[SizeAndStrideHandler.scala 46:44]
      node _io_out_bits_address_T_1 = tail(_io_out_bits_address_T, 1) @[SizeAndStrideHandler.scala 46:44]
      io.out.bits.address <= _io_out_bits_address_T_1 @[SizeAndStrideHandler.scala 46:25]
    else :
      node _io_out_bits_address_T_2 = add(io.in.bits.address, addressCounter.io.value.bits) @[SizeAndStrideHandler.scala 48:44]
      node _io_out_bits_address_T_3 = tail(_io_out_bits_address_T_2, 1) @[SizeAndStrideHandler.scala 48:44]
      io.out.bits.address <= _io_out_bits_address_T_3 @[SizeAndStrideHandler.scala 48:25]
    node fire = and(io.in.valid, io.out.ready) @[SizeAndStrideHandler.scala 51:23]
    node _T = eq(sizeCounter.io.value.bits, io.in.bits.size) @[SizeAndStrideHandler.scala 53:34]
    when _T : @[SizeAndStrideHandler.scala 53:52]
      io.in.ready <= io.out.ready @[SizeAndStrideHandler.scala 54:14]
      sizeCounter.io.resetValue <= fire @[SizeAndStrideHandler.scala 55:31]
      addressCounter.io.resetValue <= fire @[SizeAndStrideHandler.scala 56:34]
    else :
      io.in.ready <= UInt<1>("h0") @[SizeAndStrideHandler.scala 58:14]
      sizeCounter.io.value.ready <= fire @[SizeAndStrideHandler.scala 59:32]
      addressCounter.io.value.ready <= fire @[SizeAndStrideHandler.scala 60:35]

  module Counter_3 :
    input clock : Clock
    input reset : Reset
    output io : { value : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<13>}, flip resetValue : UInt<1>}

    reg value : UInt<13>, clock with :
      reset => (reset, UInt<13>("h0")) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h0")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<13>("h1fff")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h0") @[Counter.scala 22:13]
      else :
        node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h0") @[Counter.scala 28:11]

  module CountBy_3 :
    input clock : Clock
    input reset : Reset
    output io : { value : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<13>}, flip step : UInt<13>, flip resetValue : UInt<1>}

    reg value : UInt<13>, clock with :
      reset => (reset, UInt<13>("h0")) @[CountBy.scala 17:22]
    io.value.bits <= value @[CountBy.scala 19:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h0")) @[CountBy.scala 20:21]
    io.value.valid <= _io_value_valid_T @[CountBy.scala 20:18]
    when io.value.ready : @[CountBy.scala 21:24]
      node _T = sub(UInt<14>("h2000"), io.step) @[CountBy.scala 22:24]
      node _T_1 = tail(_T, 1) @[CountBy.scala 22:24]
      node _T_2 = geq(value, _T_1) @[CountBy.scala 22:16]
      when _T_2 : @[CountBy.scala 22:36]
        value <= UInt<1>("h0") @[CountBy.scala 23:13]
      else :
        node _value_T = add(value, io.step) @[CountBy.scala 25:22]
        node _value_T_1 = tail(_value_T, 1) @[CountBy.scala 25:22]
        value <= _value_T_1 @[CountBy.scala 25:13]
    when io.resetValue : @[CountBy.scala 28:23]
      value <= UInt<1>("h0") @[CountBy.scala 29:11]

  module SizeAndStrideHandler_3 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<13>, size : UInt<13>}}}

    node stride = dshl(UInt<1>("h1"), io.in.bits.stride) @[SizeAndStrideHandler.scala 30:20]
    inst sizeCounter of Counter_3 @[Counter.scala 34:19]
    sizeCounter.clock <= clock
    sizeCounter.reset <= reset
    sizeCounter.io.resetValue <= UInt<1>("h0") @[Counter.scala 35:21]
    sizeCounter.io.value.ready <= UInt<1>("h0") @[Counter.scala 36:22]
    inst addressCounter of CountBy_3 @[CountBy.scala 35:19]
    addressCounter.clock <= clock
    addressCounter.reset <= reset
    addressCounter.io.step <= stride @[CountBy.scala 36:15]
    addressCounter.io.resetValue <= UInt<1>("h0") @[CountBy.scala 37:21]
    addressCounter.io.value.ready <= UInt<1>("h0") @[CountBy.scala 38:22]
    io.out.valid <= io.in.valid @[SizeAndStrideHandler.scala 35:16]
    io.out.bits.size <= io.in.bits.size @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.address <= io.in.bits.address @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.write <= io.in.bits.write @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.size <= UInt<1>("h0") @[SizeAndStrideHandler.scala 43:34]
    when io.in.bits.reverse : @[SizeAndStrideHandler.scala 45:25]
      node _io_out_bits_address_T = sub(io.in.bits.address, addressCounter.io.value.bits) @[SizeAndStrideHandler.scala 46:44]
      node _io_out_bits_address_T_1 = tail(_io_out_bits_address_T, 1) @[SizeAndStrideHandler.scala 46:44]
      io.out.bits.address <= _io_out_bits_address_T_1 @[SizeAndStrideHandler.scala 46:25]
    else :
      node _io_out_bits_address_T_2 = add(io.in.bits.address, addressCounter.io.value.bits) @[SizeAndStrideHandler.scala 48:44]
      node _io_out_bits_address_T_3 = tail(_io_out_bits_address_T_2, 1) @[SizeAndStrideHandler.scala 48:44]
      io.out.bits.address <= _io_out_bits_address_T_3 @[SizeAndStrideHandler.scala 48:25]
    node fire = and(io.in.valid, io.out.ready) @[SizeAndStrideHandler.scala 51:23]
    node _T = eq(sizeCounter.io.value.bits, io.in.bits.size) @[SizeAndStrideHandler.scala 53:34]
    when _T : @[SizeAndStrideHandler.scala 53:52]
      io.in.ready <= io.out.ready @[SizeAndStrideHandler.scala 54:14]
      sizeCounter.io.resetValue <= fire @[SizeAndStrideHandler.scala 55:31]
      addressCounter.io.resetValue <= fire @[SizeAndStrideHandler.scala 56:34]
    else :
      io.in.ready <= UInt<1>("h0") @[SizeAndStrideHandler.scala 58:14]
      sizeCounter.io.value.ready <= fire @[SizeAndStrideHandler.scala 59:32]
      addressCounter.io.value.ready <= fire @[SizeAndStrideHandler.scala 60:35]

  module LockPool :
    input clock : Clock
    input reset : Reset
    output io : { actor : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}}}[2], flip lock : { flip ready : UInt<1>, valid : UInt<1>, bits : { cond : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}, lock : UInt<1>, acquire : UInt<1>, by : UInt<1>, delayRelease : UInt<4>}}, locked : { flip ready : UInt<1>, valid : UInt<1>, bits : { cond : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}, lock : UInt<1>, acquire : UInt<1>, by : UInt<1>, delayRelease : UInt<4>}}, deadlocked : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}}

    wire actor : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}}[2] @[LockPool.scala 52:28]
    actor[0] <= io.actor[0].in @[LockPool.scala 52:28]
    actor[1] <= io.actor[1].in @[LockPool.scala 52:28]
    wire _lock_WIRE : { cond : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}, held : UInt<1>, by : UInt<1>, delayRelease : UInt<4>} @[package.scala 75:57]
    _lock_WIRE.delayRelease <= UInt<4>("h0") @[package.scala 75:57]
    _lock_WIRE.by <= UInt<1>("h0") @[package.scala 75:57]
    _lock_WIRE.held <= UInt<1>("h0") @[package.scala 75:57]
    _lock_WIRE.cond.reverse <= UInt<1>("h0") @[package.scala 75:57]
    _lock_WIRE.cond.stride <= UInt<3>("h0") @[package.scala 75:57]
    _lock_WIRE.cond.size <= UInt<13>("h0") @[package.scala 75:57]
    _lock_WIRE.cond.address <= UInt<13>("h0") @[package.scala 75:57]
    _lock_WIRE.cond.write <= UInt<1>("h0") @[package.scala 75:57]
    wire _lock_WIRE_1 : { cond : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}, held : UInt<1>, by : UInt<1>, delayRelease : UInt<4>} @[package.scala 75:57]
    _lock_WIRE_1.delayRelease <= UInt<4>("h0") @[package.scala 75:57]
    _lock_WIRE_1.by <= UInt<1>("h0") @[package.scala 75:57]
    _lock_WIRE_1.held <= UInt<1>("h0") @[package.scala 75:57]
    _lock_WIRE_1.cond.reverse <= UInt<1>("h0") @[package.scala 75:57]
    _lock_WIRE_1.cond.stride <= UInt<3>("h0") @[package.scala 75:57]
    _lock_WIRE_1.cond.size <= UInt<13>("h0") @[package.scala 75:57]
    _lock_WIRE_1.cond.address <= UInt<13>("h0") @[package.scala 75:57]
    _lock_WIRE_1.cond.write <= UInt<1>("h0") @[package.scala 75:57]
    wire _lock_WIRE_2 : { cond : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}, held : UInt<1>, by : UInt<1>, delayRelease : UInt<4>}[2] @[LockPool.scala 56:12]
    _lock_WIRE_2[0] <= _lock_WIRE @[LockPool.scala 56:12]
    _lock_WIRE_2[1] <= _lock_WIRE_1 @[LockPool.scala 56:12]
    reg lock : { cond : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}, held : UInt<1>, by : UInt<1>, delayRelease : UInt<4>}[2], clock with :
      reset => (reset, _lock_WIRE_2) @[LockPool.scala 55:21]
    io.actor[0].out.valid <= UInt<1>("h0") @[Decoupled.scala 72:20]
    io.actor[0].out.bits.reverse is invalid @[Decoupled.scala 73:19]
    io.actor[0].out.bits.stride is invalid @[Decoupled.scala 73:19]
    io.actor[0].out.bits.size is invalid @[Decoupled.scala 73:19]
    io.actor[0].out.bits.address is invalid @[Decoupled.scala 73:19]
    io.actor[0].out.bits.write is invalid @[Decoupled.scala 73:19]
    actor[0].ready <= UInt<1>("h0") @[LockPool.scala 66:13]
    node block_requiredLockId = div(actor[0].bits.address, UInt<13>("h1000")) @[Decoder.scala 191:15]
    node _block_requiredLock_T = bits(block_requiredLockId, 0, 0)
    node _block_blocked_T = neq(lock[_block_requiredLock_T].by, UInt<1>("h0")) @[LockPool.scala 70:45]
    node _block_blocked_T_1 = and(lock[_block_requiredLock_T].held, _block_blocked_T) @[LockPool.scala 70:26]
    node _block_blocked_T_2 = and(io.lock.ready, io.lock.valid) @[Decoupled.scala 50:35]
    node _block_blocked_T_3 = eq(io.lock.bits.lock, block_requiredLockId) @[LockPool.scala 70:101]
    node _block_blocked_T_4 = and(_block_blocked_T_2, _block_blocked_T_3) @[LockPool.scala 70:76]
    node _block_blocked_T_5 = neq(io.lock.bits.by, UInt<1>("h0")) @[LockPool.scala 70:143]
    node _block_blocked_T_6 = and(_block_blocked_T_4, _block_blocked_T_5) @[LockPool.scala 70:120]
    node block_blocked = or(_block_blocked_T_1, _block_blocked_T_6) @[LockPool.scala 70:55]
    node _block_T = eq(block_blocked, UInt<1>("h0")) @[LockPool.scala 71:10]
    when _block_T : @[LockPool.scala 71:20]
      io.actor[0].out <= actor[0] @[LockPool.scala 73:24]
    io.actor[1].out.valid <= UInt<1>("h0") @[Decoupled.scala 72:20]
    io.actor[1].out.bits.reverse is invalid @[Decoupled.scala 73:19]
    io.actor[1].out.bits.stride is invalid @[Decoupled.scala 73:19]
    io.actor[1].out.bits.size is invalid @[Decoupled.scala 73:19]
    io.actor[1].out.bits.address is invalid @[Decoupled.scala 73:19]
    io.actor[1].out.bits.write is invalid @[Decoupled.scala 73:19]
    actor[1].ready <= UInt<1>("h0") @[LockPool.scala 66:13]
    node block_requiredLockId_1 = div(actor[1].bits.address, UInt<13>("h1000")) @[Decoder.scala 191:15]
    node _block_requiredLock_T_1 = bits(block_requiredLockId_1, 0, 0)
    node _block_blocked_T_7 = neq(lock[_block_requiredLock_T_1].by, UInt<1>("h1")) @[LockPool.scala 70:45]
    node _block_blocked_T_8 = and(lock[_block_requiredLock_T_1].held, _block_blocked_T_7) @[LockPool.scala 70:26]
    node _block_blocked_T_9 = and(io.lock.ready, io.lock.valid) @[Decoupled.scala 50:35]
    node _block_blocked_T_10 = eq(io.lock.bits.lock, block_requiredLockId_1) @[LockPool.scala 70:101]
    node _block_blocked_T_11 = and(_block_blocked_T_9, _block_blocked_T_10) @[LockPool.scala 70:76]
    node _block_blocked_T_12 = neq(io.lock.bits.by, UInt<1>("h1")) @[LockPool.scala 70:143]
    node _block_blocked_T_13 = and(_block_blocked_T_11, _block_blocked_T_12) @[LockPool.scala 70:120]
    node block_blocked_1 = or(_block_blocked_T_8, _block_blocked_T_13) @[LockPool.scala 70:55]
    node _block_T_1 = eq(block_blocked_1, UInt<1>("h0")) @[LockPool.scala 71:10]
    when _block_T_1 : @[LockPool.scala 71:20]
      io.actor[1].out <= actor[1] @[LockPool.scala 73:24]
    wire block : UInt<1>[2] @[LockPool.scala 63:22]
    block[0] <= block_blocked @[LockPool.scala 63:22]
    block[1] <= block_blocked_1 @[LockPool.scala 63:22]
    io.locked.bits <= io.lock.bits @[LockPool.scala 79:18]
    node _io_locked_valid_T = and(io.lock.ready, io.lock.valid) @[Decoupled.scala 50:35]
    io.locked.valid <= _io_locked_valid_T @[LockPool.scala 80:19]
    io.deadlocked.valid <= UInt<1>("h0") @[Decoupled.scala 72:20]
    io.deadlocked.bits is invalid @[Decoupled.scala 73:19]
    node _incomingObserved_T = and(actor[io.lock.bits.by].ready, actor[io.lock.bits.by].valid) @[Decoupled.scala 50:35]
    node _incomingObserved_T_1 = and(io.lock.valid, _incomingObserved_T) @[LockPool.scala 98:23]
    node _incomingObserved_T_2 = eq(actor[io.lock.bits.by].bits.address, io.lock.bits.cond.address) @[MemControl.scala 21:13]
    node _incomingObserved_T_3 = eq(actor[io.lock.bits.by].bits.write, io.lock.bits.cond.write) @[MemControl.scala 21:40]
    node _incomingObserved_T_4 = and(_incomingObserved_T_2, _incomingObserved_T_3) @[MemControl.scala 21:31]
    node _incomingObserved_T_5 = eq(actor[io.lock.bits.by].bits.size, io.lock.bits.cond.size) @[MemControl.scala 21:64]
    node _incomingObserved_T_6 = and(_incomingObserved_T_4, _incomingObserved_T_5) @[MemControl.scala 21:56]
    node _incomingObserved_T_7 = eq(actor[io.lock.bits.by].bits.stride, io.lock.bits.cond.stride) @[MemControl.scala 21:89]
    node _incomingObserved_T_8 = and(_incomingObserved_T_6, _incomingObserved_T_7) @[MemControl.scala 21:79]
    node _incomingObserved_T_9 = eq(actor[io.lock.bits.by].bits.reverse, io.lock.bits.cond.reverse) @[MemControl.scala 21:117]
    node _incomingObserved_T_10 = and(_incomingObserved_T_8, _incomingObserved_T_9) @[MemControl.scala 21:106]
    node incomingObserved = and(_incomingObserved_T_1, _incomingObserved_T_10) @[LockPool.scala 98:58]
    node _io_lock_ready_T = neq(io.lock.bits.by, lock[io.lock.bits.lock].by) @[LockPool.scala 104:68]
    node _io_lock_ready_T_1 = and(lock[io.lock.bits.lock].held, _io_lock_ready_T) @[LockPool.scala 104:45]
    node _io_lock_ready_T_2 = eq(_io_lock_ready_T_1, UInt<1>("h0")) @[LockPool.scala 104:24]
    io.lock.ready <= _io_lock_ready_T_2 @[LockPool.scala 104:21]
    node incoming = eq(io.lock.bits.lock, UInt<1>("h0")) @[LockPool.scala 106:42]
    node _observed_T = and(actor[lock[0].by].ready, actor[lock[0].by].valid) @[Decoupled.scala 50:35]
    node _observed_T_1 = eq(actor[lock[0].by].bits.address, lock[0].cond.address) @[MemControl.scala 21:13]
    node _observed_T_2 = eq(actor[lock[0].by].bits.write, lock[0].cond.write) @[MemControl.scala 21:40]
    node _observed_T_3 = and(_observed_T_1, _observed_T_2) @[MemControl.scala 21:31]
    node _observed_T_4 = eq(actor[lock[0].by].bits.size, lock[0].cond.size) @[MemControl.scala 21:64]
    node _observed_T_5 = and(_observed_T_3, _observed_T_4) @[MemControl.scala 21:56]
    node _observed_T_6 = eq(actor[lock[0].by].bits.stride, lock[0].cond.stride) @[MemControl.scala 21:89]
    node _observed_T_7 = and(_observed_T_5, _observed_T_6) @[MemControl.scala 21:79]
    node _observed_T_8 = eq(actor[lock[0].by].bits.reverse, lock[0].cond.reverse) @[MemControl.scala 21:117]
    node _observed_T_9 = and(_observed_T_7, _observed_T_8) @[MemControl.scala 21:106]
    node observed = and(_observed_T, _observed_T_9) @[LockPool.scala 107:37]
    when lock[0].held : @[LockPool.scala 108:18]
      when observed : @[LockPool.scala 109:22]
        when incoming : @[LockPool.scala 110:24]
          when incomingObserved : @[LockPool.scala 111:34]
            lock[0].held <= UInt<1>("h0") @[LockPool.scala 93:12]
          else :
            lock[0].held <= UInt<1>("h0") @[LockPool.scala 93:12]
            when io.lock.valid : @[LockPool.scala 86:29]
              lock[0].held <= io.lock.bits.acquire @[LockPool.scala 87:14]
              lock[0].by <= io.lock.bits.by @[LockPool.scala 88:12]
              lock[0].cond <= io.lock.bits.cond @[LockPool.scala 89:14]
        else :
          lock[0].held <= UInt<1>("h0") @[LockPool.scala 93:12]
      else :
        when incoming : @[LockPool.scala 122:24]
          node _T = eq(lock[0].by, io.lock.bits.by) @[LockPool.scala 123:21]
          when _T : @[LockPool.scala 123:46]
            when io.lock.valid : @[LockPool.scala 86:29]
              lock[0].held <= io.lock.bits.acquire @[LockPool.scala 87:14]
              lock[0].by <= io.lock.bits.by @[LockPool.scala 88:12]
              lock[0].cond <= io.lock.bits.cond @[LockPool.scala 89:14]
    else :
      when incoming : @[LockPool.scala 130:22]
        node _T_1 = eq(incomingObserved, UInt<1>("h0")) @[LockPool.scala 131:14]
        when _T_1 : @[LockPool.scala 131:33]
          when io.lock.valid : @[LockPool.scala 86:29]
            lock[0].held <= io.lock.bits.acquire @[LockPool.scala 87:14]
            lock[0].by <= io.lock.bits.by @[LockPool.scala 88:12]
            lock[0].cond <= io.lock.bits.cond @[LockPool.scala 89:14]
    node incoming_1 = eq(io.lock.bits.lock, UInt<1>("h1")) @[LockPool.scala 106:42]
    node _observed_T_10 = and(actor[lock[1].by].ready, actor[lock[1].by].valid) @[Decoupled.scala 50:35]
    node _observed_T_11 = eq(actor[lock[1].by].bits.address, lock[1].cond.address) @[MemControl.scala 21:13]
    node _observed_T_12 = eq(actor[lock[1].by].bits.write, lock[1].cond.write) @[MemControl.scala 21:40]
    node _observed_T_13 = and(_observed_T_11, _observed_T_12) @[MemControl.scala 21:31]
    node _observed_T_14 = eq(actor[lock[1].by].bits.size, lock[1].cond.size) @[MemControl.scala 21:64]
    node _observed_T_15 = and(_observed_T_13, _observed_T_14) @[MemControl.scala 21:56]
    node _observed_T_16 = eq(actor[lock[1].by].bits.stride, lock[1].cond.stride) @[MemControl.scala 21:89]
    node _observed_T_17 = and(_observed_T_15, _observed_T_16) @[MemControl.scala 21:79]
    node _observed_T_18 = eq(actor[lock[1].by].bits.reverse, lock[1].cond.reverse) @[MemControl.scala 21:117]
    node _observed_T_19 = and(_observed_T_17, _observed_T_18) @[MemControl.scala 21:106]
    node observed_1 = and(_observed_T_10, _observed_T_19) @[LockPool.scala 107:37]
    when lock[1].held : @[LockPool.scala 108:18]
      when observed_1 : @[LockPool.scala 109:22]
        when incoming_1 : @[LockPool.scala 110:24]
          when incomingObserved : @[LockPool.scala 111:34]
            lock[1].held <= UInt<1>("h0") @[LockPool.scala 93:12]
          else :
            lock[1].held <= UInt<1>("h0") @[LockPool.scala 93:12]
            when io.lock.valid : @[LockPool.scala 86:29]
              lock[1].held <= io.lock.bits.acquire @[LockPool.scala 87:14]
              lock[1].by <= io.lock.bits.by @[LockPool.scala 88:12]
              lock[1].cond <= io.lock.bits.cond @[LockPool.scala 89:14]
        else :
          lock[1].held <= UInt<1>("h0") @[LockPool.scala 93:12]
      else :
        when incoming_1 : @[LockPool.scala 122:24]
          node _T_2 = eq(lock[1].by, io.lock.bits.by) @[LockPool.scala 123:21]
          when _T_2 : @[LockPool.scala 123:46]
            when io.lock.valid : @[LockPool.scala 86:29]
              lock[1].held <= io.lock.bits.acquire @[LockPool.scala 87:14]
              lock[1].by <= io.lock.bits.by @[LockPool.scala 88:12]
              lock[1].cond <= io.lock.bits.cond @[LockPool.scala 89:14]
    else :
      when incoming_1 : @[LockPool.scala 130:22]
        node _T_3 = eq(incomingObserved, UInt<1>("h0")) @[LockPool.scala 131:14]
        when _T_3 : @[LockPool.scala 131:33]
          when io.lock.valid : @[LockPool.scala 86:29]
            lock[1].held <= io.lock.bits.acquire @[LockPool.scala 87:14]
            lock[1].by <= io.lock.bits.by @[LockPool.scala 88:12]
            lock[1].cond <= io.lock.bits.cond @[LockPool.scala 89:14]
    node _T_4 = and(block[0], block[1]) @[LockPool.scala 139:33]
    when _T_4 : @[LockPool.scala 139:40]
      io.actor[lock[UInt<1>("h0")].by].out <= actor[lock[UInt<1>("h0")].by] @[LockPool.scala 140:32]
      io.deadlocked.bits <= UInt<1>("h1") @[LockPool.scala 142:24]
      io.deadlocked.valid <= UInt<1>("h1") @[LockPool.scala 143:25]

  module Counter_4 :
    input clock : Clock
    input reset : Reset
    output io : { value : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<11>}, flip resetValue : UInt<1>}

    reg value : UInt<11>, clock with :
      reset => (reset, UInt<11>("h0")) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h0")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<11>("h7ff")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h0") @[Counter.scala 22:13]
      else :
        node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h0") @[Counter.scala 28:11]

  module CountBy_4 :
    input clock : Clock
    input reset : Reset
    output io : { value : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<11>}, flip step : UInt<11>, flip resetValue : UInt<1>}

    reg value : UInt<11>, clock with :
      reset => (reset, UInt<11>("h0")) @[CountBy.scala 17:22]
    io.value.bits <= value @[CountBy.scala 19:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h0")) @[CountBy.scala 20:21]
    io.value.valid <= _io_value_valid_T @[CountBy.scala 20:18]
    when io.value.ready : @[CountBy.scala 21:24]
      node _T = sub(UInt<12>("h800"), io.step) @[CountBy.scala 22:24]
      node _T_1 = tail(_T, 1) @[CountBy.scala 22:24]
      node _T_2 = geq(value, _T_1) @[CountBy.scala 22:16]
      when _T_2 : @[CountBy.scala 22:36]
        value <= UInt<1>("h0") @[CountBy.scala 23:13]
      else :
        node _value_T = add(value, io.step) @[CountBy.scala 25:22]
        node _value_T_1 = tail(_value_T, 1) @[CountBy.scala 25:22]
        value <= _value_T_1 @[CountBy.scala 25:13]
    when io.resetValue : @[CountBy.scala 28:23]
      value <= UInt<1>("h0") @[CountBy.scala 29:11]

  module SizeAndStrideHandler_4 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : { instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<11>, altAddress : UInt<11>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<11>, stride : UInt<3>, reverse : UInt<1>}}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : { instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<11>, altAddress : UInt<11>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>}}}

    node stride = dshl(UInt<1>("h1"), io.in.bits.stride) @[SizeAndStrideHandler.scala 30:20]
    inst sizeCounter of Counter_4 @[Counter.scala 34:19]
    sizeCounter.clock <= clock
    sizeCounter.reset <= reset
    sizeCounter.io.resetValue <= UInt<1>("h0") @[Counter.scala 35:21]
    sizeCounter.io.value.ready <= UInt<1>("h0") @[Counter.scala 36:22]
    inst addressCounter of CountBy_4 @[CountBy.scala 35:19]
    addressCounter.clock <= clock
    addressCounter.reset <= reset
    addressCounter.io.step <= stride @[CountBy.scala 36:15]
    addressCounter.io.resetValue <= UInt<1>("h0") @[CountBy.scala 37:21]
    addressCounter.io.value.ready <= UInt<1>("h0") @[CountBy.scala 38:22]
    io.out.valid <= io.in.valid @[SizeAndStrideHandler.scala 35:16]
    io.out.bits.accumulate <= io.in.bits.accumulate @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.write <= io.in.bits.write @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.read <= io.in.bits.read @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.altAddress <= io.in.bits.altAddress @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.address <= io.in.bits.address @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.instruction <= io.in.bits.instruction @[SizeAndStrideHandler.scala 38:34]
    when io.in.bits.reverse : @[SizeAndStrideHandler.scala 45:25]
      node _io_out_bits_address_T = sub(io.in.bits.address, addressCounter.io.value.bits) @[SizeAndStrideHandler.scala 46:44]
      node _io_out_bits_address_T_1 = tail(_io_out_bits_address_T, 1) @[SizeAndStrideHandler.scala 46:44]
      io.out.bits.address <= _io_out_bits_address_T_1 @[SizeAndStrideHandler.scala 46:25]
    else :
      node _io_out_bits_address_T_2 = add(io.in.bits.address, addressCounter.io.value.bits) @[SizeAndStrideHandler.scala 48:44]
      node _io_out_bits_address_T_3 = tail(_io_out_bits_address_T_2, 1) @[SizeAndStrideHandler.scala 48:44]
      io.out.bits.address <= _io_out_bits_address_T_3 @[SizeAndStrideHandler.scala 48:25]
    node fire = and(io.in.valid, io.out.ready) @[SizeAndStrideHandler.scala 51:23]
    node _T = eq(sizeCounter.io.value.bits, io.in.bits.size) @[SizeAndStrideHandler.scala 53:34]
    when _T : @[SizeAndStrideHandler.scala 53:52]
      io.in.ready <= io.out.ready @[SizeAndStrideHandler.scala 54:14]
      sizeCounter.io.resetValue <= fire @[SizeAndStrideHandler.scala 55:31]
      addressCounter.io.resetValue <= fire @[SizeAndStrideHandler.scala 56:34]
    else :
      io.in.ready <= UInt<1>("h0") @[SizeAndStrideHandler.scala 58:14]
      sizeCounter.io.value.ready <= fire @[SizeAndStrideHandler.scala 59:32]
      addressCounter.io.value.ready <= fire @[SizeAndStrideHandler.scala 60:35]

  module Queue_4 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<11>, altAddress : UInt<11>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<11>, stride : UInt<3>, reverse : UInt<1>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<11>, altAddress : UInt<11>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<11>, stride : UInt<3>, reverse : UInt<1>}}, count : UInt<5>}

    cmem ram : { instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<11>, altAddress : UInt<11>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<11>, stride : UInt<3>, reverse : UInt<1>} [16] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<4>, clock with :
      reset => (reset, UInt<4>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<4>, clock with :
      reset => (reset, UInt<4>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<4>("hf")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<4>("hf")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    when io.deq.ready : @[Decoupled.scala 309:24]
      io.enq.ready <= UInt<1>("h1") @[Decoupled.scala 309:39]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<5>("h10"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Counter_5 :
    input clock : Clock
    input reset : Reset
    output io : { value : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<13>}, flip resetValue : UInt<1>}

    reg value : UInt<13>, clock with :
      reset => (reset, UInt<13>("h0")) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h0")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<13>("h1fff")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h0") @[Counter.scala 22:13]
      else :
        node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h0") @[Counter.scala 28:11]

  module SizeHandler :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : { load : UInt<1>, zeroes : UInt<1>, size : UInt<13>}}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : { load : UInt<1>, zeroes : UInt<1>}}}

    inst sizeCounter of Counter_5 @[Counter.scala 34:19]
    sizeCounter.clock <= clock
    sizeCounter.reset <= reset
    sizeCounter.io.resetValue <= UInt<1>("h0") @[Counter.scala 35:21]
    sizeCounter.io.value.ready <= UInt<1>("h0") @[Counter.scala 36:22]
    io.out.valid <= io.in.valid @[SizeHandler.scala 25:16]
    io.out.bits.zeroes <= io.in.bits.zeroes @[SizeHandler.scala 28:34]
    io.out.bits.load <= io.in.bits.load @[SizeHandler.scala 28:34]
    node fire = and(io.in.valid, io.out.ready) @[SizeHandler.scala 32:23]
    node _T = eq(sizeCounter.io.value.bits, io.in.bits.size) @[SizeHandler.scala 34:34]
    when _T : @[SizeHandler.scala 34:52]
      io.in.ready <= io.out.ready @[SizeHandler.scala 35:14]
      sizeCounter.io.resetValue <= fire @[SizeHandler.scala 36:31]
    else :
      io.in.ready <= UInt<1>("h0") @[SizeHandler.scala 38:14]
      sizeCounter.io.value.ready <= fire @[SizeHandler.scala 39:32]

  module Queue_5 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { load : UInt<1>, zeroes : UInt<1>, size : UInt<13>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { load : UInt<1>, zeroes : UInt<1>, size : UInt<13>}}, count : UInt<5>}

    cmem ram : { load : UInt<1>, zeroes : UInt<1>, size : UInt<13>} [16] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<4>, clock with :
      reset => (reset, UInt<4>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<4>, clock with :
      reset => (reset, UInt<4>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<4>("hf")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<4>("hf")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    when io.deq.ready : @[Decoupled.scala 309:24]
      io.enq.ready <= UInt<1>("h1") @[Decoupled.scala 309:39]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<5>("h10"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Queue_6 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { kind : UInt<4>, size : UInt<13>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { kind : UInt<4>, size : UInt<13>}}, count : UInt<5>}

    cmem ram : { kind : UInt<4>, size : UInt<13>} [16] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<4>, clock with :
      reset => (reset, UInt<4>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<4>, clock with :
      reset => (reset, UInt<4>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<4>("hf")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<4>("hf")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    when io.deq.ready : @[Decoupled.scala 309:24]
      io.enq.ready <= UInt<1>("h1") @[Decoupled.scala 309:39]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<5>("h10"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Counter_6 :
    input clock : Clock
    input reset : Reset
    output io : { value : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<13>}, flip resetValue : UInt<1>}

    reg value : UInt<13>, clock with :
      reset => (reset, UInt<13>("h0")) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h0")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<13>("h1fff")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h0") @[Counter.scala 22:13]
      else :
        node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h0") @[Counter.scala 28:11]

  module SizeHandler_1 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : { kind : UInt<2>, size : UInt<13>}}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : { kind : UInt<2>}}}

    inst sizeCounter of Counter_6 @[Counter.scala 34:19]
    sizeCounter.clock <= clock
    sizeCounter.reset <= reset
    sizeCounter.io.resetValue <= UInt<1>("h0") @[Counter.scala 35:21]
    sizeCounter.io.value.ready <= UInt<1>("h0") @[Counter.scala 36:22]
    io.out.valid <= io.in.valid @[SizeHandler.scala 25:16]
    io.out.bits.kind <= io.in.bits.kind @[SizeHandler.scala 28:34]
    node fire = and(io.in.valid, io.out.ready) @[SizeHandler.scala 32:23]
    node _T = eq(sizeCounter.io.value.bits, io.in.bits.size) @[SizeHandler.scala 34:34]
    when _T : @[SizeHandler.scala 34:52]
      io.in.ready <= io.out.ready @[SizeHandler.scala 35:14]
      sizeCounter.io.resetValue <= fire @[SizeHandler.scala 36:31]
    else :
      io.in.ready <= UInt<1>("h0") @[SizeHandler.scala 38:14]
      sizeCounter.io.value.ready <= fire @[SizeHandler.scala 39:32]

  module Queue_7 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { kind : UInt<2>, size : UInt<13>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { kind : UInt<2>, size : UInt<13>}}, count : UInt<1>}

    cmem ram : { kind : UInt<2>, size : UInt<13>} [1] @[Decoupled.scala 259:95]
    wire enq_ptr_value : UInt
    enq_ptr_value <= UInt<1>("h0")
    wire deq_ptr_value : UInt
    deq_ptr_value <= UInt<1>("h0")
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[UInt<1>("h0")], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
    when do_deq : @[Decoupled.scala 276:16]
      skip
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[UInt<1>("h0")], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    when io.deq.ready : @[Decoupled.scala 309:24]
      io.enq.ready <= UInt<1>("h1") @[Decoupled.scala 309:39]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<1>("h1"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module MultiEnqueue :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>}[1]}

    reg enq_0 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    node allEnqueued = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]

  module MultiEnqueue_1 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>}[2]}

    reg enq_0 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node allEnqueued = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_1 = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]

  module MultiEnqueue_2 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>}[3]}

    reg enq_0 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_2 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_2 = or(io.out[2].ready, enq_2) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_3 = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node allEnqueued = and(_allEnqueued_T_3, _allEnqueued_T_2) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_1 = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
    node _io_out_2_valid_T = eq(enq_2, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_2_valid_T_1 = and(io.in.valid, _io_out_2_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[2].valid <= _io_out_2_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_2 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_2 = eq(enq_2, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_2 : @[MultiEnqueue.scala 31:21]
        node _enq_2_T = and(io.out[2].valid, io.out[2].ready) @[MultiEnqueue.scala 32:35]
        enq_2 <= _enq_2_T @[MultiEnqueue.scala 32:16]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]

  module MultiEnqueue_3 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>}[4]}

    reg enq_0 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_2 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_3 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_2 = or(io.out[2].ready, enq_2) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_3 = or(io.out[3].ready, enq_3) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_4 = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _allEnqueued_T_5 = and(_allEnqueued_T_4, _allEnqueued_T_2) @[MultiEnqueue.scala 24:15]
    node allEnqueued = and(_allEnqueued_T_5, _allEnqueued_T_3) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_1 = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
    node _io_out_2_valid_T = eq(enq_2, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_2_valid_T_1 = and(io.in.valid, _io_out_2_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[2].valid <= _io_out_2_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_2 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_2 = eq(enq_2, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_2 : @[MultiEnqueue.scala 31:21]
        node _enq_2_T = and(io.out[2].valid, io.out[2].ready) @[MultiEnqueue.scala 32:35]
        enq_2 <= _enq_2_T @[MultiEnqueue.scala 32:16]
    node _io_out_3_valid_T = eq(enq_3, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_3_valid_T_1 = and(io.in.valid, _io_out_3_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[3].valid <= _io_out_3_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_3 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_3 = eq(enq_3, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_3 : @[MultiEnqueue.scala 31:21]
        node _enq_3_T = and(io.out[3].valid, io.out[3].ready) @[MultiEnqueue.scala 32:35]
        enq_3 <= _enq_3_T @[MultiEnqueue.scala 32:16]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]

  module MultiEnqueue_4 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>}[5]}

    reg enq_0 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_2 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_3 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_4 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_2 = or(io.out[2].ready, enq_2) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_3 = or(io.out[3].ready, enq_3) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_4 = or(io.out[4].ready, enq_4) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_5 = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _allEnqueued_T_6 = and(_allEnqueued_T_5, _allEnqueued_T_2) @[MultiEnqueue.scala 24:15]
    node _allEnqueued_T_7 = and(_allEnqueued_T_6, _allEnqueued_T_3) @[MultiEnqueue.scala 24:15]
    node allEnqueued = and(_allEnqueued_T_7, _allEnqueued_T_4) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_1 = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
    node _io_out_2_valid_T = eq(enq_2, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_2_valid_T_1 = and(io.in.valid, _io_out_2_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[2].valid <= _io_out_2_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_2 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_2 = eq(enq_2, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_2 : @[MultiEnqueue.scala 31:21]
        node _enq_2_T = and(io.out[2].valid, io.out[2].ready) @[MultiEnqueue.scala 32:35]
        enq_2 <= _enq_2_T @[MultiEnqueue.scala 32:16]
    node _io_out_3_valid_T = eq(enq_3, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_3_valid_T_1 = and(io.in.valid, _io_out_3_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[3].valid <= _io_out_3_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_3 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_3 = eq(enq_3, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_3 : @[MultiEnqueue.scala 31:21]
        node _enq_3_T = and(io.out[3].valid, io.out[3].ready) @[MultiEnqueue.scala 32:35]
        enq_3 <= _enq_3_T @[MultiEnqueue.scala 32:16]
    node _io_out_4_valid_T = eq(enq_4, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_4_valid_T_1 = and(io.in.valid, _io_out_4_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[4].valid <= _io_out_4_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_4 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_4 = eq(enq_4, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_4 : @[MultiEnqueue.scala 31:21]
        node _enq_4_T = and(io.out[4].valid, io.out[4].ready) @[MultiEnqueue.scala 32:35]
        enq_4 <= _enq_4_T @[MultiEnqueue.scala 32:16]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]

  module Decoder :
    input clock : Clock
    input reset : Reset
    output io : { flip instruction : { flip ready : UInt<1>, valid : UInt<1>, bits : { opcode : UInt<4>, flags : UInt<4>, arguments : UInt<56>}}, memPortA : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<13>, size : UInt<13>}}, memPortB : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<13>, size : UInt<13>}}, dram0 : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>}}, dram1 : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>}}, dataflow : { flip ready : UInt<1>, valid : UInt<1>, bits : { kind : UInt<4>, size : UInt<13>}}, hostDataflow : { flip ready : UInt<1>, valid : UInt<1>, bits : { kind : UInt<2>}}, acc : { flip ready : UInt<1>, valid : UInt<1>, bits : { instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, readAddress : UInt<11>, writeAddress : UInt<11>, accumulate : UInt<1>, write : UInt<1>, read : UInt<1>}}, array : { flip ready : UInt<1>, valid : UInt<1>, bits : { load : UInt<1>, zeroes : UInt<1>}}, config : { dram0AddressOffset : UInt<32>, dram0CacheBehaviour : UInt<4>, dram1AddressOffset : UInt<32>, dram1CacheBehaviour : UInt<4>}, status : { flip ready : UInt<1>, valid : UInt<1>, bits : { last : UInt<1>, bits : { opcode : UInt<4>, flags : UInt<4>, arguments : UInt<56>}}}, timeout : UInt<1>, error : UInt<1>, tracepoint : UInt<1>, programCounter : UInt<32>, sample : { flip ready : UInt<1>, valid : UInt<1>, bits : { last : UInt<1>, bits : { flags : { instruction : { ready : UInt<1>, valid : UInt<1>}, memPortA : { ready : UInt<1>, valid : UInt<1>}, memPortB : { ready : UInt<1>, valid : UInt<1>}, dram0 : { ready : UInt<1>, valid : UInt<1>}, dram1 : { ready : UInt<1>, valid : UInt<1>}, dataflow : { ready : UInt<1>, valid : UInt<1>}, acc : { ready : UInt<1>, valid : UInt<1>}, array : { ready : UInt<1>, valid : UInt<1>}}, programCounter : UInt<32>}}}, skipped : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, nooped : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}}

    inst instruction of Queue @[Decoupled.scala 361:21]
    instruction.clock <= clock
    instruction.reset <= reset
    instruction.io.enq.valid <= io.instruction.valid @[Decoupled.scala 363:22]
    instruction.io.enq.bits.arguments <= io.instruction.bits.arguments @[Decoupled.scala 364:21]
    instruction.io.enq.bits.flags <= io.instruction.bits.flags @[Decoupled.scala 364:21]
    instruction.io.enq.bits.opcode <= io.instruction.bits.opcode @[Decoupled.scala 364:21]
    io.instruction.ready <= instruction.io.enq.ready @[Decoupled.scala 365:17]
    inst status of Queue_1 @[Decoder.scala 83:23]
    status.clock <= clock
    status.reset <= reset
    node _status_io_enq_valid_T = and(instruction.io.deq.valid, instruction.io.deq.ready) @[Decoder.scala 90:44]
    status.io.enq.valid <= _status_io_enq_valid_T @[Decoder.scala 90:23]
    status.io.enq.bits.bits.arguments <= instruction.io.deq.bits.arguments @[Decoder.scala 91:27]
    status.io.enq.bits.bits.flags <= instruction.io.deq.bits.flags @[Decoder.scala 91:27]
    status.io.enq.bits.bits.opcode <= instruction.io.deq.bits.opcode @[Decoder.scala 91:27]
    status.io.enq.bits.last <= UInt<1>("h1") @[Decoder.scala 92:27]
    io.status.bits <= status.io.deq.bits @[Decoder.scala 93:13]
    io.status.valid <= status.io.deq.valid @[Decoder.scala 93:13]
    status.io.deq.ready <= io.status.ready @[Decoder.scala 93:13]
    reg timeout : UInt<16>, clock with :
      reset => (reset, UInt<16>("h64")) @[Decoder.scala 96:24]
    reg timer : UInt<16>, clock with :
      reset => (reset, UInt<16>("h0")) @[Decoder.scala 97:24]
    when instruction.io.deq.ready : @[Decoder.scala 98:27]
      timer <= UInt<1>("h0") @[Decoder.scala 99:11]
    else :
      node _T = lt(timer, timeout) @[Decoder.scala 101:16]
      when _T : @[Decoder.scala 101:27]
        node _timer_T = add(timer, UInt<1>("h1")) @[Decoder.scala 102:22]
        node _timer_T_1 = tail(_timer_T, 1) @[Decoder.scala 102:22]
        timer <= _timer_T_1 @[Decoder.scala 102:13]
    node _io_timeout_T = eq(timer, timeout) @[Decoder.scala 105:23]
    io.timeout <= _io_timeout_T @[Decoder.scala 105:14]
    reg tracepoint : UInt<32>, clock with :
      reset => (reset, UInt<32>("hffffffff")) @[Decoder.scala 108:31]
    reg programCounter : UInt<32>, clock with :
      reset => (reset, UInt<32>("h0")) @[Decoder.scala 109:31]
    node _T_1 = and(instruction.io.deq.ready, instruction.io.deq.valid) @[Decoder.scala 110:26]
    when _T_1 : @[Decoder.scala 110:48]
      node _programCounter_T = add(programCounter, UInt<1>("h1")) @[Decoder.scala 111:38]
      node _programCounter_T_1 = tail(_programCounter_T, 1) @[Decoder.scala 111:38]
      programCounter <= _programCounter_T_1 @[Decoder.scala 111:20]
    node _io_tracepoint_T = eq(programCounter, tracepoint) @[Decoder.scala 113:35]
    io.tracepoint <= _io_tracepoint_T @[Decoder.scala 113:17]
    io.programCounter <= programCounter @[Decoder.scala 114:21]
    reg sampleInterval : UInt<16>, clock with :
      reset => (reset, UInt<16>("h0")) @[Decoder.scala 117:31]
    io.nooped.bits <= UInt<1>("h1") @[Decoder.scala 119:18]
    io.nooped.valid <= UInt<1>("h0") @[Decoder.scala 120:19]
    io.skipped.bits <= UInt<1>("h1") @[Decoder.scala 121:19]
    io.skipped.valid <= UInt<1>("h0") @[Decoder.scala 122:20]
    reg dram0AddressOffset : UInt<32>, clock with :
      reset => (reset, UInt<32>("h0")) @[Decoder.scala 126:35]
    reg dram0CacheBehaviour : UInt<4>, clock with :
      reset => (reset, UInt<4>("h0")) @[Decoder.scala 129:36]
    reg dram1AddressOffset : UInt<32>, clock with :
      reset => (reset, UInt<32>("h0")) @[Decoder.scala 130:35]
    reg dram1CacheBehaviour : UInt<4>, clock with :
      reset => (reset, UInt<4>("h0")) @[Decoder.scala 133:36]
    io.config.dram0AddressOffset <= dram0AddressOffset @[Decoder.scala 135:32]
    io.config.dram0CacheBehaviour <= dram0CacheBehaviour @[Decoder.scala 136:33]
    io.config.dram1AddressOffset <= dram1AddressOffset @[Decoder.scala 137:32]
    io.config.dram1CacheBehaviour <= dram1CacheBehaviour @[Decoder.scala 138:33]
    inst dram0Handler of StrideHandler @[Decoder.scala 144:28]
    dram0Handler.clock <= clock
    dram0Handler.reset <= reset
    inst dram1Handler of StrideHandler_1 @[Decoder.scala 153:28]
    dram1Handler.clock <= clock
    dram1Handler.reset <= reset
    io.dram0.bits <= dram0Handler.io.out.bits @[Decoder.scala 162:12]
    io.dram0.valid <= dram0Handler.io.out.valid @[Decoder.scala 162:12]
    dram0Handler.io.out.ready <= io.dram0.ready @[Decoder.scala 162:12]
    io.dram1.bits <= dram1Handler.io.out.bits @[Decoder.scala 163:12]
    io.dram1.valid <= dram1Handler.io.out.valid @[Decoder.scala 163:12]
    dram1Handler.io.out.ready <= io.dram1.ready @[Decoder.scala 163:12]
    inst dram0 of Queue_2 @[Mem.scala 22:19]
    dram0.clock <= clock
    dram0.reset <= reset
    dram0Handler.io.in <= dram0.io.deq @[Mem.scala 23:7]
    inst dram1 of Queue_3 @[Mem.scala 22:19]
    dram1.clock <= clock
    dram1.reset <= reset
    dram1Handler.io.in <= dram1.io.deq @[Mem.scala 23:7]
    inst memPortAHandler of SizeAndStrideHandler_2 @[Decoder.scala 168:31]
    memPortAHandler.clock <= clock
    memPortAHandler.reset <= reset
    inst memPortBHandler of SizeAndStrideHandler_3 @[Decoder.scala 177:31]
    memPortBHandler.clock <= clock
    memPortBHandler.reset <= reset
    io.memPortA.bits <= memPortAHandler.io.out.bits @[Decoder.scala 186:15]
    io.memPortA.valid <= memPortAHandler.io.out.valid @[Decoder.scala 186:15]
    memPortAHandler.io.out.ready <= io.memPortA.ready @[Decoder.scala 186:15]
    io.memPortB.bits <= memPortBHandler.io.out.bits @[Decoder.scala 187:15]
    io.memPortB.valid <= memPortBHandler.io.out.valid @[Decoder.scala 187:15]
    memPortBHandler.io.out.ready <= io.memPortB.ready @[Decoder.scala 187:15]
    inst lockPool of LockPool @[Decoder.scala 193:24]
    lockPool.clock <= clock
    lockPool.reset <= reset
    memPortAHandler.io.in <= lockPool.io.actor[UInt<1>("h0")].out @[Decoder.scala 196:25]
    memPortBHandler.io.in <= lockPool.io.actor[UInt<1>("h1")].out @[Decoder.scala 197:25]
    lockPool.io.deadlocked.ready <= UInt<1>("h0") @[Decoupled.scala 88:20]
    lockPool.io.locked.ready <= UInt<1>("h0") @[Decoupled.scala 88:20]
    inst accHandler of SizeAndStrideHandler_4 @[Decoder.scala 207:26]
    accHandler.clock <= clock
    accHandler.reset <= reset
    wire io_acc_bits_w : { instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, readAddress : UInt<11>, writeAddress : UInt<11>, accumulate : UInt<1>, write : UInt<1>, read : UInt<1>} @[AccumulatorWithALUArrayControl.scala 96:17]
    node io_acc_bits_isMemControl = eq(accHandler.io.out.bits.instruction.op, UInt<1>("h0")) @[AccumulatorWithALUArrayControl.scala 101:39]
    io_acc_bits_w.instruction <= accHandler.io.out.bits.instruction @[AccumulatorWithALUArrayControl.scala 102:19]
    io_acc_bits_w.read <= accHandler.io.out.bits.read @[AccumulatorWithALUArrayControl.scala 103:12]
    io_acc_bits_w.write <= accHandler.io.out.bits.write @[AccumulatorWithALUArrayControl.scala 104:13]
    io_acc_bits_w.accumulate <= accHandler.io.out.bits.accumulate @[AccumulatorWithALUArrayControl.scala 105:18]
    when io_acc_bits_isMemControl : @[AccumulatorWithALUArrayControl.scala 106:24]
      when accHandler.io.out.bits.read : @[AccumulatorWithALUArrayControl.scala 107:18]
        io_acc_bits_w.readAddress <= accHandler.io.out.bits.address @[AccumulatorWithALUArrayControl.scala 108:23]
        io_acc_bits_w.writeAddress <= accHandler.io.out.bits.altAddress @[AccumulatorWithALUArrayControl.scala 109:24]
      else :
        when accHandler.io.out.bits.write : @[AccumulatorWithALUArrayControl.scala 111:21]
          io_acc_bits_w.readAddress <= accHandler.io.out.bits.altAddress @[AccumulatorWithALUArrayControl.scala 112:25]
          io_acc_bits_w.writeAddress <= accHandler.io.out.bits.address @[AccumulatorWithALUArrayControl.scala 113:26]
        else :
          io_acc_bits_w.readAddress <= accHandler.io.out.bits.address @[AccumulatorWithALUArrayControl.scala 115:25]
          io_acc_bits_w.writeAddress <= accHandler.io.out.bits.altAddress @[AccumulatorWithALUArrayControl.scala 116:26]
    else :
      io_acc_bits_w.readAddress <= accHandler.io.out.bits.address @[AccumulatorWithALUArrayControl.scala 120:21]
      io_acc_bits_w.writeAddress <= accHandler.io.out.bits.altAddress @[AccumulatorWithALUArrayControl.scala 121:22]
    io.acc.bits <= io_acc_bits_w @[Decoder.scala 217:15]
    io.acc.valid <= accHandler.io.out.valid @[Decoder.scala 218:16]
    accHandler.io.out.ready <= io.acc.ready @[Decoder.scala 219:27]
    inst acc of Queue_4 @[Mem.scala 22:19]
    acc.clock <= clock
    acc.reset <= reset
    accHandler.io.in <= acc.io.deq @[Mem.scala 23:7]
    inst arrayHandler of SizeHandler @[Decoder.scala 230:28]
    arrayHandler.clock <= clock
    arrayHandler.reset <= reset
    io.array.bits <= arrayHandler.io.out.bits @[Decoder.scala 239:12]
    io.array.valid <= arrayHandler.io.out.valid @[Decoder.scala 239:12]
    arrayHandler.io.out.ready <= io.array.ready @[Decoder.scala 239:12]
    inst array of Queue_5 @[Mem.scala 22:19]
    array.clock <= clock
    array.reset <= reset
    arrayHandler.io.in <= array.io.deq @[Mem.scala 23:7]
    inst dataflow of Queue_6 @[Mem.scala 22:19]
    dataflow.clock <= clock
    dataflow.reset <= reset
    io.dataflow.bits <= dataflow.io.deq.bits @[Mem.scala 23:7]
    io.dataflow.valid <= dataflow.io.deq.valid @[Mem.scala 23:7]
    dataflow.io.deq.ready <= io.dataflow.ready @[Mem.scala 23:7]
    inst hostDataflowHandler of SizeHandler_1 @[Decoder.scala 250:35]
    hostDataflowHandler.clock <= clock
    hostDataflowHandler.reset <= reset
    io.hostDataflow.bits <= hostDataflowHandler.io.out.bits @[Decoder.scala 257:19]
    io.hostDataflow.valid <= hostDataflowHandler.io.out.valid @[Decoder.scala 257:19]
    hostDataflowHandler.io.out.ready <= io.hostDataflow.ready @[Decoder.scala 257:19]
    inst hostDataflow of Queue_7 @[Mem.scala 22:19]
    hostDataflow.clock <= clock
    hostDataflow.reset <= reset
    hostDataflowHandler.io.in <= hostDataflow.io.deq @[Mem.scala 23:7]
    wire _lockPool_io_actor_0_in_bits_WIRE : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>} @[package.scala 75:57]
    _lockPool_io_actor_0_in_bits_WIRE.reverse <= UInt<1>("h0") @[package.scala 75:57]
    _lockPool_io_actor_0_in_bits_WIRE.stride <= UInt<3>("h0") @[package.scala 75:57]
    _lockPool_io_actor_0_in_bits_WIRE.size <= UInt<13>("h0") @[package.scala 75:57]
    _lockPool_io_actor_0_in_bits_WIRE.address <= UInt<13>("h0") @[package.scala 75:57]
    _lockPool_io_actor_0_in_bits_WIRE.write <= UInt<1>("h0") @[package.scala 75:57]
    lockPool.io.actor[0].in.bits.reverse <= _lockPool_io_actor_0_in_bits_WIRE.reverse @[Decoder.scala 669:15]
    lockPool.io.actor[0].in.bits.stride <= _lockPool_io_actor_0_in_bits_WIRE.stride @[Decoder.scala 669:15]
    lockPool.io.actor[0].in.bits.size <= _lockPool_io_actor_0_in_bits_WIRE.size @[Decoder.scala 669:15]
    lockPool.io.actor[0].in.bits.address <= _lockPool_io_actor_0_in_bits_WIRE.address @[Decoder.scala 669:15]
    lockPool.io.actor[0].in.bits.write <= _lockPool_io_actor_0_in_bits_WIRE.write @[Decoder.scala 669:15]
    lockPool.io.actor[0].in.valid <= UInt<1>("h0") @[Decoder.scala 670:16]
    wire _lockPool_io_actor_1_in_bits_WIRE : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>} @[package.scala 75:57]
    _lockPool_io_actor_1_in_bits_WIRE.reverse <= UInt<1>("h0") @[package.scala 75:57]
    _lockPool_io_actor_1_in_bits_WIRE.stride <= UInt<3>("h0") @[package.scala 75:57]
    _lockPool_io_actor_1_in_bits_WIRE.size <= UInt<13>("h0") @[package.scala 75:57]
    _lockPool_io_actor_1_in_bits_WIRE.address <= UInt<13>("h0") @[package.scala 75:57]
    _lockPool_io_actor_1_in_bits_WIRE.write <= UInt<1>("h0") @[package.scala 75:57]
    lockPool.io.actor[1].in.bits.reverse <= _lockPool_io_actor_1_in_bits_WIRE.reverse @[Decoder.scala 669:15]
    lockPool.io.actor[1].in.bits.stride <= _lockPool_io_actor_1_in_bits_WIRE.stride @[Decoder.scala 669:15]
    lockPool.io.actor[1].in.bits.size <= _lockPool_io_actor_1_in_bits_WIRE.size @[Decoder.scala 669:15]
    lockPool.io.actor[1].in.bits.address <= _lockPool_io_actor_1_in_bits_WIRE.address @[Decoder.scala 669:15]
    lockPool.io.actor[1].in.bits.write <= _lockPool_io_actor_1_in_bits_WIRE.write @[Decoder.scala 669:15]
    lockPool.io.actor[1].in.valid <= UInt<1>("h0") @[Decoder.scala 670:16]
    wire _dataflow_io_enq_bits_WIRE : { kind : UInt<4>, size : UInt<13>} @[package.scala 75:57]
    _dataflow_io_enq_bits_WIRE.size <= UInt<13>("h0") @[package.scala 75:57]
    _dataflow_io_enq_bits_WIRE.kind <= UInt<4>("h0") @[package.scala 75:57]
    dataflow.io.enq.bits.size <= _dataflow_io_enq_bits_WIRE.size @[Decoder.scala 669:15]
    dataflow.io.enq.bits.kind <= _dataflow_io_enq_bits_WIRE.kind @[Decoder.scala 669:15]
    dataflow.io.enq.valid <= UInt<1>("h0") @[Decoder.scala 670:16]
    wire _hostDataflow_io_enq_bits_WIRE : { kind : UInt<2>, size : UInt<13>} @[package.scala 75:57]
    _hostDataflow_io_enq_bits_WIRE.size <= UInt<13>("h0") @[package.scala 75:57]
    _hostDataflow_io_enq_bits_WIRE.kind <= UInt<2>("h0") @[package.scala 75:57]
    hostDataflow.io.enq.bits.size <= _hostDataflow_io_enq_bits_WIRE.size @[Decoder.scala 669:15]
    hostDataflow.io.enq.bits.kind <= _hostDataflow_io_enq_bits_WIRE.kind @[Decoder.scala 669:15]
    hostDataflow.io.enq.valid <= UInt<1>("h0") @[Decoder.scala 670:16]
    wire _acc_io_enq_bits_WIRE : { instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<11>, altAddress : UInt<11>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<11>, stride : UInt<3>, reverse : UInt<1>} @[package.scala 75:57]
    _acc_io_enq_bits_WIRE.reverse <= UInt<1>("h0") @[package.scala 75:57]
    _acc_io_enq_bits_WIRE.stride <= UInt<3>("h0") @[package.scala 75:57]
    _acc_io_enq_bits_WIRE.size <= UInt<11>("h0") @[package.scala 75:57]
    _acc_io_enq_bits_WIRE.accumulate <= UInt<1>("h0") @[package.scala 75:57]
    _acc_io_enq_bits_WIRE.write <= UInt<1>("h0") @[package.scala 75:57]
    _acc_io_enq_bits_WIRE.read <= UInt<1>("h0") @[package.scala 75:57]
    _acc_io_enq_bits_WIRE.altAddress <= UInt<11>("h0") @[package.scala 75:57]
    _acc_io_enq_bits_WIRE.address <= UInt<11>("h0") @[package.scala 75:57]
    _acc_io_enq_bits_WIRE.instruction.dest <= UInt<1>("h0") @[package.scala 75:57]
    _acc_io_enq_bits_WIRE.instruction.sourceRight <= UInt<1>("h0") @[package.scala 75:57]
    _acc_io_enq_bits_WIRE.instruction.sourceLeft <= UInt<1>("h0") @[package.scala 75:57]
    _acc_io_enq_bits_WIRE.instruction.op <= UInt<4>("h0") @[package.scala 75:57]
    acc.io.enq.bits.reverse <= _acc_io_enq_bits_WIRE.reverse @[Decoder.scala 669:15]
    acc.io.enq.bits.stride <= _acc_io_enq_bits_WIRE.stride @[Decoder.scala 669:15]
    acc.io.enq.bits.size <= _acc_io_enq_bits_WIRE.size @[Decoder.scala 669:15]
    acc.io.enq.bits.accumulate <= _acc_io_enq_bits_WIRE.accumulate @[Decoder.scala 669:15]
    acc.io.enq.bits.write <= _acc_io_enq_bits_WIRE.write @[Decoder.scala 669:15]
    acc.io.enq.bits.read <= _acc_io_enq_bits_WIRE.read @[Decoder.scala 669:15]
    acc.io.enq.bits.altAddress <= _acc_io_enq_bits_WIRE.altAddress @[Decoder.scala 669:15]
    acc.io.enq.bits.address <= _acc_io_enq_bits_WIRE.address @[Decoder.scala 669:15]
    acc.io.enq.bits.instruction.dest <= _acc_io_enq_bits_WIRE.instruction.dest @[Decoder.scala 669:15]
    acc.io.enq.bits.instruction.sourceRight <= _acc_io_enq_bits_WIRE.instruction.sourceRight @[Decoder.scala 669:15]
    acc.io.enq.bits.instruction.sourceLeft <= _acc_io_enq_bits_WIRE.instruction.sourceLeft @[Decoder.scala 669:15]
    acc.io.enq.bits.instruction.op <= _acc_io_enq_bits_WIRE.instruction.op @[Decoder.scala 669:15]
    acc.io.enq.valid <= UInt<1>("h0") @[Decoder.scala 670:16]
    wire _array_io_enq_bits_WIRE : { load : UInt<1>, zeroes : UInt<1>, size : UInt<13>} @[package.scala 75:57]
    _array_io_enq_bits_WIRE.size <= UInt<13>("h0") @[package.scala 75:57]
    _array_io_enq_bits_WIRE.zeroes <= UInt<1>("h0") @[package.scala 75:57]
    _array_io_enq_bits_WIRE.load <= UInt<1>("h0") @[package.scala 75:57]
    array.io.enq.bits.size <= _array_io_enq_bits_WIRE.size @[Decoder.scala 669:15]
    array.io.enq.bits.zeroes <= _array_io_enq_bits_WIRE.zeroes @[Decoder.scala 669:15]
    array.io.enq.bits.load <= _array_io_enq_bits_WIRE.load @[Decoder.scala 669:15]
    array.io.enq.valid <= UInt<1>("h0") @[Decoder.scala 670:16]
    wire _dram0_io_enq_bits_WIRE : { write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>} @[package.scala 75:57]
    _dram0_io_enq_bits_WIRE.reverse <= UInt<1>("h0") @[package.scala 75:57]
    _dram0_io_enq_bits_WIRE.stride <= UInt<3>("h0") @[package.scala 75:57]
    _dram0_io_enq_bits_WIRE.size <= UInt<20>("h0") @[package.scala 75:57]
    _dram0_io_enq_bits_WIRE.address <= UInt<20>("h0") @[package.scala 75:57]
    _dram0_io_enq_bits_WIRE.write <= UInt<1>("h0") @[package.scala 75:57]
    dram0.io.enq.bits.reverse <= _dram0_io_enq_bits_WIRE.reverse @[Decoder.scala 669:15]
    dram0.io.enq.bits.stride <= _dram0_io_enq_bits_WIRE.stride @[Decoder.scala 669:15]
    dram0.io.enq.bits.size <= _dram0_io_enq_bits_WIRE.size @[Decoder.scala 669:15]
    dram0.io.enq.bits.address <= _dram0_io_enq_bits_WIRE.address @[Decoder.scala 669:15]
    dram0.io.enq.bits.write <= _dram0_io_enq_bits_WIRE.write @[Decoder.scala 669:15]
    dram0.io.enq.valid <= UInt<1>("h0") @[Decoder.scala 670:16]
    wire _dram1_io_enq_bits_WIRE : { write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>} @[package.scala 75:57]
    _dram1_io_enq_bits_WIRE.reverse <= UInt<1>("h0") @[package.scala 75:57]
    _dram1_io_enq_bits_WIRE.stride <= UInt<3>("h0") @[package.scala 75:57]
    _dram1_io_enq_bits_WIRE.size <= UInt<20>("h0") @[package.scala 75:57]
    _dram1_io_enq_bits_WIRE.address <= UInt<20>("h0") @[package.scala 75:57]
    _dram1_io_enq_bits_WIRE.write <= UInt<1>("h0") @[package.scala 75:57]
    dram1.io.enq.bits.reverse <= _dram1_io_enq_bits_WIRE.reverse @[Decoder.scala 669:15]
    dram1.io.enq.bits.stride <= _dram1_io_enq_bits_WIRE.stride @[Decoder.scala 669:15]
    dram1.io.enq.bits.size <= _dram1_io_enq_bits_WIRE.size @[Decoder.scala 669:15]
    dram1.io.enq.bits.address <= _dram1_io_enq_bits_WIRE.address @[Decoder.scala 669:15]
    dram1.io.enq.bits.write <= _dram1_io_enq_bits_WIRE.write @[Decoder.scala 669:15]
    dram1.io.enq.valid <= UInt<1>("h0") @[Decoder.scala 670:16]
    lockPool.io.lock.valid <= UInt<1>("h0") @[Decoupled.scala 72:20]
    lockPool.io.lock.bits.delayRelease is invalid @[Decoupled.scala 73:19]
    lockPool.io.lock.bits.by is invalid @[Decoupled.scala 73:19]
    lockPool.io.lock.bits.acquire is invalid @[Decoupled.scala 73:19]
    lockPool.io.lock.bits.lock is invalid @[Decoupled.scala 73:19]
    lockPool.io.lock.bits.cond.reverse is invalid @[Decoupled.scala 73:19]
    lockPool.io.lock.bits.cond.stride is invalid @[Decoupled.scala 73:19]
    lockPool.io.lock.bits.cond.size is invalid @[Decoupled.scala 73:19]
    lockPool.io.lock.bits.cond.address is invalid @[Decoupled.scala 73:19]
    lockPool.io.lock.bits.cond.write is invalid @[Decoupled.scala 73:19]
    inst enqueuer1 of MultiEnqueue @[MultiEnqueue.scala 182:43]
    enqueuer1.clock <= clock
    enqueuer1.reset <= reset
    inst enqueuer2 of MultiEnqueue_1 @[MultiEnqueue.scala 182:43]
    enqueuer2.clock <= clock
    enqueuer2.reset <= reset
    inst enqueuer3 of MultiEnqueue_2 @[MultiEnqueue.scala 182:43]
    enqueuer3.clock <= clock
    enqueuer3.reset <= reset
    inst enqueuer4 of MultiEnqueue_3 @[MultiEnqueue.scala 182:43]
    enqueuer4.clock <= clock
    enqueuer4.reset <= reset
    inst enqueuer5 of MultiEnqueue_4 @[MultiEnqueue.scala 182:43]
    enqueuer5.clock <= clock
    enqueuer5.reset <= reset
    enqueuer1.io.in.valid <= UInt<1>("h0") @[MultiEnqueue.scala 40:17]
    enqueuer1.io.out[0].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    enqueuer2.io.in.valid <= UInt<1>("h0") @[MultiEnqueue.scala 40:17]
    enqueuer2.io.out[0].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    enqueuer2.io.out[1].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    enqueuer3.io.in.valid <= UInt<1>("h0") @[MultiEnqueue.scala 40:17]
    enqueuer3.io.out[0].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    enqueuer3.io.out[1].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    enqueuer3.io.out[2].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    enqueuer4.io.in.valid <= UInt<1>("h0") @[MultiEnqueue.scala 40:17]
    enqueuer4.io.out[0].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    enqueuer4.io.out[1].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    enqueuer4.io.out[2].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    enqueuer4.io.out[3].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    enqueuer5.io.in.valid <= UInt<1>("h0") @[MultiEnqueue.scala 40:17]
    enqueuer5.io.out[0].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    enqueuer5.io.out[1].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    enqueuer5.io.out[2].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    enqueuer5.io.out[3].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    enqueuer5.io.out[4].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    node _T_2 = eq(instruction.io.deq.bits.opcode, UInt<1>("h1")) @[Decoder.scala 282:32]
    when _T_2 : @[Decoder.scala 282:51]
      wire flags : { _unused : UInt<2>, zeroes : UInt<1>, accumulate : UInt<1>} @[Decoder.scala 283:21]
      wire args : { size : UInt<16>, _unused1 : UInt<1>, accStride : UInt<3>, accAddress : UInt<20>, _unused0 : UInt<0>, memStride : UInt<3>, memAddress : UInt<13>} @[Decoder.scala 284:20]
      wire _flags_WIRE : { _unused : UInt<2>, zeroes : UInt<1>, accumulate : UInt<1>} @[Decoder.scala 288:45]
      wire _flags_WIRE_1 : UInt<4>
      _flags_WIRE_1 <= instruction.io.deq.bits.flags
      node _flags_T = bits(_flags_WIRE_1, 0, 0) @[Decoder.scala 288:45]
      _flags_WIRE.accumulate <= _flags_T @[Decoder.scala 288:45]
      node _flags_T_1 = bits(_flags_WIRE_1, 1, 1) @[Decoder.scala 288:45]
      _flags_WIRE.zeroes <= _flags_T_1 @[Decoder.scala 288:45]
      node _flags_T_2 = bits(_flags_WIRE_1, 3, 2) @[Decoder.scala 288:45]
      _flags_WIRE._unused <= _flags_T_2 @[Decoder.scala 288:45]
      flags <= _flags_WIRE @[Decoder.scala 288:11]
      wire _args_WIRE : { size : UInt<16>, _unused1 : UInt<1>, accStride : UInt<3>, accAddress : UInt<20>, _unused0 : UInt<0>, memStride : UInt<3>, memAddress : UInt<13>} @[Decoder.scala 289:48]
      wire _args_WIRE_1 : UInt<56>
      _args_WIRE_1 <= instruction.io.deq.bits.arguments
      node _args_T = bits(_args_WIRE_1, 12, 0) @[Decoder.scala 289:48]
      _args_WIRE.memAddress <= _args_T @[Decoder.scala 289:48]
      node _args_T_1 = bits(_args_WIRE_1, 15, 13) @[Decoder.scala 289:48]
      _args_WIRE.memStride <= _args_T_1 @[Decoder.scala 289:48]
      _args_WIRE._unused0 is invalid @[Decoder.scala 289:48]
      node _args_T_2 = bits(_args_WIRE_1, 35, 16) @[Decoder.scala 289:48]
      _args_WIRE.accAddress <= _args_T_2 @[Decoder.scala 289:48]
      node _args_T_3 = bits(_args_WIRE_1, 38, 36) @[Decoder.scala 289:48]
      _args_WIRE.accStride <= _args_T_3 @[Decoder.scala 289:48]
      node _args_T_4 = bits(_args_WIRE_1, 39, 39) @[Decoder.scala 289:48]
      _args_WIRE._unused1 <= _args_T_4 @[Decoder.scala 289:48]
      node _args_T_5 = bits(_args_WIRE_1, 55, 40) @[Decoder.scala 289:48]
      _args_WIRE.size <= _args_T_5 @[Decoder.scala 289:48]
      args <= _args_WIRE @[Decoder.scala 289:10]
      when flags.zeroes : @[Decoder.scala 291:24]
        wire instruction_io_deq_ready_w : { kind : UInt<4>, size : UInt<13>} @[Decoder.scala 733:17]
        instruction_io_deq_ready_w.kind <= UInt<2>("h3") @[Decoder.scala 734:12]
        instruction_io_deq_ready_w.size <= args.size @[Decoder.scala 735:12]
        wire instruction_io_deq_ready_w_1 : { load : UInt<1>, zeroes : UInt<1>, size : UInt<13>} @[Decoder.scala 744:17]
        instruction_io_deq_ready_w_1.load <= UInt<1>("h0") @[Decoder.scala 745:12]
        instruction_io_deq_ready_w_1.zeroes <= flags.zeroes @[Decoder.scala 746:14]
        instruction_io_deq_ready_w_1.size <= args.size @[Decoder.scala 747:12]
        wire instruction_io_deq_ready_w_2 : { instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<11>, altAddress : UInt<11>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<11>, stride : UInt<3>, reverse : UInt<1>} @[Decoder.scala 716:17]
        instruction_io_deq_ready_w_2.instruction.dest <= UInt<1>("h0") @[Decoder.scala 717:19]
        instruction_io_deq_ready_w_2.instruction.sourceRight <= UInt<1>("h0") @[Decoder.scala 717:19]
        instruction_io_deq_ready_w_2.instruction.sourceLeft <= UInt<1>("h0") @[Decoder.scala 717:19]
        instruction_io_deq_ready_w_2.instruction.op <= UInt<1>("h0") @[Decoder.scala 717:19]
        instruction_io_deq_ready_w_2.address <= args.accAddress @[Decoder.scala 718:15]
        instruction_io_deq_ready_w_2.altAddress <= UInt<1>("h0") @[Decoder.scala 719:18]
        instruction_io_deq_ready_w_2.accumulate <= flags.accumulate @[Decoder.scala 720:18]
        instruction_io_deq_ready_w_2.write <= UInt<1>("h1") @[Decoder.scala 721:13]
        instruction_io_deq_ready_w_2.read <= UInt<1>("h0") @[Decoder.scala 722:12]
        instruction_io_deq_ready_w_2.size <= args.size @[Decoder.scala 723:12]
        instruction_io_deq_ready_w_2.stride <= args.accStride @[Decoder.scala 724:14]
        instruction_io_deq_ready_w_2.reverse <= UInt<1>("h0") @[Decoder.scala 725:15]
        enqueuer3.io.in.valid <= instruction.io.deq.valid @[MultiEnqueue.scala 114:17]
        wire instruction_io_deq_ready_dataflow_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { kind : UInt<4>, size : UInt<13>}} @[ReadyValid.scala 16:17]
        instruction_io_deq_ready_dataflow_io_enq_w.bits <= instruction_io_deq_ready_w @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_dataflow_io_enq_w.valid <= enqueuer3.io.out[0].valid @[ReadyValid.scala 18:13]
        enqueuer3.io.out[0].ready <= instruction_io_deq_ready_dataflow_io_enq_w.ready @[ReadyValid.scala 19:11]
        dataflow.io.enq <= instruction_io_deq_ready_dataflow_io_enq_w @[MultiEnqueue.scala 115:10]
        wire instruction_io_deq_ready_array_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { load : UInt<1>, zeroes : UInt<1>, size : UInt<13>}} @[ReadyValid.scala 16:17]
        instruction_io_deq_ready_array_io_enq_w.bits <= instruction_io_deq_ready_w_1 @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_array_io_enq_w.valid <= enqueuer3.io.out[1].valid @[ReadyValid.scala 18:13]
        enqueuer3.io.out[1].ready <= instruction_io_deq_ready_array_io_enq_w.ready @[ReadyValid.scala 19:11]
        array.io.enq <= instruction_io_deq_ready_array_io_enq_w @[MultiEnqueue.scala 116:10]
        wire instruction_io_deq_ready_acc_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<11>, altAddress : UInt<11>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<11>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
        instruction_io_deq_ready_acc_io_enq_w.bits <= instruction_io_deq_ready_w_2 @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_acc_io_enq_w.valid <= enqueuer3.io.out[2].valid @[ReadyValid.scala 18:13]
        enqueuer3.io.out[2].ready <= instruction_io_deq_ready_acc_io_enq_w.ready @[ReadyValid.scala 19:11]
        acc.io.enq <= instruction_io_deq_ready_acc_io_enq_w @[MultiEnqueue.scala 117:10]
        instruction.io.deq.ready <= enqueuer3.io.in.ready @[Decoder.scala 292:25]
      else :
        wire req : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 44:19]
        req.address <= args.memAddress @[MemControl.scala 45:17]
        req.size <= args.size @[MemControl.scala 46:14]
        req.stride <= args.memStride @[MemControl.scala 47:16]
        req.write <= UInt<1>("h0") @[MemControl.scala 48:15]
        req.reverse <= UInt<1>("h0") @[MemControl.scala 49:17]
        wire instruction_io_deq_ready_w_3 : { kind : UInt<4>, size : UInt<13>} @[Decoder.scala 733:17]
        instruction_io_deq_ready_w_3.kind <= UInt<2>("h2") @[Decoder.scala 734:12]
        instruction_io_deq_ready_w_3.size <= args.size @[Decoder.scala 735:12]
        wire instruction_io_deq_ready_w_4 : { load : UInt<1>, zeroes : UInt<1>, size : UInt<13>} @[Decoder.scala 744:17]
        instruction_io_deq_ready_w_4.load <= UInt<1>("h0") @[Decoder.scala 745:12]
        instruction_io_deq_ready_w_4.zeroes <= flags.zeroes @[Decoder.scala 746:14]
        instruction_io_deq_ready_w_4.size <= args.size @[Decoder.scala 747:12]
        wire instruction_io_deq_ready_w_5 : { instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<11>, altAddress : UInt<11>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<11>, stride : UInt<3>, reverse : UInt<1>} @[Decoder.scala 716:17]
        instruction_io_deq_ready_w_5.instruction.dest <= UInt<1>("h0") @[Decoder.scala 717:19]
        instruction_io_deq_ready_w_5.instruction.sourceRight <= UInt<1>("h0") @[Decoder.scala 717:19]
        instruction_io_deq_ready_w_5.instruction.sourceLeft <= UInt<1>("h0") @[Decoder.scala 717:19]
        instruction_io_deq_ready_w_5.instruction.op <= UInt<1>("h0") @[Decoder.scala 717:19]
        instruction_io_deq_ready_w_5.address <= args.accAddress @[Decoder.scala 718:15]
        instruction_io_deq_ready_w_5.altAddress <= UInt<1>("h0") @[Decoder.scala 719:18]
        instruction_io_deq_ready_w_5.accumulate <= flags.accumulate @[Decoder.scala 720:18]
        instruction_io_deq_ready_w_5.write <= UInt<1>("h1") @[Decoder.scala 721:13]
        instruction_io_deq_ready_w_5.read <= UInt<1>("h0") @[Decoder.scala 722:12]
        instruction_io_deq_ready_w_5.size <= args.size @[Decoder.scala 723:12]
        instruction_io_deq_ready_w_5.stride <= args.accStride @[Decoder.scala 724:14]
        instruction_io_deq_ready_w_5.reverse <= UInt<1>("h0") @[Decoder.scala 725:15]
        wire instruction_io_deq_ready_w_6 : { cond : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}, lock : UInt<1>, acquire : UInt<1>, by : UInt<1>, delayRelease : UInt<4>} @[Decoder.scala 755:17]
        node _instruction_io_deq_ready_w_lock_T = div(req.address, UInt<13>("h1000")) @[Decoder.scala 191:15]
        instruction_io_deq_ready_w_6.lock <= _instruction_io_deq_ready_w_lock_T @[Decoder.scala 758:12]
        instruction_io_deq_ready_w_6.acquire <= UInt<1>("h1") @[Decoder.scala 759:15]
        instruction_io_deq_ready_w_6.by <= UInt<1>("h0") @[Decoder.scala 760:10]
        instruction_io_deq_ready_w_6.delayRelease <= UInt<1>("h0") @[Decoder.scala 761:20]
        instruction_io_deq_ready_w_6.cond <= req @[Decoder.scala 762:12]
        enqueuer5.io.in.valid <= instruction.io.deq.valid @[MultiEnqueue.scala 171:17]
        wire instruction_io_deq_ready_dataflow_io_enq_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : { kind : UInt<4>, size : UInt<13>}} @[ReadyValid.scala 16:17]
        instruction_io_deq_ready_dataflow_io_enq_w_1.bits <= instruction_io_deq_ready_w_3 @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_dataflow_io_enq_w_1.valid <= enqueuer5.io.out[0].valid @[ReadyValid.scala 18:13]
        enqueuer5.io.out[0].ready <= instruction_io_deq_ready_dataflow_io_enq_w_1.ready @[ReadyValid.scala 19:11]
        dataflow.io.enq <= instruction_io_deq_ready_dataflow_io_enq_w_1 @[MultiEnqueue.scala 172:10]
        wire instruction_io_deq_ready_lockPool_io_actor_0_in_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
        instruction_io_deq_ready_lockPool_io_actor_0_in_w.bits <= req @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_lockPool_io_actor_0_in_w.valid <= enqueuer5.io.out[1].valid @[ReadyValid.scala 18:13]
        enqueuer5.io.out[1].ready <= instruction_io_deq_ready_lockPool_io_actor_0_in_w.ready @[ReadyValid.scala 19:11]
        lockPool.io.actor[0].in <= instruction_io_deq_ready_lockPool_io_actor_0_in_w @[MultiEnqueue.scala 173:10]
        wire instruction_io_deq_ready_array_io_enq_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : { load : UInt<1>, zeroes : UInt<1>, size : UInt<13>}} @[ReadyValid.scala 16:17]
        instruction_io_deq_ready_array_io_enq_w_1.bits <= instruction_io_deq_ready_w_4 @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_array_io_enq_w_1.valid <= enqueuer5.io.out[2].valid @[ReadyValid.scala 18:13]
        enqueuer5.io.out[2].ready <= instruction_io_deq_ready_array_io_enq_w_1.ready @[ReadyValid.scala 19:11]
        array.io.enq <= instruction_io_deq_ready_array_io_enq_w_1 @[MultiEnqueue.scala 174:10]
        wire instruction_io_deq_ready_acc_io_enq_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : { instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<11>, altAddress : UInt<11>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<11>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
        instruction_io_deq_ready_acc_io_enq_w_1.bits <= instruction_io_deq_ready_w_5 @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_acc_io_enq_w_1.valid <= enqueuer5.io.out[3].valid @[ReadyValid.scala 18:13]
        enqueuer5.io.out[3].ready <= instruction_io_deq_ready_acc_io_enq_w_1.ready @[ReadyValid.scala 19:11]
        acc.io.enq <= instruction_io_deq_ready_acc_io_enq_w_1 @[MultiEnqueue.scala 175:10]
        wire instruction_io_deq_ready_lockPool_io_lock_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { cond : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}, lock : UInt<1>, acquire : UInt<1>, by : UInt<1>, delayRelease : UInt<4>}} @[ReadyValid.scala 16:17]
        instruction_io_deq_ready_lockPool_io_lock_w.bits <= instruction_io_deq_ready_w_6 @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_lockPool_io_lock_w.valid <= enqueuer5.io.out[4].valid @[ReadyValid.scala 18:13]
        enqueuer5.io.out[4].ready <= instruction_io_deq_ready_lockPool_io_lock_w.ready @[ReadyValid.scala 19:11]
        lockPool.io.lock <= instruction_io_deq_ready_lockPool_io_lock_w @[MultiEnqueue.scala 176:10]
        instruction.io.deq.ready <= enqueuer5.io.in.ready @[Decoder.scala 314:25]
    else :
      node _T_3 = eq(instruction.io.deq.bits.opcode, UInt<2>("h3")) @[Decoder.scala 333:38]
      when _T_3 : @[Decoder.scala 333:62]
        wire flags_1 : { _unused : UInt<3>, zeroes : UInt<1>} @[Decoder.scala 334:21]
        wire args_1 : { size : UInt<24>, _unused : UInt<0>, stride : UInt<3>, address : UInt<13>} @[Decoder.scala 336:11]
        wire _flags_WIRE_2 : { _unused : UInt<3>, zeroes : UInt<1>} @[Decoder.scala 340:45]
        wire _flags_WIRE_3 : UInt<4>
        _flags_WIRE_3 <= instruction.io.deq.bits.flags
        node _flags_T_3 = bits(_flags_WIRE_3, 0, 0) @[Decoder.scala 340:45]
        _flags_WIRE_2.zeroes <= _flags_T_3 @[Decoder.scala 340:45]
        node _flags_T_4 = bits(_flags_WIRE_3, 3, 1) @[Decoder.scala 340:45]
        _flags_WIRE_2._unused <= _flags_T_4 @[Decoder.scala 340:45]
        flags_1 <= _flags_WIRE_2 @[Decoder.scala 340:11]
        wire _args_WIRE_2 : { size : UInt<24>, _unused : UInt<0>, stride : UInt<3>, address : UInt<13>} @[Decoder.scala 341:48]
        wire _args_WIRE_3 : UInt<40>
        _args_WIRE_3 <= instruction.io.deq.bits.arguments
        node _args_T_6 = bits(_args_WIRE_3, 12, 0) @[Decoder.scala 341:48]
        _args_WIRE_2.address <= _args_T_6 @[Decoder.scala 341:48]
        node _args_T_7 = bits(_args_WIRE_3, 15, 13) @[Decoder.scala 341:48]
        _args_WIRE_2.stride <= _args_T_7 @[Decoder.scala 341:48]
        _args_WIRE_2._unused is invalid @[Decoder.scala 341:48]
        node _args_T_8 = bits(_args_WIRE_3, 39, 16) @[Decoder.scala 341:48]
        _args_WIRE_2.size <= _args_T_8 @[Decoder.scala 341:48]
        args_1 <= _args_WIRE_2 @[Decoder.scala 341:10]
        when flags_1.zeroes : @[Decoder.scala 343:24]
          wire instruction_io_deq_ready_w_7 : { load : UInt<1>, zeroes : UInt<1>, size : UInt<13>} @[Decoder.scala 744:17]
          instruction_io_deq_ready_w_7.load <= UInt<1>("h1") @[Decoder.scala 745:12]
          instruction_io_deq_ready_w_7.zeroes <= flags_1.zeroes @[Decoder.scala 746:14]
          instruction_io_deq_ready_w_7.size <= args_1.size @[Decoder.scala 747:12]
          enqueuer1.io.in.valid <= instruction.io.deq.valid @[MultiEnqueue.scala 60:17]
          wire instruction_io_deq_ready_array_io_enq_w_2 : { flip ready : UInt<1>, valid : UInt<1>, bits : { load : UInt<1>, zeroes : UInt<1>, size : UInt<13>}} @[ReadyValid.scala 16:17]
          instruction_io_deq_ready_array_io_enq_w_2.bits <= instruction_io_deq_ready_w_7 @[ReadyValid.scala 17:12]
          instruction_io_deq_ready_array_io_enq_w_2.valid <= enqueuer1.io.out[0].valid @[ReadyValid.scala 18:13]
          enqueuer1.io.out[0].ready <= instruction_io_deq_ready_array_io_enq_w_2.ready @[ReadyValid.scala 19:11]
          array.io.enq <= instruction_io_deq_ready_array_io_enq_w_2 @[MultiEnqueue.scala 61:10]
          instruction.io.deq.ready <= enqueuer1.io.in.ready @[Decoder.scala 344:25]
        else :
          node stride = dshl(UInt<1>("h1"), args_1.stride) @[Decoder.scala 350:24]
          node _req_T = mul(args_1.size, stride) @[Decoder.scala 352:35]
          node _req_T_1 = add(args_1.address, _req_T) @[Decoder.scala 352:22]
          node _req_T_2 = tail(_req_T_1, 1) @[Decoder.scala 352:22]
          wire req_1 : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 44:19]
          req_1.address <= _req_T_2 @[MemControl.scala 45:17]
          req_1.size <= args_1.size @[MemControl.scala 46:14]
          req_1.stride <= args_1.stride @[MemControl.scala 47:16]
          req_1.write <= UInt<1>("h0") @[MemControl.scala 48:15]
          req_1.reverse <= UInt<1>("h1") @[MemControl.scala 49:17]
          wire instruction_io_deq_ready_w_8 : { kind : UInt<4>, size : UInt<13>} @[LocalDataFlowControl.scala 28:19]
          instruction_io_deq_ready_w_8.kind <= UInt<1>("h1") @[LocalDataFlowControl.scala 29:14]
          instruction_io_deq_ready_w_8.size <= args_1.size @[LocalDataFlowControl.scala 30:14]
          wire instruction_io_deq_ready_w_9 : { load : UInt<1>, zeroes : UInt<1>, size : UInt<13>} @[Decoder.scala 744:17]
          instruction_io_deq_ready_w_9.load <= UInt<1>("h1") @[Decoder.scala 745:12]
          instruction_io_deq_ready_w_9.zeroes <= flags_1.zeroes @[Decoder.scala 746:14]
          instruction_io_deq_ready_w_9.size <= args_1.size @[Decoder.scala 747:12]
          wire instruction_io_deq_ready_w_10 : { cond : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}, lock : UInt<1>, acquire : UInt<1>, by : UInt<1>, delayRelease : UInt<4>} @[Decoder.scala 755:17]
          node _instruction_io_deq_ready_w_lock_T_1 = div(req_1.address, UInt<13>("h1000")) @[Decoder.scala 191:15]
          instruction_io_deq_ready_w_10.lock <= _instruction_io_deq_ready_w_lock_T_1 @[Decoder.scala 758:12]
          instruction_io_deq_ready_w_10.acquire <= UInt<1>("h1") @[Decoder.scala 759:15]
          instruction_io_deq_ready_w_10.by <= UInt<1>("h0") @[Decoder.scala 760:10]
          instruction_io_deq_ready_w_10.delayRelease <= UInt<1>("h0") @[Decoder.scala 761:20]
          instruction_io_deq_ready_w_10.cond <= req_1 @[Decoder.scala 762:12]
          enqueuer4.io.in.valid <= instruction.io.deq.valid @[MultiEnqueue.scala 150:17]
          wire instruction_io_deq_ready_dataflow_io_enq_w_2 : { flip ready : UInt<1>, valid : UInt<1>, bits : { kind : UInt<4>, size : UInt<13>}} @[ReadyValid.scala 16:17]
          instruction_io_deq_ready_dataflow_io_enq_w_2.bits <= instruction_io_deq_ready_w_8 @[ReadyValid.scala 17:12]
          instruction_io_deq_ready_dataflow_io_enq_w_2.valid <= enqueuer4.io.out[0].valid @[ReadyValid.scala 18:13]
          enqueuer4.io.out[0].ready <= instruction_io_deq_ready_dataflow_io_enq_w_2.ready @[ReadyValid.scala 19:11]
          dataflow.io.enq <= instruction_io_deq_ready_dataflow_io_enq_w_2 @[MultiEnqueue.scala 151:10]
          wire instruction_io_deq_ready_array_io_enq_w_3 : { flip ready : UInt<1>, valid : UInt<1>, bits : { load : UInt<1>, zeroes : UInt<1>, size : UInt<13>}} @[ReadyValid.scala 16:17]
          instruction_io_deq_ready_array_io_enq_w_3.bits <= instruction_io_deq_ready_w_9 @[ReadyValid.scala 17:12]
          instruction_io_deq_ready_array_io_enq_w_3.valid <= enqueuer4.io.out[1].valid @[ReadyValid.scala 18:13]
          enqueuer4.io.out[1].ready <= instruction_io_deq_ready_array_io_enq_w_3.ready @[ReadyValid.scala 19:11]
          array.io.enq <= instruction_io_deq_ready_array_io_enq_w_3 @[MultiEnqueue.scala 152:10]
          wire instruction_io_deq_ready_lockPool_io_actor_0_in_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
          instruction_io_deq_ready_lockPool_io_actor_0_in_w_1.bits <= req_1 @[ReadyValid.scala 17:12]
          instruction_io_deq_ready_lockPool_io_actor_0_in_w_1.valid <= enqueuer4.io.out[2].valid @[ReadyValid.scala 18:13]
          enqueuer4.io.out[2].ready <= instruction_io_deq_ready_lockPool_io_actor_0_in_w_1.ready @[ReadyValid.scala 19:11]
          lockPool.io.actor[0].in <= instruction_io_deq_ready_lockPool_io_actor_0_in_w_1 @[MultiEnqueue.scala 153:10]
          wire instruction_io_deq_ready_lockPool_io_lock_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : { cond : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}, lock : UInt<1>, acquire : UInt<1>, by : UInt<1>, delayRelease : UInt<4>}} @[ReadyValid.scala 16:17]
          instruction_io_deq_ready_lockPool_io_lock_w_1.bits <= instruction_io_deq_ready_w_10 @[ReadyValid.scala 17:12]
          instruction_io_deq_ready_lockPool_io_lock_w_1.valid <= enqueuer4.io.out[3].valid @[ReadyValid.scala 18:13]
          enqueuer4.io.out[3].ready <= instruction_io_deq_ready_lockPool_io_lock_w_1.ready @[ReadyValid.scala 19:11]
          lockPool.io.lock <= instruction_io_deq_ready_lockPool_io_lock_w_1 @[MultiEnqueue.scala 154:10]
          instruction.io.deq.ready <= enqueuer4.io.in.ready @[Decoder.scala 358:25]
      else :
        node _T_4 = eq(instruction.io.deq.bits.opcode, UInt<2>("h2")) @[Decoder.scala 373:38]
        when _T_4 : @[Decoder.scala 373:59]
          wire args_2 : { size : UInt<16>, _unused1 : UInt<1>, accStride : UInt<3>, accAddress : UInt<20>, _unused0 : UInt<0>, memStride : UInt<3>, memAddress : UInt<13>} @[Decoder.scala 375:11]
          wire flags_2 : { kind : UInt<4>} @[Decoder.scala 378:21]
          wire _args_WIRE_4 : { size : UInt<16>, _unused1 : UInt<1>, accStride : UInt<3>, accAddress : UInt<20>, _unused0 : UInt<0>, memStride : UInt<3>, memAddress : UInt<13>} @[Decoder.scala 380:48]
          wire _args_WIRE_5 : UInt<56>
          _args_WIRE_5 <= instruction.io.deq.bits.arguments
          node _args_T_9 = bits(_args_WIRE_5, 12, 0) @[Decoder.scala 380:48]
          _args_WIRE_4.memAddress <= _args_T_9 @[Decoder.scala 380:48]
          node _args_T_10 = bits(_args_WIRE_5, 15, 13) @[Decoder.scala 380:48]
          _args_WIRE_4.memStride <= _args_T_10 @[Decoder.scala 380:48]
          _args_WIRE_4._unused0 is invalid @[Decoder.scala 380:48]
          node _args_T_11 = bits(_args_WIRE_5, 35, 16) @[Decoder.scala 380:48]
          _args_WIRE_4.accAddress <= _args_T_11 @[Decoder.scala 380:48]
          node _args_T_12 = bits(_args_WIRE_5, 38, 36) @[Decoder.scala 380:48]
          _args_WIRE_4.accStride <= _args_T_12 @[Decoder.scala 380:48]
          node _args_T_13 = bits(_args_WIRE_5, 39, 39) @[Decoder.scala 380:48]
          _args_WIRE_4._unused1 <= _args_T_13 @[Decoder.scala 380:48]
          node _args_T_14 = bits(_args_WIRE_5, 55, 40) @[Decoder.scala 380:48]
          _args_WIRE_4.size <= _args_T_14 @[Decoder.scala 380:48]
          args_2 <= _args_WIRE_4 @[Decoder.scala 380:10]
          wire _flags_WIRE_4 : { kind : UInt<4>} @[Decoder.scala 381:45]
          wire _flags_WIRE_5 : UInt<4>
          _flags_WIRE_5 <= instruction.io.deq.bits.flags
          node _flags_T_5 = bits(_flags_WIRE_5, 3, 0) @[Decoder.scala 381:45]
          _flags_WIRE_4.kind <= _flags_T_5 @[Decoder.scala 381:45]
          flags_2 <= _flags_WIRE_4 @[Decoder.scala 381:11]
          node _T_5 = eq(flags_2.kind, UInt<1>("h0")) @[Decoder.scala 383:21]
          when _T_5 : @[Decoder.scala 383:53]
            wire req_2 : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 44:19]
            req_2.address <= args_2.memAddress @[MemControl.scala 45:17]
            req_2.size <= args_2.size @[MemControl.scala 46:14]
            req_2.stride <= args_2.memStride @[MemControl.scala 47:16]
            req_2.write <= UInt<1>("h1") @[MemControl.scala 48:15]
            req_2.reverse <= UInt<1>("h0") @[MemControl.scala 49:17]
            wire instruction_io_deq_ready_w_11 : { kind : UInt<2>, size : UInt<13>} @[HostRouter.scala 93:19]
            instruction_io_deq_ready_w_11.kind <= UInt<1>("h0") @[HostRouter.scala 94:14]
            instruction_io_deq_ready_w_11.size <= args_2.size @[HostRouter.scala 95:14]
            wire instruction_io_deq_ready_w_12 : { write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 44:19]
            instruction_io_deq_ready_w_12.address <= args_2.accAddress @[MemControl.scala 45:17]
            instruction_io_deq_ready_w_12.size <= args_2.size @[MemControl.scala 46:14]
            instruction_io_deq_ready_w_12.stride <= args_2.accStride @[MemControl.scala 47:16]
            instruction_io_deq_ready_w_12.write <= UInt<1>("h0") @[MemControl.scala 48:15]
            instruction_io_deq_ready_w_12.reverse <= UInt<1>("h0") @[MemControl.scala 49:17]
            wire instruction_io_deq_ready_w_13 : { cond : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}, lock : UInt<1>, acquire : UInt<1>, by : UInt<1>, delayRelease : UInt<4>} @[Decoder.scala 755:17]
            node _instruction_io_deq_ready_w_lock_T_2 = div(req_2.address, UInt<13>("h1000")) @[Decoder.scala 191:15]
            instruction_io_deq_ready_w_13.lock <= _instruction_io_deq_ready_w_lock_T_2 @[Decoder.scala 758:12]
            instruction_io_deq_ready_w_13.acquire <= UInt<1>("h1") @[Decoder.scala 759:15]
            instruction_io_deq_ready_w_13.by <= UInt<1>("h1") @[Decoder.scala 760:10]
            instruction_io_deq_ready_w_13.delayRelease <= UInt<1>("h0") @[Decoder.scala 761:20]
            instruction_io_deq_ready_w_13.cond <= req_2 @[Decoder.scala 762:12]
            enqueuer4.io.in.valid <= instruction.io.deq.valid @[MultiEnqueue.scala 150:17]
            wire instruction_io_deq_ready_hostDataflow_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { kind : UInt<2>, size : UInt<13>}} @[ReadyValid.scala 16:17]
            instruction_io_deq_ready_hostDataflow_io_enq_w.bits <= instruction_io_deq_ready_w_11 @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_hostDataflow_io_enq_w.valid <= enqueuer4.io.out[0].valid @[ReadyValid.scala 18:13]
            enqueuer4.io.out[0].ready <= instruction_io_deq_ready_hostDataflow_io_enq_w.ready @[ReadyValid.scala 19:11]
            hostDataflow.io.enq <= instruction_io_deq_ready_hostDataflow_io_enq_w @[MultiEnqueue.scala 151:10]
            wire instruction_io_deq_ready_lockPool_io_actor_1_in_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
            instruction_io_deq_ready_lockPool_io_actor_1_in_w.bits <= req_2 @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_lockPool_io_actor_1_in_w.valid <= enqueuer4.io.out[1].valid @[ReadyValid.scala 18:13]
            enqueuer4.io.out[1].ready <= instruction_io_deq_ready_lockPool_io_actor_1_in_w.ready @[ReadyValid.scala 19:11]
            lockPool.io.actor[1].in <= instruction_io_deq_ready_lockPool_io_actor_1_in_w @[MultiEnqueue.scala 152:10]
            wire instruction_io_deq_ready_dram0_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
            instruction_io_deq_ready_dram0_io_enq_w.bits <= instruction_io_deq_ready_w_12 @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_dram0_io_enq_w.valid <= enqueuer4.io.out[2].valid @[ReadyValid.scala 18:13]
            enqueuer4.io.out[2].ready <= instruction_io_deq_ready_dram0_io_enq_w.ready @[ReadyValid.scala 19:11]
            dram0.io.enq <= instruction_io_deq_ready_dram0_io_enq_w @[MultiEnqueue.scala 153:10]
            wire instruction_io_deq_ready_lockPool_io_lock_w_2 : { flip ready : UInt<1>, valid : UInt<1>, bits : { cond : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}, lock : UInt<1>, acquire : UInt<1>, by : UInt<1>, delayRelease : UInt<4>}} @[ReadyValid.scala 16:17]
            instruction_io_deq_ready_lockPool_io_lock_w_2.bits <= instruction_io_deq_ready_w_13 @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_lockPool_io_lock_w_2.valid <= enqueuer4.io.out[3].valid @[ReadyValid.scala 18:13]
            enqueuer4.io.out[3].ready <= instruction_io_deq_ready_lockPool_io_lock_w_2.ready @[ReadyValid.scala 19:11]
            lockPool.io.lock <= instruction_io_deq_ready_lockPool_io_lock_w_2 @[MultiEnqueue.scala 154:10]
            instruction.io.deq.ready <= enqueuer4.io.in.ready @[Decoder.scala 392:25]
          else :
            node _T_6 = eq(flags_2.kind, UInt<1>("h1")) @[Decoder.scala 412:27]
            when _T_6 : @[Decoder.scala 412:59]
              wire req_3 : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 44:19]
              req_3.address <= args_2.memAddress @[MemControl.scala 45:17]
              req_3.size <= args_2.size @[MemControl.scala 46:14]
              req_3.stride <= args_2.memStride @[MemControl.scala 47:16]
              req_3.write <= UInt<1>("h0") @[MemControl.scala 48:15]
              req_3.reverse <= UInt<1>("h0") @[MemControl.scala 49:17]
              wire instruction_io_deq_ready_w_14 : { kind : UInt<2>, size : UInt<13>} @[HostRouter.scala 93:19]
              instruction_io_deq_ready_w_14.kind <= UInt<1>("h1") @[HostRouter.scala 94:14]
              instruction_io_deq_ready_w_14.size <= args_2.size @[HostRouter.scala 95:14]
              wire instruction_io_deq_ready_w_15 : { write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 44:19]
              instruction_io_deq_ready_w_15.address <= args_2.accAddress @[MemControl.scala 45:17]
              instruction_io_deq_ready_w_15.size <= args_2.size @[MemControl.scala 46:14]
              instruction_io_deq_ready_w_15.stride <= args_2.accStride @[MemControl.scala 47:16]
              instruction_io_deq_ready_w_15.write <= UInt<1>("h1") @[MemControl.scala 48:15]
              instruction_io_deq_ready_w_15.reverse <= UInt<1>("h0") @[MemControl.scala 49:17]
              wire instruction_io_deq_ready_w_16 : { cond : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}, lock : UInt<1>, acquire : UInt<1>, by : UInt<1>, delayRelease : UInt<4>} @[Decoder.scala 755:17]
              node _instruction_io_deq_ready_w_lock_T_3 = div(req_3.address, UInt<13>("h1000")) @[Decoder.scala 191:15]
              instruction_io_deq_ready_w_16.lock <= _instruction_io_deq_ready_w_lock_T_3 @[Decoder.scala 758:12]
              instruction_io_deq_ready_w_16.acquire <= UInt<1>("h1") @[Decoder.scala 759:15]
              instruction_io_deq_ready_w_16.by <= UInt<1>("h1") @[Decoder.scala 760:10]
              instruction_io_deq_ready_w_16.delayRelease <= UInt<1>("h0") @[Decoder.scala 761:20]
              instruction_io_deq_ready_w_16.cond <= req_3 @[Decoder.scala 762:12]
              enqueuer4.io.in.valid <= instruction.io.deq.valid @[MultiEnqueue.scala 150:17]
              wire instruction_io_deq_ready_hostDataflow_io_enq_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : { kind : UInt<2>, size : UInt<13>}} @[ReadyValid.scala 16:17]
              instruction_io_deq_ready_hostDataflow_io_enq_w_1.bits <= instruction_io_deq_ready_w_14 @[ReadyValid.scala 17:12]
              instruction_io_deq_ready_hostDataflow_io_enq_w_1.valid <= enqueuer4.io.out[0].valid @[ReadyValid.scala 18:13]
              enqueuer4.io.out[0].ready <= instruction_io_deq_ready_hostDataflow_io_enq_w_1.ready @[ReadyValid.scala 19:11]
              hostDataflow.io.enq <= instruction_io_deq_ready_hostDataflow_io_enq_w_1 @[MultiEnqueue.scala 151:10]
              wire instruction_io_deq_ready_lockPool_io_actor_1_in_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
              instruction_io_deq_ready_lockPool_io_actor_1_in_w_1.bits <= req_3 @[ReadyValid.scala 17:12]
              instruction_io_deq_ready_lockPool_io_actor_1_in_w_1.valid <= enqueuer4.io.out[1].valid @[ReadyValid.scala 18:13]
              enqueuer4.io.out[1].ready <= instruction_io_deq_ready_lockPool_io_actor_1_in_w_1.ready @[ReadyValid.scala 19:11]
              lockPool.io.actor[1].in <= instruction_io_deq_ready_lockPool_io_actor_1_in_w_1 @[MultiEnqueue.scala 152:10]
              wire instruction_io_deq_ready_dram0_io_enq_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
              instruction_io_deq_ready_dram0_io_enq_w_1.bits <= instruction_io_deq_ready_w_15 @[ReadyValid.scala 17:12]
              instruction_io_deq_ready_dram0_io_enq_w_1.valid <= enqueuer4.io.out[2].valid @[ReadyValid.scala 18:13]
              enqueuer4.io.out[2].ready <= instruction_io_deq_ready_dram0_io_enq_w_1.ready @[ReadyValid.scala 19:11]
              dram0.io.enq <= instruction_io_deq_ready_dram0_io_enq_w_1 @[MultiEnqueue.scala 153:10]
              wire instruction_io_deq_ready_lockPool_io_lock_w_3 : { flip ready : UInt<1>, valid : UInt<1>, bits : { cond : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}, lock : UInt<1>, acquire : UInt<1>, by : UInt<1>, delayRelease : UInt<4>}} @[ReadyValid.scala 16:17]
              instruction_io_deq_ready_lockPool_io_lock_w_3.bits <= instruction_io_deq_ready_w_16 @[ReadyValid.scala 17:12]
              instruction_io_deq_ready_lockPool_io_lock_w_3.valid <= enqueuer4.io.out[3].valid @[ReadyValid.scala 18:13]
              enqueuer4.io.out[3].ready <= instruction_io_deq_ready_lockPool_io_lock_w_3.ready @[ReadyValid.scala 19:11]
              lockPool.io.lock <= instruction_io_deq_ready_lockPool_io_lock_w_3 @[MultiEnqueue.scala 154:10]
              instruction.io.deq.ready <= enqueuer4.io.in.ready @[Decoder.scala 421:25]
            else :
              node _T_7 = eq(flags_2.kind, UInt<2>("h2")) @[Decoder.scala 441:27]
              when _T_7 : @[Decoder.scala 441:59]
                wire req_4 : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 44:19]
                req_4.address <= args_2.memAddress @[MemControl.scala 45:17]
                req_4.size <= args_2.size @[MemControl.scala 46:14]
                req_4.stride <= args_2.memStride @[MemControl.scala 47:16]
                req_4.write <= UInt<1>("h1") @[MemControl.scala 48:15]
                req_4.reverse <= UInt<1>("h0") @[MemControl.scala 49:17]
                wire instruction_io_deq_ready_w_17 : { kind : UInt<2>, size : UInt<13>} @[HostRouter.scala 93:19]
                instruction_io_deq_ready_w_17.kind <= UInt<2>("h2") @[HostRouter.scala 94:14]
                instruction_io_deq_ready_w_17.size <= args_2.size @[HostRouter.scala 95:14]
                wire instruction_io_deq_ready_w_18 : { write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 44:19]
                instruction_io_deq_ready_w_18.address <= args_2.accAddress @[MemControl.scala 45:17]
                instruction_io_deq_ready_w_18.size <= args_2.size @[MemControl.scala 46:14]
                instruction_io_deq_ready_w_18.stride <= args_2.accStride @[MemControl.scala 47:16]
                instruction_io_deq_ready_w_18.write <= UInt<1>("h0") @[MemControl.scala 48:15]
                instruction_io_deq_ready_w_18.reverse <= UInt<1>("h0") @[MemControl.scala 49:17]
                wire instruction_io_deq_ready_w_19 : { cond : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}, lock : UInt<1>, acquire : UInt<1>, by : UInt<1>, delayRelease : UInt<4>} @[Decoder.scala 755:17]
                node _instruction_io_deq_ready_w_lock_T_4 = div(req_4.address, UInt<13>("h1000")) @[Decoder.scala 191:15]
                instruction_io_deq_ready_w_19.lock <= _instruction_io_deq_ready_w_lock_T_4 @[Decoder.scala 758:12]
                instruction_io_deq_ready_w_19.acquire <= UInt<1>("h1") @[Decoder.scala 759:15]
                instruction_io_deq_ready_w_19.by <= UInt<1>("h1") @[Decoder.scala 760:10]
                instruction_io_deq_ready_w_19.delayRelease <= UInt<1>("h0") @[Decoder.scala 761:20]
                instruction_io_deq_ready_w_19.cond <= req_4 @[Decoder.scala 762:12]
                enqueuer4.io.in.valid <= instruction.io.deq.valid @[MultiEnqueue.scala 150:17]
                wire instruction_io_deq_ready_hostDataflow_io_enq_w_2 : { flip ready : UInt<1>, valid : UInt<1>, bits : { kind : UInt<2>, size : UInt<13>}} @[ReadyValid.scala 16:17]
                instruction_io_deq_ready_hostDataflow_io_enq_w_2.bits <= instruction_io_deq_ready_w_17 @[ReadyValid.scala 17:12]
                instruction_io_deq_ready_hostDataflow_io_enq_w_2.valid <= enqueuer4.io.out[0].valid @[ReadyValid.scala 18:13]
                enqueuer4.io.out[0].ready <= instruction_io_deq_ready_hostDataflow_io_enq_w_2.ready @[ReadyValid.scala 19:11]
                hostDataflow.io.enq <= instruction_io_deq_ready_hostDataflow_io_enq_w_2 @[MultiEnqueue.scala 151:10]
                wire instruction_io_deq_ready_lockPool_io_actor_1_in_w_2 : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
                instruction_io_deq_ready_lockPool_io_actor_1_in_w_2.bits <= req_4 @[ReadyValid.scala 17:12]
                instruction_io_deq_ready_lockPool_io_actor_1_in_w_2.valid <= enqueuer4.io.out[1].valid @[ReadyValid.scala 18:13]
                enqueuer4.io.out[1].ready <= instruction_io_deq_ready_lockPool_io_actor_1_in_w_2.ready @[ReadyValid.scala 19:11]
                lockPool.io.actor[1].in <= instruction_io_deq_ready_lockPool_io_actor_1_in_w_2 @[MultiEnqueue.scala 152:10]
                wire instruction_io_deq_ready_dram1_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
                instruction_io_deq_ready_dram1_io_enq_w.bits <= instruction_io_deq_ready_w_18 @[ReadyValid.scala 17:12]
                instruction_io_deq_ready_dram1_io_enq_w.valid <= enqueuer4.io.out[2].valid @[ReadyValid.scala 18:13]
                enqueuer4.io.out[2].ready <= instruction_io_deq_ready_dram1_io_enq_w.ready @[ReadyValid.scala 19:11]
                dram1.io.enq <= instruction_io_deq_ready_dram1_io_enq_w @[MultiEnqueue.scala 153:10]
                wire instruction_io_deq_ready_lockPool_io_lock_w_4 : { flip ready : UInt<1>, valid : UInt<1>, bits : { cond : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}, lock : UInt<1>, acquire : UInt<1>, by : UInt<1>, delayRelease : UInt<4>}} @[ReadyValid.scala 16:17]
                instruction_io_deq_ready_lockPool_io_lock_w_4.bits <= instruction_io_deq_ready_w_19 @[ReadyValid.scala 17:12]
                instruction_io_deq_ready_lockPool_io_lock_w_4.valid <= enqueuer4.io.out[3].valid @[ReadyValid.scala 18:13]
                enqueuer4.io.out[3].ready <= instruction_io_deq_ready_lockPool_io_lock_w_4.ready @[ReadyValid.scala 19:11]
                lockPool.io.lock <= instruction_io_deq_ready_lockPool_io_lock_w_4 @[MultiEnqueue.scala 154:10]
                instruction.io.deq.ready <= enqueuer4.io.in.ready @[Decoder.scala 450:25]
              else :
                node _T_8 = eq(flags_2.kind, UInt<2>("h3")) @[Decoder.scala 470:27]
                when _T_8 : @[Decoder.scala 470:59]
                  wire req_5 : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 44:19]
                  req_5.address <= args_2.memAddress @[MemControl.scala 45:17]
                  req_5.size <= args_2.size @[MemControl.scala 46:14]
                  req_5.stride <= args_2.memStride @[MemControl.scala 47:16]
                  req_5.write <= UInt<1>("h0") @[MemControl.scala 48:15]
                  req_5.reverse <= UInt<1>("h0") @[MemControl.scala 49:17]
                  wire instruction_io_deq_ready_w_20 : { kind : UInt<2>, size : UInt<13>} @[HostRouter.scala 93:19]
                  instruction_io_deq_ready_w_20.kind <= UInt<2>("h3") @[HostRouter.scala 94:14]
                  instruction_io_deq_ready_w_20.size <= args_2.size @[HostRouter.scala 95:14]
                  wire instruction_io_deq_ready_w_21 : { write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 44:19]
                  instruction_io_deq_ready_w_21.address <= args_2.accAddress @[MemControl.scala 45:17]
                  instruction_io_deq_ready_w_21.size <= args_2.size @[MemControl.scala 46:14]
                  instruction_io_deq_ready_w_21.stride <= args_2.accStride @[MemControl.scala 47:16]
                  instruction_io_deq_ready_w_21.write <= UInt<1>("h1") @[MemControl.scala 48:15]
                  instruction_io_deq_ready_w_21.reverse <= UInt<1>("h0") @[MemControl.scala 49:17]
                  wire instruction_io_deq_ready_w_22 : { cond : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}, lock : UInt<1>, acquire : UInt<1>, by : UInt<1>, delayRelease : UInt<4>} @[Decoder.scala 755:17]
                  node _instruction_io_deq_ready_w_lock_T_5 = div(req_5.address, UInt<13>("h1000")) @[Decoder.scala 191:15]
                  instruction_io_deq_ready_w_22.lock <= _instruction_io_deq_ready_w_lock_T_5 @[Decoder.scala 758:12]
                  instruction_io_deq_ready_w_22.acquire <= UInt<1>("h1") @[Decoder.scala 759:15]
                  instruction_io_deq_ready_w_22.by <= UInt<1>("h1") @[Decoder.scala 760:10]
                  instruction_io_deq_ready_w_22.delayRelease <= UInt<1>("h0") @[Decoder.scala 761:20]
                  instruction_io_deq_ready_w_22.cond <= req_5 @[Decoder.scala 762:12]
                  enqueuer4.io.in.valid <= instruction.io.deq.valid @[MultiEnqueue.scala 150:17]
                  wire instruction_io_deq_ready_hostDataflow_io_enq_w_3 : { flip ready : UInt<1>, valid : UInt<1>, bits : { kind : UInt<2>, size : UInt<13>}} @[ReadyValid.scala 16:17]
                  instruction_io_deq_ready_hostDataflow_io_enq_w_3.bits <= instruction_io_deq_ready_w_20 @[ReadyValid.scala 17:12]
                  instruction_io_deq_ready_hostDataflow_io_enq_w_3.valid <= enqueuer4.io.out[0].valid @[ReadyValid.scala 18:13]
                  enqueuer4.io.out[0].ready <= instruction_io_deq_ready_hostDataflow_io_enq_w_3.ready @[ReadyValid.scala 19:11]
                  hostDataflow.io.enq <= instruction_io_deq_ready_hostDataflow_io_enq_w_3 @[MultiEnqueue.scala 151:10]
                  wire instruction_io_deq_ready_lockPool_io_actor_1_in_w_3 : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
                  instruction_io_deq_ready_lockPool_io_actor_1_in_w_3.bits <= req_5 @[ReadyValid.scala 17:12]
                  instruction_io_deq_ready_lockPool_io_actor_1_in_w_3.valid <= enqueuer4.io.out[1].valid @[ReadyValid.scala 18:13]
                  enqueuer4.io.out[1].ready <= instruction_io_deq_ready_lockPool_io_actor_1_in_w_3.ready @[ReadyValid.scala 19:11]
                  lockPool.io.actor[1].in <= instruction_io_deq_ready_lockPool_io_actor_1_in_w_3 @[MultiEnqueue.scala 152:10]
                  wire instruction_io_deq_ready_dram1_io_enq_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
                  instruction_io_deq_ready_dram1_io_enq_w_1.bits <= instruction_io_deq_ready_w_21 @[ReadyValid.scala 17:12]
                  instruction_io_deq_ready_dram1_io_enq_w_1.valid <= enqueuer4.io.out[2].valid @[ReadyValid.scala 18:13]
                  enqueuer4.io.out[2].ready <= instruction_io_deq_ready_dram1_io_enq_w_1.ready @[ReadyValid.scala 19:11]
                  dram1.io.enq <= instruction_io_deq_ready_dram1_io_enq_w_1 @[MultiEnqueue.scala 153:10]
                  wire instruction_io_deq_ready_lockPool_io_lock_w_5 : { flip ready : UInt<1>, valid : UInt<1>, bits : { cond : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}, lock : UInt<1>, acquire : UInt<1>, by : UInt<1>, delayRelease : UInt<4>}} @[ReadyValid.scala 16:17]
                  instruction_io_deq_ready_lockPool_io_lock_w_5.bits <= instruction_io_deq_ready_w_22 @[ReadyValid.scala 17:12]
                  instruction_io_deq_ready_lockPool_io_lock_w_5.valid <= enqueuer4.io.out[3].valid @[ReadyValid.scala 18:13]
                  enqueuer4.io.out[3].ready <= instruction_io_deq_ready_lockPool_io_lock_w_5.ready @[ReadyValid.scala 19:11]
                  lockPool.io.lock <= instruction_io_deq_ready_lockPool_io_lock_w_5 @[MultiEnqueue.scala 154:10]
                  instruction.io.deq.ready <= enqueuer4.io.in.ready @[Decoder.scala 478:25]
                else :
                  node _T_9 = eq(flags_2.kind, UInt<4>("hc")) @[Decoder.scala 499:18]
                  when _T_9 : @[Decoder.scala 500:7]
                    wire req_6 : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 44:19]
                    req_6.address <= args_2.memAddress @[MemControl.scala 45:17]
                    req_6.size <= args_2.size @[MemControl.scala 46:14]
                    req_6.stride <= args_2.memStride @[MemControl.scala 47:16]
                    req_6.write <= UInt<1>("h1") @[MemControl.scala 48:15]
                    req_6.reverse <= UInt<1>("h0") @[MemControl.scala 49:17]
                    wire instruction_io_deq_ready_w_23 : { kind : UInt<4>, size : UInt<13>} @[LocalDataFlowControl.scala 28:19]
                    instruction_io_deq_ready_w_23.kind <= UInt<3>("h4") @[LocalDataFlowControl.scala 29:14]
                    instruction_io_deq_ready_w_23.size <= args_2.size @[LocalDataFlowControl.scala 30:14]
                    wire instruction_io_deq_ready_w_24 : { instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<11>, altAddress : UInt<11>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<11>, stride : UInt<3>, reverse : UInt<1>} @[Decoder.scala 716:17]
                    instruction_io_deq_ready_w_24.instruction.dest <= UInt<1>("h0") @[Decoder.scala 717:19]
                    instruction_io_deq_ready_w_24.instruction.sourceRight <= UInt<1>("h0") @[Decoder.scala 717:19]
                    instruction_io_deq_ready_w_24.instruction.sourceLeft <= UInt<1>("h0") @[Decoder.scala 717:19]
                    instruction_io_deq_ready_w_24.instruction.op <= UInt<1>("h0") @[Decoder.scala 717:19]
                    instruction_io_deq_ready_w_24.address <= args_2.accAddress @[Decoder.scala 718:15]
                    instruction_io_deq_ready_w_24.altAddress <= UInt<1>("h0") @[Decoder.scala 719:18]
                    instruction_io_deq_ready_w_24.accumulate <= UInt<1>("h0") @[Decoder.scala 720:18]
                    instruction_io_deq_ready_w_24.write <= UInt<1>("h0") @[Decoder.scala 721:13]
                    instruction_io_deq_ready_w_24.read <= UInt<1>("h1") @[Decoder.scala 722:12]
                    instruction_io_deq_ready_w_24.size <= args_2.size @[Decoder.scala 723:12]
                    instruction_io_deq_ready_w_24.stride <= args_2.accStride @[Decoder.scala 724:14]
                    instruction_io_deq_ready_w_24.reverse <= UInt<1>("h0") @[Decoder.scala 725:15]
                    wire instruction_io_deq_ready_w_25 : { cond : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}, lock : UInt<1>, acquire : UInt<1>, by : UInt<1>, delayRelease : UInt<4>} @[Decoder.scala 755:17]
                    node _instruction_io_deq_ready_w_lock_T_6 = div(req_6.address, UInt<13>("h1000")) @[Decoder.scala 191:15]
                    instruction_io_deq_ready_w_25.lock <= _instruction_io_deq_ready_w_lock_T_6 @[Decoder.scala 758:12]
                    instruction_io_deq_ready_w_25.acquire <= UInt<1>("h1") @[Decoder.scala 759:15]
                    instruction_io_deq_ready_w_25.by <= UInt<1>("h0") @[Decoder.scala 760:10]
                    instruction_io_deq_ready_w_25.delayRelease <= UInt<1>("h0") @[Decoder.scala 761:20]
                    instruction_io_deq_ready_w_25.cond <= req_6 @[Decoder.scala 762:12]
                    enqueuer4.io.in.valid <= instruction.io.deq.valid @[MultiEnqueue.scala 150:17]
                    wire instruction_io_deq_ready_dataflow_io_enq_w_3 : { flip ready : UInt<1>, valid : UInt<1>, bits : { kind : UInt<4>, size : UInt<13>}} @[ReadyValid.scala 16:17]
                    instruction_io_deq_ready_dataflow_io_enq_w_3.bits <= instruction_io_deq_ready_w_23 @[ReadyValid.scala 17:12]
                    instruction_io_deq_ready_dataflow_io_enq_w_3.valid <= enqueuer4.io.out[0].valid @[ReadyValid.scala 18:13]
                    enqueuer4.io.out[0].ready <= instruction_io_deq_ready_dataflow_io_enq_w_3.ready @[ReadyValid.scala 19:11]
                    dataflow.io.enq <= instruction_io_deq_ready_dataflow_io_enq_w_3 @[MultiEnqueue.scala 151:10]
                    wire instruction_io_deq_ready_lockPool_io_actor_0_in_w_2 : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
                    instruction_io_deq_ready_lockPool_io_actor_0_in_w_2.bits <= req_6 @[ReadyValid.scala 17:12]
                    instruction_io_deq_ready_lockPool_io_actor_0_in_w_2.valid <= enqueuer4.io.out[1].valid @[ReadyValid.scala 18:13]
                    enqueuer4.io.out[1].ready <= instruction_io_deq_ready_lockPool_io_actor_0_in_w_2.ready @[ReadyValid.scala 19:11]
                    lockPool.io.actor[0].in <= instruction_io_deq_ready_lockPool_io_actor_0_in_w_2 @[MultiEnqueue.scala 152:10]
                    wire instruction_io_deq_ready_acc_io_enq_w_2 : { flip ready : UInt<1>, valid : UInt<1>, bits : { instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<11>, altAddress : UInt<11>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<11>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
                    instruction_io_deq_ready_acc_io_enq_w_2.bits <= instruction_io_deq_ready_w_24 @[ReadyValid.scala 17:12]
                    instruction_io_deq_ready_acc_io_enq_w_2.valid <= enqueuer4.io.out[2].valid @[ReadyValid.scala 18:13]
                    enqueuer4.io.out[2].ready <= instruction_io_deq_ready_acc_io_enq_w_2.ready @[ReadyValid.scala 19:11]
                    acc.io.enq <= instruction_io_deq_ready_acc_io_enq_w_2 @[MultiEnqueue.scala 153:10]
                    wire instruction_io_deq_ready_lockPool_io_lock_w_6 : { flip ready : UInt<1>, valid : UInt<1>, bits : { cond : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}, lock : UInt<1>, acquire : UInt<1>, by : UInt<1>, delayRelease : UInt<4>}} @[ReadyValid.scala 16:17]
                    instruction_io_deq_ready_lockPool_io_lock_w_6.bits <= instruction_io_deq_ready_w_25 @[ReadyValid.scala 17:12]
                    instruction_io_deq_ready_lockPool_io_lock_w_6.valid <= enqueuer4.io.out[3].valid @[ReadyValid.scala 18:13]
                    enqueuer4.io.out[3].ready <= instruction_io_deq_ready_lockPool_io_lock_w_6.ready @[ReadyValid.scala 19:11]
                    lockPool.io.lock <= instruction_io_deq_ready_lockPool_io_lock_w_6 @[MultiEnqueue.scala 154:10]
                    instruction.io.deq.ready <= enqueuer4.io.in.ready @[Decoder.scala 509:25]
                  else :
                    node _T_10 = eq(flags_2.kind, UInt<4>("hd")) @[Decoder.scala 524:18]
                    when _T_10 : @[Decoder.scala 525:7]
                      wire req_7 : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 44:19]
                      req_7.address <= args_2.memAddress @[MemControl.scala 45:17]
                      req_7.size <= args_2.size @[MemControl.scala 46:14]
                      req_7.stride <= args_2.memStride @[MemControl.scala 47:16]
                      req_7.write <= UInt<1>("h0") @[MemControl.scala 48:15]
                      req_7.reverse <= UInt<1>("h0") @[MemControl.scala 49:17]
                      wire instruction_io_deq_ready_w_26 : { kind : UInt<4>, size : UInt<13>} @[LocalDataFlowControl.scala 28:19]
                      instruction_io_deq_ready_w_26.kind <= UInt<3>("h5") @[LocalDataFlowControl.scala 29:14]
                      instruction_io_deq_ready_w_26.size <= args_2.size @[LocalDataFlowControl.scala 30:14]
                      wire instruction_io_deq_ready_w_27 : { instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<11>, altAddress : UInt<11>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<11>, stride : UInt<3>, reverse : UInt<1>} @[Decoder.scala 716:17]
                      instruction_io_deq_ready_w_27.instruction.dest <= UInt<1>("h0") @[Decoder.scala 717:19]
                      instruction_io_deq_ready_w_27.instruction.sourceRight <= UInt<1>("h0") @[Decoder.scala 717:19]
                      instruction_io_deq_ready_w_27.instruction.sourceLeft <= UInt<1>("h0") @[Decoder.scala 717:19]
                      instruction_io_deq_ready_w_27.instruction.op <= UInt<1>("h0") @[Decoder.scala 717:19]
                      instruction_io_deq_ready_w_27.address <= args_2.accAddress @[Decoder.scala 718:15]
                      instruction_io_deq_ready_w_27.altAddress <= UInt<1>("h0") @[Decoder.scala 719:18]
                      instruction_io_deq_ready_w_27.accumulate <= UInt<1>("h0") @[Decoder.scala 720:18]
                      instruction_io_deq_ready_w_27.write <= UInt<1>("h1") @[Decoder.scala 721:13]
                      instruction_io_deq_ready_w_27.read <= UInt<1>("h0") @[Decoder.scala 722:12]
                      instruction_io_deq_ready_w_27.size <= args_2.size @[Decoder.scala 723:12]
                      instruction_io_deq_ready_w_27.stride <= args_2.accStride @[Decoder.scala 724:14]
                      instruction_io_deq_ready_w_27.reverse <= UInt<1>("h0") @[Decoder.scala 725:15]
                      wire instruction_io_deq_ready_w_28 : { cond : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}, lock : UInt<1>, acquire : UInt<1>, by : UInt<1>, delayRelease : UInt<4>} @[Decoder.scala 755:17]
                      node _instruction_io_deq_ready_w_lock_T_7 = div(req_7.address, UInt<13>("h1000")) @[Decoder.scala 191:15]
                      instruction_io_deq_ready_w_28.lock <= _instruction_io_deq_ready_w_lock_T_7 @[Decoder.scala 758:12]
                      instruction_io_deq_ready_w_28.acquire <= UInt<1>("h1") @[Decoder.scala 759:15]
                      instruction_io_deq_ready_w_28.by <= UInt<1>("h0") @[Decoder.scala 760:10]
                      instruction_io_deq_ready_w_28.delayRelease <= UInt<1>("h0") @[Decoder.scala 761:20]
                      instruction_io_deq_ready_w_28.cond <= req_7 @[Decoder.scala 762:12]
                      enqueuer4.io.in.valid <= instruction.io.deq.valid @[MultiEnqueue.scala 150:17]
                      wire instruction_io_deq_ready_dataflow_io_enq_w_4 : { flip ready : UInt<1>, valid : UInt<1>, bits : { kind : UInt<4>, size : UInt<13>}} @[ReadyValid.scala 16:17]
                      instruction_io_deq_ready_dataflow_io_enq_w_4.bits <= instruction_io_deq_ready_w_26 @[ReadyValid.scala 17:12]
                      instruction_io_deq_ready_dataflow_io_enq_w_4.valid <= enqueuer4.io.out[0].valid @[ReadyValid.scala 18:13]
                      enqueuer4.io.out[0].ready <= instruction_io_deq_ready_dataflow_io_enq_w_4.ready @[ReadyValid.scala 19:11]
                      dataflow.io.enq <= instruction_io_deq_ready_dataflow_io_enq_w_4 @[MultiEnqueue.scala 151:10]
                      wire instruction_io_deq_ready_lockPool_io_actor_0_in_w_3 : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
                      instruction_io_deq_ready_lockPool_io_actor_0_in_w_3.bits <= req_7 @[ReadyValid.scala 17:12]
                      instruction_io_deq_ready_lockPool_io_actor_0_in_w_3.valid <= enqueuer4.io.out[1].valid @[ReadyValid.scala 18:13]
                      enqueuer4.io.out[1].ready <= instruction_io_deq_ready_lockPool_io_actor_0_in_w_3.ready @[ReadyValid.scala 19:11]
                      lockPool.io.actor[0].in <= instruction_io_deq_ready_lockPool_io_actor_0_in_w_3 @[MultiEnqueue.scala 152:10]
                      wire instruction_io_deq_ready_acc_io_enq_w_3 : { flip ready : UInt<1>, valid : UInt<1>, bits : { instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<11>, altAddress : UInt<11>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<11>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
                      instruction_io_deq_ready_acc_io_enq_w_3.bits <= instruction_io_deq_ready_w_27 @[ReadyValid.scala 17:12]
                      instruction_io_deq_ready_acc_io_enq_w_3.valid <= enqueuer4.io.out[2].valid @[ReadyValid.scala 18:13]
                      enqueuer4.io.out[2].ready <= instruction_io_deq_ready_acc_io_enq_w_3.ready @[ReadyValid.scala 19:11]
                      acc.io.enq <= instruction_io_deq_ready_acc_io_enq_w_3 @[MultiEnqueue.scala 153:10]
                      wire instruction_io_deq_ready_lockPool_io_lock_w_7 : { flip ready : UInt<1>, valid : UInt<1>, bits : { cond : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}, lock : UInt<1>, acquire : UInt<1>, by : UInt<1>, delayRelease : UInt<4>}} @[ReadyValid.scala 16:17]
                      instruction_io_deq_ready_lockPool_io_lock_w_7.bits <= instruction_io_deq_ready_w_28 @[ReadyValid.scala 17:12]
                      instruction_io_deq_ready_lockPool_io_lock_w_7.valid <= enqueuer4.io.out[3].valid @[ReadyValid.scala 18:13]
                      enqueuer4.io.out[3].ready <= instruction_io_deq_ready_lockPool_io_lock_w_7.ready @[ReadyValid.scala 19:11]
                      lockPool.io.lock <= instruction_io_deq_ready_lockPool_io_lock_w_7 @[MultiEnqueue.scala 154:10]
                      instruction.io.deq.ready <= enqueuer4.io.in.ready @[Decoder.scala 534:25]
                    else :
                      node _T_11 = eq(flags_2.kind, UInt<4>("hf")) @[Decoder.scala 549:18]
                      when _T_11 : @[Decoder.scala 550:7]
                        wire req_8 : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 44:19]
                        req_8.address <= args_2.memAddress @[MemControl.scala 45:17]
                        req_8.size <= args_2.size @[MemControl.scala 46:14]
                        req_8.stride <= args_2.memStride @[MemControl.scala 47:16]
                        req_8.write <= UInt<1>("h0") @[MemControl.scala 48:15]
                        req_8.reverse <= UInt<1>("h0") @[MemControl.scala 49:17]
                        wire instruction_io_deq_ready_w_29 : { kind : UInt<4>, size : UInt<13>} @[LocalDataFlowControl.scala 28:19]
                        instruction_io_deq_ready_w_29.kind <= UInt<3>("h5") @[LocalDataFlowControl.scala 29:14]
                        instruction_io_deq_ready_w_29.size <= args_2.size @[LocalDataFlowControl.scala 30:14]
                        wire instruction_io_deq_ready_w_30 : { instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<11>, altAddress : UInt<11>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<11>, stride : UInt<3>, reverse : UInt<1>} @[Decoder.scala 716:17]
                        instruction_io_deq_ready_w_30.instruction.dest <= UInt<1>("h0") @[Decoder.scala 717:19]
                        instruction_io_deq_ready_w_30.instruction.sourceRight <= UInt<1>("h0") @[Decoder.scala 717:19]
                        instruction_io_deq_ready_w_30.instruction.sourceLeft <= UInt<1>("h0") @[Decoder.scala 717:19]
                        instruction_io_deq_ready_w_30.instruction.op <= UInt<1>("h0") @[Decoder.scala 717:19]
                        instruction_io_deq_ready_w_30.address <= args_2.accAddress @[Decoder.scala 718:15]
                        instruction_io_deq_ready_w_30.altAddress <= UInt<1>("h0") @[Decoder.scala 719:18]
                        instruction_io_deq_ready_w_30.accumulate <= UInt<1>("h1") @[Decoder.scala 720:18]
                        instruction_io_deq_ready_w_30.write <= UInt<1>("h1") @[Decoder.scala 721:13]
                        instruction_io_deq_ready_w_30.read <= UInt<1>("h0") @[Decoder.scala 722:12]
                        instruction_io_deq_ready_w_30.size <= args_2.size @[Decoder.scala 723:12]
                        instruction_io_deq_ready_w_30.stride <= args_2.accStride @[Decoder.scala 724:14]
                        instruction_io_deq_ready_w_30.reverse <= UInt<1>("h0") @[Decoder.scala 725:15]
                        wire instruction_io_deq_ready_w_31 : { cond : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}, lock : UInt<1>, acquire : UInt<1>, by : UInt<1>, delayRelease : UInt<4>} @[Decoder.scala 755:17]
                        node _instruction_io_deq_ready_w_lock_T_8 = div(req_8.address, UInt<13>("h1000")) @[Decoder.scala 191:15]
                        instruction_io_deq_ready_w_31.lock <= _instruction_io_deq_ready_w_lock_T_8 @[Decoder.scala 758:12]
                        instruction_io_deq_ready_w_31.acquire <= UInt<1>("h1") @[Decoder.scala 759:15]
                        instruction_io_deq_ready_w_31.by <= UInt<1>("h0") @[Decoder.scala 760:10]
                        instruction_io_deq_ready_w_31.delayRelease <= UInt<1>("h0") @[Decoder.scala 761:20]
                        instruction_io_deq_ready_w_31.cond <= req_8 @[Decoder.scala 762:12]
                        enqueuer4.io.in.valid <= instruction.io.deq.valid @[MultiEnqueue.scala 150:17]
                        wire instruction_io_deq_ready_dataflow_io_enq_w_5 : { flip ready : UInt<1>, valid : UInt<1>, bits : { kind : UInt<4>, size : UInt<13>}} @[ReadyValid.scala 16:17]
                        instruction_io_deq_ready_dataflow_io_enq_w_5.bits <= instruction_io_deq_ready_w_29 @[ReadyValid.scala 17:12]
                        instruction_io_deq_ready_dataflow_io_enq_w_5.valid <= enqueuer4.io.out[0].valid @[ReadyValid.scala 18:13]
                        enqueuer4.io.out[0].ready <= instruction_io_deq_ready_dataflow_io_enq_w_5.ready @[ReadyValid.scala 19:11]
                        dataflow.io.enq <= instruction_io_deq_ready_dataflow_io_enq_w_5 @[MultiEnqueue.scala 151:10]
                        wire instruction_io_deq_ready_lockPool_io_actor_0_in_w_4 : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
                        instruction_io_deq_ready_lockPool_io_actor_0_in_w_4.bits <= req_8 @[ReadyValid.scala 17:12]
                        instruction_io_deq_ready_lockPool_io_actor_0_in_w_4.valid <= enqueuer4.io.out[1].valid @[ReadyValid.scala 18:13]
                        enqueuer4.io.out[1].ready <= instruction_io_deq_ready_lockPool_io_actor_0_in_w_4.ready @[ReadyValid.scala 19:11]
                        lockPool.io.actor[0].in <= instruction_io_deq_ready_lockPool_io_actor_0_in_w_4 @[MultiEnqueue.scala 152:10]
                        wire instruction_io_deq_ready_acc_io_enq_w_4 : { flip ready : UInt<1>, valid : UInt<1>, bits : { instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<11>, altAddress : UInt<11>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<11>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
                        instruction_io_deq_ready_acc_io_enq_w_4.bits <= instruction_io_deq_ready_w_30 @[ReadyValid.scala 17:12]
                        instruction_io_deq_ready_acc_io_enq_w_4.valid <= enqueuer4.io.out[2].valid @[ReadyValid.scala 18:13]
                        enqueuer4.io.out[2].ready <= instruction_io_deq_ready_acc_io_enq_w_4.ready @[ReadyValid.scala 19:11]
                        acc.io.enq <= instruction_io_deq_ready_acc_io_enq_w_4 @[MultiEnqueue.scala 153:10]
                        wire instruction_io_deq_ready_lockPool_io_lock_w_8 : { flip ready : UInt<1>, valid : UInt<1>, bits : { cond : { write : UInt<1>, address : UInt<13>, size : UInt<13>, stride : UInt<3>, reverse : UInt<1>}, lock : UInt<1>, acquire : UInt<1>, by : UInt<1>, delayRelease : UInt<4>}} @[ReadyValid.scala 16:17]
                        instruction_io_deq_ready_lockPool_io_lock_w_8.bits <= instruction_io_deq_ready_w_31 @[ReadyValid.scala 17:12]
                        instruction_io_deq_ready_lockPool_io_lock_w_8.valid <= enqueuer4.io.out[3].valid @[ReadyValid.scala 18:13]
                        enqueuer4.io.out[3].ready <= instruction_io_deq_ready_lockPool_io_lock_w_8.ready @[ReadyValid.scala 19:11]
                        lockPool.io.lock <= instruction_io_deq_ready_lockPool_io_lock_w_8 @[MultiEnqueue.scala 154:10]
                        instruction.io.deq.ready <= enqueuer4.io.in.ready @[Decoder.scala 559:25]
                      else :
                        instruction.io.deq.ready <= UInt<1>("h1") @[Decoder.scala 575:25]
        else :
          node _T_12 = eq(instruction.io.deq.bits.opcode, UInt<3>("h4")) @[Decoder.scala 577:38]
          when _T_12 : @[Decoder.scala 577:55]
            wire flags_3 : { _unused : UInt<1>, accumulate : UInt<1>, write : UInt<1>, read : UInt<1>} @[Decoder.scala 578:21]
            wire args_3 : { _unused : UInt<9>, instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, accReadAddress : UInt<24>, accWriteAddress : UInt<16>} @[Decoder.scala 580:11]
            wire _flags_WIRE_6 : { _unused : UInt<1>, accumulate : UInt<1>, write : UInt<1>, read : UInt<1>} @[Decoder.scala 583:45]
            wire _flags_WIRE_7 : UInt<4>
            _flags_WIRE_7 <= instruction.io.deq.bits.flags
            node _flags_T_6 = bits(_flags_WIRE_7, 0, 0) @[Decoder.scala 583:45]
            _flags_WIRE_6.read <= _flags_T_6 @[Decoder.scala 583:45]
            node _flags_T_7 = bits(_flags_WIRE_7, 1, 1) @[Decoder.scala 583:45]
            _flags_WIRE_6.write <= _flags_T_7 @[Decoder.scala 583:45]
            node _flags_T_8 = bits(_flags_WIRE_7, 2, 2) @[Decoder.scala 583:45]
            _flags_WIRE_6.accumulate <= _flags_T_8 @[Decoder.scala 583:45]
            node _flags_T_9 = bits(_flags_WIRE_7, 3, 3) @[Decoder.scala 583:45]
            _flags_WIRE_6._unused <= _flags_T_9 @[Decoder.scala 583:45]
            flags_3 <= _flags_WIRE_6 @[Decoder.scala 583:11]
            wire _args_WIRE_6 : { _unused : UInt<9>, instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, accReadAddress : UInt<24>, accWriteAddress : UInt<16>} @[Decoder.scala 584:48]
            wire _args_WIRE_7 : UInt<56>
            _args_WIRE_7 <= instruction.io.deq.bits.arguments
            node _args_T_15 = bits(_args_WIRE_7, 15, 0) @[Decoder.scala 584:48]
            _args_WIRE_6.accWriteAddress <= _args_T_15 @[Decoder.scala 584:48]
            node _args_T_16 = bits(_args_WIRE_7, 39, 16) @[Decoder.scala 584:48]
            _args_WIRE_6.accReadAddress <= _args_T_16 @[Decoder.scala 584:48]
            node _args_T_17 = bits(_args_WIRE_7, 40, 40) @[Decoder.scala 584:48]
            _args_WIRE_6.instruction.dest <= _args_T_17 @[Decoder.scala 584:48]
            node _args_T_18 = bits(_args_WIRE_7, 41, 41) @[Decoder.scala 584:48]
            _args_WIRE_6.instruction.sourceRight <= _args_T_18 @[Decoder.scala 584:48]
            node _args_T_19 = bits(_args_WIRE_7, 42, 42) @[Decoder.scala 584:48]
            _args_WIRE_6.instruction.sourceLeft <= _args_T_19 @[Decoder.scala 584:48]
            node _args_T_20 = bits(_args_WIRE_7, 46, 43) @[Decoder.scala 584:48]
            _args_WIRE_6.instruction.op <= _args_T_20 @[Decoder.scala 584:48]
            node _args_T_21 = bits(_args_WIRE_7, 55, 47) @[Decoder.scala 584:48]
            _args_WIRE_6._unused <= _args_T_21 @[Decoder.scala 584:48]
            args_3 <= _args_WIRE_6 @[Decoder.scala 584:10]
            wire instruction_io_deq_ready_w_32 : { instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<11>, altAddress : UInt<11>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<11>, stride : UInt<3>, reverse : UInt<1>} @[Decoder.scala 716:17]
            instruction_io_deq_ready_w_32.instruction <= args_3.instruction @[Decoder.scala 717:19]
            instruction_io_deq_ready_w_32.address <= args_3.accReadAddress @[Decoder.scala 718:15]
            instruction_io_deq_ready_w_32.altAddress <= args_3.accWriteAddress @[Decoder.scala 719:18]
            instruction_io_deq_ready_w_32.accumulate <= flags_3.accumulate @[Decoder.scala 720:18]
            instruction_io_deq_ready_w_32.write <= flags_3.write @[Decoder.scala 721:13]
            instruction_io_deq_ready_w_32.read <= flags_3.read @[Decoder.scala 722:12]
            instruction_io_deq_ready_w_32.size <= UInt<1>("h0") @[Decoder.scala 723:12]
            instruction_io_deq_ready_w_32.stride <= UInt<1>("h0") @[Decoder.scala 724:14]
            instruction_io_deq_ready_w_32.reverse <= UInt<1>("h0") @[Decoder.scala 725:15]
            enqueuer1.io.in.valid <= instruction.io.deq.valid @[MultiEnqueue.scala 60:17]
            wire instruction_io_deq_ready_acc_io_enq_w_5 : { flip ready : UInt<1>, valid : UInt<1>, bits : { instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<11>, altAddress : UInt<11>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<11>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
            instruction_io_deq_ready_acc_io_enq_w_5.bits <= instruction_io_deq_ready_w_32 @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_acc_io_enq_w_5.valid <= enqueuer1.io.out[0].valid @[ReadyValid.scala 18:13]
            enqueuer1.io.out[0].ready <= instruction_io_deq_ready_acc_io_enq_w_5.ready @[ReadyValid.scala 19:11]
            acc.io.enq <= instruction_io_deq_ready_acc_io_enq_w_5 @[MultiEnqueue.scala 61:10]
            instruction.io.deq.ready <= enqueuer1.io.in.ready @[Decoder.scala 586:23]
          else :
            node _T_13 = eq(instruction.io.deq.bits.opcode, UInt<4>("hf")) @[Decoder.scala 600:38]
            when _T_13 : @[Decoder.scala 600:60]
              when instruction.io.deq.valid : @[Decoder.scala 601:29]
                wire args_4 : { value : UInt<28>, register : UInt<4>} @[Decoder.scala 603:13]
                wire _args_WIRE_8 : { value : UInt<28>, register : UInt<4>} @[Decoder.scala 610:50]
                wire _args_WIRE_9 : UInt<32>
                _args_WIRE_9 <= instruction.io.deq.bits.arguments
                node _args_T_22 = bits(_args_WIRE_9, 3, 0) @[Decoder.scala 610:50]
                _args_WIRE_8.register <= _args_T_22 @[Decoder.scala 610:50]
                node _args_T_23 = bits(_args_WIRE_9, 31, 4) @[Decoder.scala 610:50]
                _args_WIRE_8.value <= _args_T_23 @[Decoder.scala 610:50]
                args_4 <= _args_WIRE_8 @[Decoder.scala 610:12]
                node _T_14 = eq(args_4.register, UInt<1>("h0")) @[Decoder.scala 612:26]
                when _T_14 : @[Decoder.scala 612:60]
                  node _dram0AddressOffset_T = shl(args_4.value, 16) @[Decoder.scala 613:43]
                  dram0AddressOffset <= _dram0AddressOffset_T @[Decoder.scala 613:28]
                else :
                  node _T_15 = eq(args_4.register, UInt<1>("h1")) @[Decoder.scala 614:32]
                  when _T_15 : @[Decoder.scala 614:67]
                    dram0CacheBehaviour <= args_4.value @[Decoder.scala 615:29]
                  else :
                    node _T_16 = eq(args_4.register, UInt<3>("h4")) @[Decoder.scala 616:32]
                    when _T_16 : @[Decoder.scala 616:66]
                      node _dram1AddressOffset_T = shl(args_4.value, 16) @[Decoder.scala 617:43]
                      dram1AddressOffset <= _dram1AddressOffset_T @[Decoder.scala 617:28]
                    else :
                      node _T_17 = eq(args_4.register, UInt<3>("h5")) @[Decoder.scala 618:32]
                      when _T_17 : @[Decoder.scala 618:67]
                        dram1CacheBehaviour <= args_4.value @[Decoder.scala 619:29]
                      else :
                        node _T_18 = eq(args_4.register, UInt<4>("h8")) @[Decoder.scala 620:32]
                        when _T_18 : @[Decoder.scala 620:55]
                          timeout <= args_4.value @[Decoder.scala 621:17]
                        else :
                          node _T_19 = eq(args_4.register, UInt<4>("h9")) @[Decoder.scala 622:32]
                          when _T_19 : @[Decoder.scala 622:58]
                            tracepoint <= args_4.value @[Decoder.scala 623:20]
                          else :
                            node _T_20 = eq(args_4.register, UInt<4>("ha")) @[Decoder.scala 624:32]
                            when _T_20 : @[Decoder.scala 624:62]
                              programCounter <= args_4.value @[Decoder.scala 625:24]
                            else :
                              node _T_21 = eq(args_4.register, UInt<4>("hb")) @[Decoder.scala 626:32]
                              when _T_21 : @[Decoder.scala 626:62]
                                sampleInterval <= args_4.value @[Decoder.scala 627:24]
              instruction.io.deq.ready <= UInt<1>("h1") @[Decoder.scala 631:23]
            else :
              node _T_22 = eq(instruction.io.deq.bits.opcode, UInt<1>("h0")) @[Decoder.scala 632:38]
              when _T_22 : @[Decoder.scala 632:55]
                instruction.io.deq.ready <= UInt<1>("h1") @[Decoder.scala 633:23]
                io.nooped.valid <= UInt<1>("h1") @[Decoder.scala 634:21]
              else :
                instruction.io.deq.ready <= UInt<1>("h1") @[Decoder.scala 636:23]
                io.skipped.valid <= UInt<1>("h1") @[Decoder.scala 637:22]
    io.error <= UInt<1>("h0") @[Decoder.scala 646:14]
    wire _io_sample_bits_bits_WIRE : { flags : { instruction : { ready : UInt<1>, valid : UInt<1>}, memPortA : { ready : UInt<1>, valid : UInt<1>}, memPortB : { ready : UInt<1>, valid : UInt<1>}, dram0 : { ready : UInt<1>, valid : UInt<1>}, dram1 : { ready : UInt<1>, valid : UInt<1>}, dataflow : { ready : UInt<1>, valid : UInt<1>}, acc : { ready : UInt<1>, valid : UInt<1>}, array : { ready : UInt<1>, valid : UInt<1>}}, programCounter : UInt<32>} @[package.scala 75:57]
    _io_sample_bits_bits_WIRE.programCounter <= UInt<32>("h0") @[package.scala 75:57]
    _io_sample_bits_bits_WIRE.flags.array.valid <= UInt<1>("h0") @[package.scala 75:57]
    _io_sample_bits_bits_WIRE.flags.array.ready <= UInt<1>("h0") @[package.scala 75:57]
    _io_sample_bits_bits_WIRE.flags.acc.valid <= UInt<1>("h0") @[package.scala 75:57]
    _io_sample_bits_bits_WIRE.flags.acc.ready <= UInt<1>("h0") @[package.scala 75:57]
    _io_sample_bits_bits_WIRE.flags.dataflow.valid <= UInt<1>("h0") @[package.scala 75:57]
    _io_sample_bits_bits_WIRE.flags.dataflow.ready <= UInt<1>("h0") @[package.scala 75:57]
    _io_sample_bits_bits_WIRE.flags.dram1.valid <= UInt<1>("h0") @[package.scala 75:57]
    _io_sample_bits_bits_WIRE.flags.dram1.ready <= UInt<1>("h0") @[package.scala 75:57]
    _io_sample_bits_bits_WIRE.flags.dram0.valid <= UInt<1>("h0") @[package.scala 75:57]
    _io_sample_bits_bits_WIRE.flags.dram0.ready <= UInt<1>("h0") @[package.scala 75:57]
    _io_sample_bits_bits_WIRE.flags.memPortB.valid <= UInt<1>("h0") @[package.scala 75:57]
    _io_sample_bits_bits_WIRE.flags.memPortB.ready <= UInt<1>("h0") @[package.scala 75:57]
    _io_sample_bits_bits_WIRE.flags.memPortA.valid <= UInt<1>("h0") @[package.scala 75:57]
    _io_sample_bits_bits_WIRE.flags.memPortA.ready <= UInt<1>("h0") @[package.scala 75:57]
    _io_sample_bits_bits_WIRE.flags.instruction.valid <= UInt<1>("h0") @[package.scala 75:57]
    _io_sample_bits_bits_WIRE.flags.instruction.ready <= UInt<1>("h0") @[package.scala 75:57]
    io.sample.bits.bits <= _io_sample_bits_bits_WIRE @[Decoder.scala 663:25]
    io.sample.bits.last <= UInt<1>("h0") @[Decoder.scala 664:25]
    io.sample.valid <= UInt<1>("h0") @[Decoder.scala 665:21]

  module MAC :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_1 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_2 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_3 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_4 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_5 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_6 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_7 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_8 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_9 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_10 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_11 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_12 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_13 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_14 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_15 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_16 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_17 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_18 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_19 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_20 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_21 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_22 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_23 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_24 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_25 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_26 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_27 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_28 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_29 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_30 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_31 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_32 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_33 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_34 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_35 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_36 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_37 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_38 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_39 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_40 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_41 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_42 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_43 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_44 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_45 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_46 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_47 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_48 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_49 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_50 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_51 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_52 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_53 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_54 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_55 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_56 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_57 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_58 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_59 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_60 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_61 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_62 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module MAC_63 :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}

    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 74:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 74:56]
    reg weight : Fixed<<8>>, clock with :
      reset => (reset, _weight_WIRE) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 74:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 74:56]
    reg passthrough : Fixed<<8>>, clock with :
      reset => (reset, _passthrough_WIRE) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 74:56]
    _output_WIRE <= _output_T_1 @[package.scala 74:56]
    reg output : Fixed<<8>>, clock with :
      reset => (reset, _output_WIRE) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
    else :
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 147:36]
      node _output_T_3 = asSInt(weight) @[package.scala 147:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 147:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 117:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 117:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 117:23]
      node output_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 120:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 120:44]
      node output_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 125:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 125:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 125:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 125:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 125:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 125:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 125:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 125:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 130:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 130:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 130:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 130:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h8000")), output_adjusted) @[package.scala 98:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h7fff")), _output_saturated_T_2) @[package.scala 98:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 133:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]

  module InnerSystolicArray :
    input clock : Clock
    input reset : Reset
    output io : { flip load : UInt<1>, flip input : Fixed<16><<8>>[8], flip weight : Fixed<16><<8>>[8], output : Fixed<16><<8>>[8]}

    inst mac_0_0 of MAC @[InnerSystolicArray.scala 34:50]
    mac_0_0.clock <= clock
    mac_0_0.reset <= reset
    inst mac_0_1 of MAC_1 @[InnerSystolicArray.scala 34:50]
    mac_0_1.clock <= clock
    mac_0_1.reset <= reset
    inst mac_0_2 of MAC_2 @[InnerSystolicArray.scala 34:50]
    mac_0_2.clock <= clock
    mac_0_2.reset <= reset
    inst mac_0_3 of MAC_3 @[InnerSystolicArray.scala 34:50]
    mac_0_3.clock <= clock
    mac_0_3.reset <= reset
    inst mac_0_4 of MAC_4 @[InnerSystolicArray.scala 34:50]
    mac_0_4.clock <= clock
    mac_0_4.reset <= reset
    inst mac_0_5 of MAC_5 @[InnerSystolicArray.scala 34:50]
    mac_0_5.clock <= clock
    mac_0_5.reset <= reset
    inst mac_0_6 of MAC_6 @[InnerSystolicArray.scala 34:50]
    mac_0_6.clock <= clock
    mac_0_6.reset <= reset
    inst mac_0_7 of MAC_7 @[InnerSystolicArray.scala 34:50]
    mac_0_7.clock <= clock
    mac_0_7.reset <= reset
    inst mac_1_0 of MAC_8 @[InnerSystolicArray.scala 34:50]
    mac_1_0.clock <= clock
    mac_1_0.reset <= reset
    inst mac_1_1 of MAC_9 @[InnerSystolicArray.scala 34:50]
    mac_1_1.clock <= clock
    mac_1_1.reset <= reset
    inst mac_1_2 of MAC_10 @[InnerSystolicArray.scala 34:50]
    mac_1_2.clock <= clock
    mac_1_2.reset <= reset
    inst mac_1_3 of MAC_11 @[InnerSystolicArray.scala 34:50]
    mac_1_3.clock <= clock
    mac_1_3.reset <= reset
    inst mac_1_4 of MAC_12 @[InnerSystolicArray.scala 34:50]
    mac_1_4.clock <= clock
    mac_1_4.reset <= reset
    inst mac_1_5 of MAC_13 @[InnerSystolicArray.scala 34:50]
    mac_1_5.clock <= clock
    mac_1_5.reset <= reset
    inst mac_1_6 of MAC_14 @[InnerSystolicArray.scala 34:50]
    mac_1_6.clock <= clock
    mac_1_6.reset <= reset
    inst mac_1_7 of MAC_15 @[InnerSystolicArray.scala 34:50]
    mac_1_7.clock <= clock
    mac_1_7.reset <= reset
    inst mac_2_0 of MAC_16 @[InnerSystolicArray.scala 34:50]
    mac_2_0.clock <= clock
    mac_2_0.reset <= reset
    inst mac_2_1 of MAC_17 @[InnerSystolicArray.scala 34:50]
    mac_2_1.clock <= clock
    mac_2_1.reset <= reset
    inst mac_2_2 of MAC_18 @[InnerSystolicArray.scala 34:50]
    mac_2_2.clock <= clock
    mac_2_2.reset <= reset
    inst mac_2_3 of MAC_19 @[InnerSystolicArray.scala 34:50]
    mac_2_3.clock <= clock
    mac_2_3.reset <= reset
    inst mac_2_4 of MAC_20 @[InnerSystolicArray.scala 34:50]
    mac_2_4.clock <= clock
    mac_2_4.reset <= reset
    inst mac_2_5 of MAC_21 @[InnerSystolicArray.scala 34:50]
    mac_2_5.clock <= clock
    mac_2_5.reset <= reset
    inst mac_2_6 of MAC_22 @[InnerSystolicArray.scala 34:50]
    mac_2_6.clock <= clock
    mac_2_6.reset <= reset
    inst mac_2_7 of MAC_23 @[InnerSystolicArray.scala 34:50]
    mac_2_7.clock <= clock
    mac_2_7.reset <= reset
    inst mac_3_0 of MAC_24 @[InnerSystolicArray.scala 34:50]
    mac_3_0.clock <= clock
    mac_3_0.reset <= reset
    inst mac_3_1 of MAC_25 @[InnerSystolicArray.scala 34:50]
    mac_3_1.clock <= clock
    mac_3_1.reset <= reset
    inst mac_3_2 of MAC_26 @[InnerSystolicArray.scala 34:50]
    mac_3_2.clock <= clock
    mac_3_2.reset <= reset
    inst mac_3_3 of MAC_27 @[InnerSystolicArray.scala 34:50]
    mac_3_3.clock <= clock
    mac_3_3.reset <= reset
    inst mac_3_4 of MAC_28 @[InnerSystolicArray.scala 34:50]
    mac_3_4.clock <= clock
    mac_3_4.reset <= reset
    inst mac_3_5 of MAC_29 @[InnerSystolicArray.scala 34:50]
    mac_3_5.clock <= clock
    mac_3_5.reset <= reset
    inst mac_3_6 of MAC_30 @[InnerSystolicArray.scala 34:50]
    mac_3_6.clock <= clock
    mac_3_6.reset <= reset
    inst mac_3_7 of MAC_31 @[InnerSystolicArray.scala 34:50]
    mac_3_7.clock <= clock
    mac_3_7.reset <= reset
    inst mac_4_0 of MAC_32 @[InnerSystolicArray.scala 34:50]
    mac_4_0.clock <= clock
    mac_4_0.reset <= reset
    inst mac_4_1 of MAC_33 @[InnerSystolicArray.scala 34:50]
    mac_4_1.clock <= clock
    mac_4_1.reset <= reset
    inst mac_4_2 of MAC_34 @[InnerSystolicArray.scala 34:50]
    mac_4_2.clock <= clock
    mac_4_2.reset <= reset
    inst mac_4_3 of MAC_35 @[InnerSystolicArray.scala 34:50]
    mac_4_3.clock <= clock
    mac_4_3.reset <= reset
    inst mac_4_4 of MAC_36 @[InnerSystolicArray.scala 34:50]
    mac_4_4.clock <= clock
    mac_4_4.reset <= reset
    inst mac_4_5 of MAC_37 @[InnerSystolicArray.scala 34:50]
    mac_4_5.clock <= clock
    mac_4_5.reset <= reset
    inst mac_4_6 of MAC_38 @[InnerSystolicArray.scala 34:50]
    mac_4_6.clock <= clock
    mac_4_6.reset <= reset
    inst mac_4_7 of MAC_39 @[InnerSystolicArray.scala 34:50]
    mac_4_7.clock <= clock
    mac_4_7.reset <= reset
    inst mac_5_0 of MAC_40 @[InnerSystolicArray.scala 34:50]
    mac_5_0.clock <= clock
    mac_5_0.reset <= reset
    inst mac_5_1 of MAC_41 @[InnerSystolicArray.scala 34:50]
    mac_5_1.clock <= clock
    mac_5_1.reset <= reset
    inst mac_5_2 of MAC_42 @[InnerSystolicArray.scala 34:50]
    mac_5_2.clock <= clock
    mac_5_2.reset <= reset
    inst mac_5_3 of MAC_43 @[InnerSystolicArray.scala 34:50]
    mac_5_3.clock <= clock
    mac_5_3.reset <= reset
    inst mac_5_4 of MAC_44 @[InnerSystolicArray.scala 34:50]
    mac_5_4.clock <= clock
    mac_5_4.reset <= reset
    inst mac_5_5 of MAC_45 @[InnerSystolicArray.scala 34:50]
    mac_5_5.clock <= clock
    mac_5_5.reset <= reset
    inst mac_5_6 of MAC_46 @[InnerSystolicArray.scala 34:50]
    mac_5_6.clock <= clock
    mac_5_6.reset <= reset
    inst mac_5_7 of MAC_47 @[InnerSystolicArray.scala 34:50]
    mac_5_7.clock <= clock
    mac_5_7.reset <= reset
    inst mac_6_0 of MAC_48 @[InnerSystolicArray.scala 34:50]
    mac_6_0.clock <= clock
    mac_6_0.reset <= reset
    inst mac_6_1 of MAC_49 @[InnerSystolicArray.scala 34:50]
    mac_6_1.clock <= clock
    mac_6_1.reset <= reset
    inst mac_6_2 of MAC_50 @[InnerSystolicArray.scala 34:50]
    mac_6_2.clock <= clock
    mac_6_2.reset <= reset
    inst mac_6_3 of MAC_51 @[InnerSystolicArray.scala 34:50]
    mac_6_3.clock <= clock
    mac_6_3.reset <= reset
    inst mac_6_4 of MAC_52 @[InnerSystolicArray.scala 34:50]
    mac_6_4.clock <= clock
    mac_6_4.reset <= reset
    inst mac_6_5 of MAC_53 @[InnerSystolicArray.scala 34:50]
    mac_6_5.clock <= clock
    mac_6_5.reset <= reset
    inst mac_6_6 of MAC_54 @[InnerSystolicArray.scala 34:50]
    mac_6_6.clock <= clock
    mac_6_6.reset <= reset
    inst mac_6_7 of MAC_55 @[InnerSystolicArray.scala 34:50]
    mac_6_7.clock <= clock
    mac_6_7.reset <= reset
    inst mac_7_0 of MAC_56 @[InnerSystolicArray.scala 34:50]
    mac_7_0.clock <= clock
    mac_7_0.reset <= reset
    inst mac_7_1 of MAC_57 @[InnerSystolicArray.scala 34:50]
    mac_7_1.clock <= clock
    mac_7_1.reset <= reset
    inst mac_7_2 of MAC_58 @[InnerSystolicArray.scala 34:50]
    mac_7_2.clock <= clock
    mac_7_2.reset <= reset
    inst mac_7_3 of MAC_59 @[InnerSystolicArray.scala 34:50]
    mac_7_3.clock <= clock
    mac_7_3.reset <= reset
    inst mac_7_4 of MAC_60 @[InnerSystolicArray.scala 34:50]
    mac_7_4.clock <= clock
    mac_7_4.reset <= reset
    inst mac_7_5 of MAC_61 @[InnerSystolicArray.scala 34:50]
    mac_7_5.clock <= clock
    mac_7_5.reset <= reset
    inst mac_7_6 of MAC_62 @[InnerSystolicArray.scala 34:50]
    mac_7_6.clock <= clock
    mac_7_6.reset <= reset
    inst mac_7_7 of MAC_63 @[InnerSystolicArray.scala 34:50]
    mac_7_7.clock <= clock
    mac_7_7.reset <= reset
    wire _bias_b_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _bias_b_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bias_b_T_1 = asFixedPoint(_bias_b_T, 8) @[package.scala 74:56]
    _bias_b_WIRE <= _bias_b_T_1 @[package.scala 74:56]
    reg bias_0 : Fixed<<8>>, clock with :
      reset => (reset, _bias_b_WIRE) @[InnerSystolicArray.scala 37:20]
    when io.load : @[InnerSystolicArray.scala 38:19]
      bias_0 <= io.weight[0] @[InnerSystolicArray.scala 39:9]
    wire _bias_b_WIRE_1 : Fixed<16><<8>> @[package.scala 74:56]
    node _bias_b_T_2 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bias_b_T_3 = asFixedPoint(_bias_b_T_2, 8) @[package.scala 74:56]
    _bias_b_WIRE_1 <= _bias_b_T_3 @[package.scala 74:56]
    reg bias_1 : Fixed<<8>>, clock with :
      reset => (reset, _bias_b_WIRE_1) @[InnerSystolicArray.scala 37:20]
    when io.load : @[InnerSystolicArray.scala 38:19]
      bias_1 <= io.weight[1] @[InnerSystolicArray.scala 39:9]
    wire _bias_b_WIRE_2 : Fixed<16><<8>> @[package.scala 74:56]
    node _bias_b_T_4 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bias_b_T_5 = asFixedPoint(_bias_b_T_4, 8) @[package.scala 74:56]
    _bias_b_WIRE_2 <= _bias_b_T_5 @[package.scala 74:56]
    reg bias_2 : Fixed<<8>>, clock with :
      reset => (reset, _bias_b_WIRE_2) @[InnerSystolicArray.scala 37:20]
    when io.load : @[InnerSystolicArray.scala 38:19]
      bias_2 <= io.weight[2] @[InnerSystolicArray.scala 39:9]
    wire _bias_b_WIRE_3 : Fixed<16><<8>> @[package.scala 74:56]
    node _bias_b_T_6 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bias_b_T_7 = asFixedPoint(_bias_b_T_6, 8) @[package.scala 74:56]
    _bias_b_WIRE_3 <= _bias_b_T_7 @[package.scala 74:56]
    reg bias_3 : Fixed<<8>>, clock with :
      reset => (reset, _bias_b_WIRE_3) @[InnerSystolicArray.scala 37:20]
    when io.load : @[InnerSystolicArray.scala 38:19]
      bias_3 <= io.weight[3] @[InnerSystolicArray.scala 39:9]
    wire _bias_b_WIRE_4 : Fixed<16><<8>> @[package.scala 74:56]
    node _bias_b_T_8 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bias_b_T_9 = asFixedPoint(_bias_b_T_8, 8) @[package.scala 74:56]
    _bias_b_WIRE_4 <= _bias_b_T_9 @[package.scala 74:56]
    reg bias_4 : Fixed<<8>>, clock with :
      reset => (reset, _bias_b_WIRE_4) @[InnerSystolicArray.scala 37:20]
    when io.load : @[InnerSystolicArray.scala 38:19]
      bias_4 <= io.weight[4] @[InnerSystolicArray.scala 39:9]
    wire _bias_b_WIRE_5 : Fixed<16><<8>> @[package.scala 74:56]
    node _bias_b_T_10 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bias_b_T_11 = asFixedPoint(_bias_b_T_10, 8) @[package.scala 74:56]
    _bias_b_WIRE_5 <= _bias_b_T_11 @[package.scala 74:56]
    reg bias_5 : Fixed<<8>>, clock with :
      reset => (reset, _bias_b_WIRE_5) @[InnerSystolicArray.scala 37:20]
    when io.load : @[InnerSystolicArray.scala 38:19]
      bias_5 <= io.weight[5] @[InnerSystolicArray.scala 39:9]
    wire _bias_b_WIRE_6 : Fixed<16><<8>> @[package.scala 74:56]
    node _bias_b_T_12 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bias_b_T_13 = asFixedPoint(_bias_b_T_12, 8) @[package.scala 74:56]
    _bias_b_WIRE_6 <= _bias_b_T_13 @[package.scala 74:56]
    reg bias_6 : Fixed<<8>>, clock with :
      reset => (reset, _bias_b_WIRE_6) @[InnerSystolicArray.scala 37:20]
    when io.load : @[InnerSystolicArray.scala 38:19]
      bias_6 <= io.weight[6] @[InnerSystolicArray.scala 39:9]
    wire _bias_b_WIRE_7 : Fixed<16><<8>> @[package.scala 74:56]
    node _bias_b_T_14 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bias_b_T_15 = asFixedPoint(_bias_b_T_14, 8) @[package.scala 74:56]
    _bias_b_WIRE_7 <= _bias_b_T_15 @[package.scala 74:56]
    reg bias_7 : Fixed<<8>>, clock with :
      reset => (reset, _bias_b_WIRE_7) @[InnerSystolicArray.scala 37:20]
    when io.load : @[InnerSystolicArray.scala 38:19]
      bias_7 <= io.weight[7] @[InnerSystolicArray.scala 39:9]
    mac_0_0.io.mulInput <= io.input[0] @[InnerSystolicArray.scala 48:27]
    mac_0_0.io.load <= io.load @[InnerSystolicArray.scala 52:23]
    wire _mac_0_1_io_mulInput_sr_WIRE : Fixed<16><<8>>[1] @[package.scala 75:57]
    node _mac_0_1_io_mulInput_sr_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_1_io_mulInput_sr_WIRE[0] <= _mac_0_1_io_mulInput_sr_T @[package.scala 75:57]
    reg mac_0_1_io_mulInput_sr : Fixed<16><<8>>[1], clock with :
      reset => (reset, _mac_0_1_io_mulInput_sr_WIRE) @[ShiftRegister.scala 10:22]
    mac_0_1_io_mulInput_sr[0] <= io.input[1] @[ShiftRegister.scala 25:12]
    mac_0_1.io.mulInput <= mac_0_1_io_mulInput_sr[0] @[InnerSystolicArray.scala 48:27]
    mac_0_1.io.addInput <= mac_0_0.io.output @[InnerSystolicArray.scala 50:29]
    mac_0_1.io.load <= io.load @[InnerSystolicArray.scala 52:23]
    wire _mac_0_2_io_mulInput_sr_WIRE : Fixed<16><<8>>[2] @[package.scala 75:57]
    node _mac_0_2_io_mulInput_sr_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_2_io_mulInput_sr_WIRE[0] <= _mac_0_2_io_mulInput_sr_T @[package.scala 75:57]
    node _mac_0_2_io_mulInput_sr_T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_2_io_mulInput_sr_WIRE[1] <= _mac_0_2_io_mulInput_sr_T_1 @[package.scala 75:57]
    reg mac_0_2_io_mulInput_sr : Fixed<16><<8>>[2], clock with :
      reset => (reset, _mac_0_2_io_mulInput_sr_WIRE) @[ShiftRegister.scala 10:22]
    mac_0_2_io_mulInput_sr[1] <= mac_0_2_io_mulInput_sr[0] @[ShiftRegister.scala 13:11]
    mac_0_2_io_mulInput_sr[0] <= io.input[2] @[ShiftRegister.scala 25:12]
    mac_0_2.io.mulInput <= mac_0_2_io_mulInput_sr[1] @[InnerSystolicArray.scala 48:27]
    mac_0_2.io.addInput <= mac_0_1.io.output @[InnerSystolicArray.scala 50:29]
    mac_0_2.io.load <= io.load @[InnerSystolicArray.scala 52:23]
    wire _mac_0_3_io_mulInput_sr_WIRE : Fixed<16><<8>>[3] @[package.scala 75:57]
    node _mac_0_3_io_mulInput_sr_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_3_io_mulInput_sr_WIRE[0] <= _mac_0_3_io_mulInput_sr_T @[package.scala 75:57]
    node _mac_0_3_io_mulInput_sr_T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_3_io_mulInput_sr_WIRE[1] <= _mac_0_3_io_mulInput_sr_T_1 @[package.scala 75:57]
    node _mac_0_3_io_mulInput_sr_T_2 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_3_io_mulInput_sr_WIRE[2] <= _mac_0_3_io_mulInput_sr_T_2 @[package.scala 75:57]
    reg mac_0_3_io_mulInput_sr : Fixed<16><<8>>[3], clock with :
      reset => (reset, _mac_0_3_io_mulInput_sr_WIRE) @[ShiftRegister.scala 10:22]
    mac_0_3_io_mulInput_sr[1] <= mac_0_3_io_mulInput_sr[0] @[ShiftRegister.scala 13:11]
    mac_0_3_io_mulInput_sr[2] <= mac_0_3_io_mulInput_sr[1] @[ShiftRegister.scala 13:11]
    mac_0_3_io_mulInput_sr[0] <= io.input[3] @[ShiftRegister.scala 25:12]
    mac_0_3.io.mulInput <= mac_0_3_io_mulInput_sr[2] @[InnerSystolicArray.scala 48:27]
    mac_0_3.io.addInput <= mac_0_2.io.output @[InnerSystolicArray.scala 50:29]
    mac_0_3.io.load <= io.load @[InnerSystolicArray.scala 52:23]
    wire _mac_0_4_io_mulInput_sr_WIRE : Fixed<16><<8>>[4] @[package.scala 75:57]
    node _mac_0_4_io_mulInput_sr_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_4_io_mulInput_sr_WIRE[0] <= _mac_0_4_io_mulInput_sr_T @[package.scala 75:57]
    node _mac_0_4_io_mulInput_sr_T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_4_io_mulInput_sr_WIRE[1] <= _mac_0_4_io_mulInput_sr_T_1 @[package.scala 75:57]
    node _mac_0_4_io_mulInput_sr_T_2 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_4_io_mulInput_sr_WIRE[2] <= _mac_0_4_io_mulInput_sr_T_2 @[package.scala 75:57]
    node _mac_0_4_io_mulInput_sr_T_3 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_4_io_mulInput_sr_WIRE[3] <= _mac_0_4_io_mulInput_sr_T_3 @[package.scala 75:57]
    reg mac_0_4_io_mulInput_sr : Fixed<16><<8>>[4], clock with :
      reset => (reset, _mac_0_4_io_mulInput_sr_WIRE) @[ShiftRegister.scala 10:22]
    mac_0_4_io_mulInput_sr[1] <= mac_0_4_io_mulInput_sr[0] @[ShiftRegister.scala 13:11]
    mac_0_4_io_mulInput_sr[2] <= mac_0_4_io_mulInput_sr[1] @[ShiftRegister.scala 13:11]
    mac_0_4_io_mulInput_sr[3] <= mac_0_4_io_mulInput_sr[2] @[ShiftRegister.scala 13:11]
    mac_0_4_io_mulInput_sr[0] <= io.input[4] @[ShiftRegister.scala 25:12]
    mac_0_4.io.mulInput <= mac_0_4_io_mulInput_sr[3] @[InnerSystolicArray.scala 48:27]
    mac_0_4.io.addInput <= mac_0_3.io.output @[InnerSystolicArray.scala 50:29]
    mac_0_4.io.load <= io.load @[InnerSystolicArray.scala 52:23]
    wire _mac_0_5_io_mulInput_sr_WIRE : Fixed<16><<8>>[5] @[package.scala 75:57]
    node _mac_0_5_io_mulInput_sr_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_5_io_mulInput_sr_WIRE[0] <= _mac_0_5_io_mulInput_sr_T @[package.scala 75:57]
    node _mac_0_5_io_mulInput_sr_T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_5_io_mulInput_sr_WIRE[1] <= _mac_0_5_io_mulInput_sr_T_1 @[package.scala 75:57]
    node _mac_0_5_io_mulInput_sr_T_2 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_5_io_mulInput_sr_WIRE[2] <= _mac_0_5_io_mulInput_sr_T_2 @[package.scala 75:57]
    node _mac_0_5_io_mulInput_sr_T_3 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_5_io_mulInput_sr_WIRE[3] <= _mac_0_5_io_mulInput_sr_T_3 @[package.scala 75:57]
    node _mac_0_5_io_mulInput_sr_T_4 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_5_io_mulInput_sr_WIRE[4] <= _mac_0_5_io_mulInput_sr_T_4 @[package.scala 75:57]
    reg mac_0_5_io_mulInput_sr : Fixed<16><<8>>[5], clock with :
      reset => (reset, _mac_0_5_io_mulInput_sr_WIRE) @[ShiftRegister.scala 10:22]
    mac_0_5_io_mulInput_sr[1] <= mac_0_5_io_mulInput_sr[0] @[ShiftRegister.scala 13:11]
    mac_0_5_io_mulInput_sr[2] <= mac_0_5_io_mulInput_sr[1] @[ShiftRegister.scala 13:11]
    mac_0_5_io_mulInput_sr[3] <= mac_0_5_io_mulInput_sr[2] @[ShiftRegister.scala 13:11]
    mac_0_5_io_mulInput_sr[4] <= mac_0_5_io_mulInput_sr[3] @[ShiftRegister.scala 13:11]
    mac_0_5_io_mulInput_sr[0] <= io.input[5] @[ShiftRegister.scala 25:12]
    mac_0_5.io.mulInput <= mac_0_5_io_mulInput_sr[4] @[InnerSystolicArray.scala 48:27]
    mac_0_5.io.addInput <= mac_0_4.io.output @[InnerSystolicArray.scala 50:29]
    mac_0_5.io.load <= io.load @[InnerSystolicArray.scala 52:23]
    wire _mac_0_6_io_mulInput_sr_WIRE : Fixed<16><<8>>[6] @[package.scala 75:57]
    node _mac_0_6_io_mulInput_sr_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_6_io_mulInput_sr_WIRE[0] <= _mac_0_6_io_mulInput_sr_T @[package.scala 75:57]
    node _mac_0_6_io_mulInput_sr_T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_6_io_mulInput_sr_WIRE[1] <= _mac_0_6_io_mulInput_sr_T_1 @[package.scala 75:57]
    node _mac_0_6_io_mulInput_sr_T_2 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_6_io_mulInput_sr_WIRE[2] <= _mac_0_6_io_mulInput_sr_T_2 @[package.scala 75:57]
    node _mac_0_6_io_mulInput_sr_T_3 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_6_io_mulInput_sr_WIRE[3] <= _mac_0_6_io_mulInput_sr_T_3 @[package.scala 75:57]
    node _mac_0_6_io_mulInput_sr_T_4 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_6_io_mulInput_sr_WIRE[4] <= _mac_0_6_io_mulInput_sr_T_4 @[package.scala 75:57]
    node _mac_0_6_io_mulInput_sr_T_5 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_6_io_mulInput_sr_WIRE[5] <= _mac_0_6_io_mulInput_sr_T_5 @[package.scala 75:57]
    reg mac_0_6_io_mulInput_sr : Fixed<16><<8>>[6], clock with :
      reset => (reset, _mac_0_6_io_mulInput_sr_WIRE) @[ShiftRegister.scala 10:22]
    mac_0_6_io_mulInput_sr[1] <= mac_0_6_io_mulInput_sr[0] @[ShiftRegister.scala 13:11]
    mac_0_6_io_mulInput_sr[2] <= mac_0_6_io_mulInput_sr[1] @[ShiftRegister.scala 13:11]
    mac_0_6_io_mulInput_sr[3] <= mac_0_6_io_mulInput_sr[2] @[ShiftRegister.scala 13:11]
    mac_0_6_io_mulInput_sr[4] <= mac_0_6_io_mulInput_sr[3] @[ShiftRegister.scala 13:11]
    mac_0_6_io_mulInput_sr[5] <= mac_0_6_io_mulInput_sr[4] @[ShiftRegister.scala 13:11]
    mac_0_6_io_mulInput_sr[0] <= io.input[6] @[ShiftRegister.scala 25:12]
    mac_0_6.io.mulInput <= mac_0_6_io_mulInput_sr[5] @[InnerSystolicArray.scala 48:27]
    mac_0_6.io.addInput <= mac_0_5.io.output @[InnerSystolicArray.scala 50:29]
    mac_0_6.io.load <= io.load @[InnerSystolicArray.scala 52:23]
    wire _mac_0_7_io_mulInput_sr_WIRE : Fixed<16><<8>>[7] @[package.scala 75:57]
    node _mac_0_7_io_mulInput_sr_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_7_io_mulInput_sr_WIRE[0] <= _mac_0_7_io_mulInput_sr_T @[package.scala 75:57]
    node _mac_0_7_io_mulInput_sr_T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_7_io_mulInput_sr_WIRE[1] <= _mac_0_7_io_mulInput_sr_T_1 @[package.scala 75:57]
    node _mac_0_7_io_mulInput_sr_T_2 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_7_io_mulInput_sr_WIRE[2] <= _mac_0_7_io_mulInput_sr_T_2 @[package.scala 75:57]
    node _mac_0_7_io_mulInput_sr_T_3 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_7_io_mulInput_sr_WIRE[3] <= _mac_0_7_io_mulInput_sr_T_3 @[package.scala 75:57]
    node _mac_0_7_io_mulInput_sr_T_4 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_7_io_mulInput_sr_WIRE[4] <= _mac_0_7_io_mulInput_sr_T_4 @[package.scala 75:57]
    node _mac_0_7_io_mulInput_sr_T_5 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_7_io_mulInput_sr_WIRE[5] <= _mac_0_7_io_mulInput_sr_T_5 @[package.scala 75:57]
    node _mac_0_7_io_mulInput_sr_T_6 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _mac_0_7_io_mulInput_sr_WIRE[6] <= _mac_0_7_io_mulInput_sr_T_6 @[package.scala 75:57]
    reg mac_0_7_io_mulInput_sr : Fixed<16><<8>>[7], clock with :
      reset => (reset, _mac_0_7_io_mulInput_sr_WIRE) @[ShiftRegister.scala 10:22]
    mac_0_7_io_mulInput_sr[1] <= mac_0_7_io_mulInput_sr[0] @[ShiftRegister.scala 13:11]
    mac_0_7_io_mulInput_sr[2] <= mac_0_7_io_mulInput_sr[1] @[ShiftRegister.scala 13:11]
    mac_0_7_io_mulInput_sr[3] <= mac_0_7_io_mulInput_sr[2] @[ShiftRegister.scala 13:11]
    mac_0_7_io_mulInput_sr[4] <= mac_0_7_io_mulInput_sr[3] @[ShiftRegister.scala 13:11]
    mac_0_7_io_mulInput_sr[5] <= mac_0_7_io_mulInput_sr[4] @[ShiftRegister.scala 13:11]
    mac_0_7_io_mulInput_sr[6] <= mac_0_7_io_mulInput_sr[5] @[ShiftRegister.scala 13:11]
    mac_0_7_io_mulInput_sr[0] <= io.input[7] @[ShiftRegister.scala 25:12]
    mac_0_7.io.mulInput <= mac_0_7_io_mulInput_sr[6] @[InnerSystolicArray.scala 48:27]
    mac_0_7.io.addInput <= mac_0_6.io.output @[InnerSystolicArray.scala 50:29]
    mac_0_7.io.load <= io.load @[InnerSystolicArray.scala 52:23]
    mac_0_0.io.addInput <= bias_0 @[InnerSystolicArray.scala 57:27]
    mac_1_0.io.addInput <= bias_1 @[InnerSystolicArray.scala 57:27]
    mac_1_0.io.mulInput <= mac_0_0.io.passthrough @[InnerSystolicArray.scala 59:29]
    mac_1_0.io.load <= io.load @[InnerSystolicArray.scala 60:25]
    mac_2_0.io.addInput <= bias_2 @[InnerSystolicArray.scala 57:27]
    mac_2_0.io.mulInput <= mac_1_0.io.passthrough @[InnerSystolicArray.scala 59:29]
    mac_2_0.io.load <= io.load @[InnerSystolicArray.scala 60:25]
    mac_3_0.io.addInput <= bias_3 @[InnerSystolicArray.scala 57:27]
    mac_3_0.io.mulInput <= mac_2_0.io.passthrough @[InnerSystolicArray.scala 59:29]
    mac_3_0.io.load <= io.load @[InnerSystolicArray.scala 60:25]
    mac_4_0.io.addInput <= bias_4 @[InnerSystolicArray.scala 57:27]
    mac_4_0.io.mulInput <= mac_3_0.io.passthrough @[InnerSystolicArray.scala 59:29]
    mac_4_0.io.load <= io.load @[InnerSystolicArray.scala 60:25]
    mac_5_0.io.addInput <= bias_5 @[InnerSystolicArray.scala 57:27]
    mac_5_0.io.mulInput <= mac_4_0.io.passthrough @[InnerSystolicArray.scala 59:29]
    mac_5_0.io.load <= io.load @[InnerSystolicArray.scala 60:25]
    mac_6_0.io.addInput <= bias_6 @[InnerSystolicArray.scala 57:27]
    mac_6_0.io.mulInput <= mac_5_0.io.passthrough @[InnerSystolicArray.scala 59:29]
    mac_6_0.io.load <= io.load @[InnerSystolicArray.scala 60:25]
    mac_7_0.io.addInput <= bias_7 @[InnerSystolicArray.scala 57:27]
    mac_7_0.io.mulInput <= mac_6_0.io.passthrough @[InnerSystolicArray.scala 59:29]
    mac_7_0.io.load <= io.load @[InnerSystolicArray.scala 60:25]
    mac_1_1.io.mulInput <= mac_0_1.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_1_1.io.addInput <= mac_1_0.io.output @[InnerSystolicArray.scala 68:29]
    mac_1_1.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_1_2.io.mulInput <= mac_0_2.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_1_2.io.addInput <= mac_1_1.io.output @[InnerSystolicArray.scala 68:29]
    mac_1_2.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_1_3.io.mulInput <= mac_0_3.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_1_3.io.addInput <= mac_1_2.io.output @[InnerSystolicArray.scala 68:29]
    mac_1_3.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_1_4.io.mulInput <= mac_0_4.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_1_4.io.addInput <= mac_1_3.io.output @[InnerSystolicArray.scala 68:29]
    mac_1_4.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_1_5.io.mulInput <= mac_0_5.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_1_5.io.addInput <= mac_1_4.io.output @[InnerSystolicArray.scala 68:29]
    mac_1_5.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_1_6.io.mulInput <= mac_0_6.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_1_6.io.addInput <= mac_1_5.io.output @[InnerSystolicArray.scala 68:29]
    mac_1_6.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_1_7.io.mulInput <= mac_0_7.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_1_7.io.addInput <= mac_1_6.io.output @[InnerSystolicArray.scala 68:29]
    mac_1_7.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_2_1.io.mulInput <= mac_1_1.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_2_1.io.addInput <= mac_2_0.io.output @[InnerSystolicArray.scala 68:29]
    mac_2_1.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_2_2.io.mulInput <= mac_1_2.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_2_2.io.addInput <= mac_2_1.io.output @[InnerSystolicArray.scala 68:29]
    mac_2_2.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_2_3.io.mulInput <= mac_1_3.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_2_3.io.addInput <= mac_2_2.io.output @[InnerSystolicArray.scala 68:29]
    mac_2_3.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_2_4.io.mulInput <= mac_1_4.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_2_4.io.addInput <= mac_2_3.io.output @[InnerSystolicArray.scala 68:29]
    mac_2_4.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_2_5.io.mulInput <= mac_1_5.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_2_5.io.addInput <= mac_2_4.io.output @[InnerSystolicArray.scala 68:29]
    mac_2_5.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_2_6.io.mulInput <= mac_1_6.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_2_6.io.addInput <= mac_2_5.io.output @[InnerSystolicArray.scala 68:29]
    mac_2_6.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_2_7.io.mulInput <= mac_1_7.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_2_7.io.addInput <= mac_2_6.io.output @[InnerSystolicArray.scala 68:29]
    mac_2_7.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_3_1.io.mulInput <= mac_2_1.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_3_1.io.addInput <= mac_3_0.io.output @[InnerSystolicArray.scala 68:29]
    mac_3_1.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_3_2.io.mulInput <= mac_2_2.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_3_2.io.addInput <= mac_3_1.io.output @[InnerSystolicArray.scala 68:29]
    mac_3_2.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_3_3.io.mulInput <= mac_2_3.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_3_3.io.addInput <= mac_3_2.io.output @[InnerSystolicArray.scala 68:29]
    mac_3_3.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_3_4.io.mulInput <= mac_2_4.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_3_4.io.addInput <= mac_3_3.io.output @[InnerSystolicArray.scala 68:29]
    mac_3_4.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_3_5.io.mulInput <= mac_2_5.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_3_5.io.addInput <= mac_3_4.io.output @[InnerSystolicArray.scala 68:29]
    mac_3_5.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_3_6.io.mulInput <= mac_2_6.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_3_6.io.addInput <= mac_3_5.io.output @[InnerSystolicArray.scala 68:29]
    mac_3_6.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_3_7.io.mulInput <= mac_2_7.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_3_7.io.addInput <= mac_3_6.io.output @[InnerSystolicArray.scala 68:29]
    mac_3_7.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_4_1.io.mulInput <= mac_3_1.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_4_1.io.addInput <= mac_4_0.io.output @[InnerSystolicArray.scala 68:29]
    mac_4_1.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_4_2.io.mulInput <= mac_3_2.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_4_2.io.addInput <= mac_4_1.io.output @[InnerSystolicArray.scala 68:29]
    mac_4_2.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_4_3.io.mulInput <= mac_3_3.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_4_3.io.addInput <= mac_4_2.io.output @[InnerSystolicArray.scala 68:29]
    mac_4_3.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_4_4.io.mulInput <= mac_3_4.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_4_4.io.addInput <= mac_4_3.io.output @[InnerSystolicArray.scala 68:29]
    mac_4_4.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_4_5.io.mulInput <= mac_3_5.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_4_5.io.addInput <= mac_4_4.io.output @[InnerSystolicArray.scala 68:29]
    mac_4_5.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_4_6.io.mulInput <= mac_3_6.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_4_6.io.addInput <= mac_4_5.io.output @[InnerSystolicArray.scala 68:29]
    mac_4_6.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_4_7.io.mulInput <= mac_3_7.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_4_7.io.addInput <= mac_4_6.io.output @[InnerSystolicArray.scala 68:29]
    mac_4_7.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_5_1.io.mulInput <= mac_4_1.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_5_1.io.addInput <= mac_5_0.io.output @[InnerSystolicArray.scala 68:29]
    mac_5_1.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_5_2.io.mulInput <= mac_4_2.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_5_2.io.addInput <= mac_5_1.io.output @[InnerSystolicArray.scala 68:29]
    mac_5_2.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_5_3.io.mulInput <= mac_4_3.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_5_3.io.addInput <= mac_5_2.io.output @[InnerSystolicArray.scala 68:29]
    mac_5_3.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_5_4.io.mulInput <= mac_4_4.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_5_4.io.addInput <= mac_5_3.io.output @[InnerSystolicArray.scala 68:29]
    mac_5_4.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_5_5.io.mulInput <= mac_4_5.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_5_5.io.addInput <= mac_5_4.io.output @[InnerSystolicArray.scala 68:29]
    mac_5_5.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_5_6.io.mulInput <= mac_4_6.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_5_6.io.addInput <= mac_5_5.io.output @[InnerSystolicArray.scala 68:29]
    mac_5_6.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_5_7.io.mulInput <= mac_4_7.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_5_7.io.addInput <= mac_5_6.io.output @[InnerSystolicArray.scala 68:29]
    mac_5_7.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_6_1.io.mulInput <= mac_5_1.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_6_1.io.addInput <= mac_6_0.io.output @[InnerSystolicArray.scala 68:29]
    mac_6_1.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_6_2.io.mulInput <= mac_5_2.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_6_2.io.addInput <= mac_6_1.io.output @[InnerSystolicArray.scala 68:29]
    mac_6_2.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_6_3.io.mulInput <= mac_5_3.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_6_3.io.addInput <= mac_6_2.io.output @[InnerSystolicArray.scala 68:29]
    mac_6_3.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_6_4.io.mulInput <= mac_5_4.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_6_4.io.addInput <= mac_6_3.io.output @[InnerSystolicArray.scala 68:29]
    mac_6_4.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_6_5.io.mulInput <= mac_5_5.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_6_5.io.addInput <= mac_6_4.io.output @[InnerSystolicArray.scala 68:29]
    mac_6_5.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_6_6.io.mulInput <= mac_5_6.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_6_6.io.addInput <= mac_6_5.io.output @[InnerSystolicArray.scala 68:29]
    mac_6_6.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_6_7.io.mulInput <= mac_5_7.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_6_7.io.addInput <= mac_6_6.io.output @[InnerSystolicArray.scala 68:29]
    mac_6_7.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_7_1.io.mulInput <= mac_6_1.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_7_1.io.addInput <= mac_7_0.io.output @[InnerSystolicArray.scala 68:29]
    mac_7_1.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_7_2.io.mulInput <= mac_6_2.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_7_2.io.addInput <= mac_7_1.io.output @[InnerSystolicArray.scala 68:29]
    mac_7_2.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_7_3.io.mulInput <= mac_6_3.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_7_3.io.addInput <= mac_7_2.io.output @[InnerSystolicArray.scala 68:29]
    mac_7_3.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_7_4.io.mulInput <= mac_6_4.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_7_4.io.addInput <= mac_7_3.io.output @[InnerSystolicArray.scala 68:29]
    mac_7_4.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_7_5.io.mulInput <= mac_6_5.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_7_5.io.addInput <= mac_7_4.io.output @[InnerSystolicArray.scala 68:29]
    mac_7_5.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_7_6.io.mulInput <= mac_6_6.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_7_6.io.addInput <= mac_7_5.io.output @[InnerSystolicArray.scala 68:29]
    mac_7_6.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_7_7.io.mulInput <= mac_6_7.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_7_7.io.addInput <= mac_7_6.io.output @[InnerSystolicArray.scala 68:29]
    mac_7_7.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    wire _io_output_0_sr_WIRE : Fixed<16><<8>>[7] @[package.scala 75:57]
    node _io_output_0_sr_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_0_sr_WIRE[0] <= _io_output_0_sr_T @[package.scala 75:57]
    node _io_output_0_sr_T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_0_sr_WIRE[1] <= _io_output_0_sr_T_1 @[package.scala 75:57]
    node _io_output_0_sr_T_2 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_0_sr_WIRE[2] <= _io_output_0_sr_T_2 @[package.scala 75:57]
    node _io_output_0_sr_T_3 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_0_sr_WIRE[3] <= _io_output_0_sr_T_3 @[package.scala 75:57]
    node _io_output_0_sr_T_4 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_0_sr_WIRE[4] <= _io_output_0_sr_T_4 @[package.scala 75:57]
    node _io_output_0_sr_T_5 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_0_sr_WIRE[5] <= _io_output_0_sr_T_5 @[package.scala 75:57]
    node _io_output_0_sr_T_6 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_0_sr_WIRE[6] <= _io_output_0_sr_T_6 @[package.scala 75:57]
    reg io_output_0_sr : Fixed<16><<8>>[7], clock with :
      reset => (reset, _io_output_0_sr_WIRE) @[ShiftRegister.scala 10:22]
    io_output_0_sr[1] <= io_output_0_sr[0] @[ShiftRegister.scala 13:11]
    io_output_0_sr[2] <= io_output_0_sr[1] @[ShiftRegister.scala 13:11]
    io_output_0_sr[3] <= io_output_0_sr[2] @[ShiftRegister.scala 13:11]
    io_output_0_sr[4] <= io_output_0_sr[3] @[ShiftRegister.scala 13:11]
    io_output_0_sr[5] <= io_output_0_sr[4] @[ShiftRegister.scala 13:11]
    io_output_0_sr[6] <= io_output_0_sr[5] @[ShiftRegister.scala 13:11]
    io_output_0_sr[0] <= mac_0_7.io.output @[ShiftRegister.scala 25:12]
    io.output[0] <= io_output_0_sr[6] @[InnerSystolicArray.scala 75:18]
    wire _io_output_1_sr_WIRE : Fixed<16><<8>>[6] @[package.scala 75:57]
    node _io_output_1_sr_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_1_sr_WIRE[0] <= _io_output_1_sr_T @[package.scala 75:57]
    node _io_output_1_sr_T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_1_sr_WIRE[1] <= _io_output_1_sr_T_1 @[package.scala 75:57]
    node _io_output_1_sr_T_2 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_1_sr_WIRE[2] <= _io_output_1_sr_T_2 @[package.scala 75:57]
    node _io_output_1_sr_T_3 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_1_sr_WIRE[3] <= _io_output_1_sr_T_3 @[package.scala 75:57]
    node _io_output_1_sr_T_4 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_1_sr_WIRE[4] <= _io_output_1_sr_T_4 @[package.scala 75:57]
    node _io_output_1_sr_T_5 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_1_sr_WIRE[5] <= _io_output_1_sr_T_5 @[package.scala 75:57]
    reg io_output_1_sr : Fixed<16><<8>>[6], clock with :
      reset => (reset, _io_output_1_sr_WIRE) @[ShiftRegister.scala 10:22]
    io_output_1_sr[1] <= io_output_1_sr[0] @[ShiftRegister.scala 13:11]
    io_output_1_sr[2] <= io_output_1_sr[1] @[ShiftRegister.scala 13:11]
    io_output_1_sr[3] <= io_output_1_sr[2] @[ShiftRegister.scala 13:11]
    io_output_1_sr[4] <= io_output_1_sr[3] @[ShiftRegister.scala 13:11]
    io_output_1_sr[5] <= io_output_1_sr[4] @[ShiftRegister.scala 13:11]
    io_output_1_sr[0] <= mac_1_7.io.output @[ShiftRegister.scala 25:12]
    io.output[1] <= io_output_1_sr[5] @[InnerSystolicArray.scala 75:18]
    wire _io_output_2_sr_WIRE : Fixed<16><<8>>[5] @[package.scala 75:57]
    node _io_output_2_sr_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_2_sr_WIRE[0] <= _io_output_2_sr_T @[package.scala 75:57]
    node _io_output_2_sr_T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_2_sr_WIRE[1] <= _io_output_2_sr_T_1 @[package.scala 75:57]
    node _io_output_2_sr_T_2 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_2_sr_WIRE[2] <= _io_output_2_sr_T_2 @[package.scala 75:57]
    node _io_output_2_sr_T_3 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_2_sr_WIRE[3] <= _io_output_2_sr_T_3 @[package.scala 75:57]
    node _io_output_2_sr_T_4 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_2_sr_WIRE[4] <= _io_output_2_sr_T_4 @[package.scala 75:57]
    reg io_output_2_sr : Fixed<16><<8>>[5], clock with :
      reset => (reset, _io_output_2_sr_WIRE) @[ShiftRegister.scala 10:22]
    io_output_2_sr[1] <= io_output_2_sr[0] @[ShiftRegister.scala 13:11]
    io_output_2_sr[2] <= io_output_2_sr[1] @[ShiftRegister.scala 13:11]
    io_output_2_sr[3] <= io_output_2_sr[2] @[ShiftRegister.scala 13:11]
    io_output_2_sr[4] <= io_output_2_sr[3] @[ShiftRegister.scala 13:11]
    io_output_2_sr[0] <= mac_2_7.io.output @[ShiftRegister.scala 25:12]
    io.output[2] <= io_output_2_sr[4] @[InnerSystolicArray.scala 75:18]
    wire _io_output_3_sr_WIRE : Fixed<16><<8>>[4] @[package.scala 75:57]
    node _io_output_3_sr_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_3_sr_WIRE[0] <= _io_output_3_sr_T @[package.scala 75:57]
    node _io_output_3_sr_T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_3_sr_WIRE[1] <= _io_output_3_sr_T_1 @[package.scala 75:57]
    node _io_output_3_sr_T_2 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_3_sr_WIRE[2] <= _io_output_3_sr_T_2 @[package.scala 75:57]
    node _io_output_3_sr_T_3 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_3_sr_WIRE[3] <= _io_output_3_sr_T_3 @[package.scala 75:57]
    reg io_output_3_sr : Fixed<16><<8>>[4], clock with :
      reset => (reset, _io_output_3_sr_WIRE) @[ShiftRegister.scala 10:22]
    io_output_3_sr[1] <= io_output_3_sr[0] @[ShiftRegister.scala 13:11]
    io_output_3_sr[2] <= io_output_3_sr[1] @[ShiftRegister.scala 13:11]
    io_output_3_sr[3] <= io_output_3_sr[2] @[ShiftRegister.scala 13:11]
    io_output_3_sr[0] <= mac_3_7.io.output @[ShiftRegister.scala 25:12]
    io.output[3] <= io_output_3_sr[3] @[InnerSystolicArray.scala 75:18]
    wire _io_output_4_sr_WIRE : Fixed<16><<8>>[3] @[package.scala 75:57]
    node _io_output_4_sr_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_4_sr_WIRE[0] <= _io_output_4_sr_T @[package.scala 75:57]
    node _io_output_4_sr_T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_4_sr_WIRE[1] <= _io_output_4_sr_T_1 @[package.scala 75:57]
    node _io_output_4_sr_T_2 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_4_sr_WIRE[2] <= _io_output_4_sr_T_2 @[package.scala 75:57]
    reg io_output_4_sr : Fixed<16><<8>>[3], clock with :
      reset => (reset, _io_output_4_sr_WIRE) @[ShiftRegister.scala 10:22]
    io_output_4_sr[1] <= io_output_4_sr[0] @[ShiftRegister.scala 13:11]
    io_output_4_sr[2] <= io_output_4_sr[1] @[ShiftRegister.scala 13:11]
    io_output_4_sr[0] <= mac_4_7.io.output @[ShiftRegister.scala 25:12]
    io.output[4] <= io_output_4_sr[2] @[InnerSystolicArray.scala 75:18]
    wire _io_output_5_sr_WIRE : Fixed<16><<8>>[2] @[package.scala 75:57]
    node _io_output_5_sr_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_5_sr_WIRE[0] <= _io_output_5_sr_T @[package.scala 75:57]
    node _io_output_5_sr_T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_5_sr_WIRE[1] <= _io_output_5_sr_T_1 @[package.scala 75:57]
    reg io_output_5_sr : Fixed<16><<8>>[2], clock with :
      reset => (reset, _io_output_5_sr_WIRE) @[ShiftRegister.scala 10:22]
    io_output_5_sr[1] <= io_output_5_sr[0] @[ShiftRegister.scala 13:11]
    io_output_5_sr[0] <= mac_5_7.io.output @[ShiftRegister.scala 25:12]
    io.output[5] <= io_output_5_sr[1] @[InnerSystolicArray.scala 75:18]
    wire _io_output_6_sr_WIRE : Fixed<16><<8>>[1] @[package.scala 75:57]
    node _io_output_6_sr_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_output_6_sr_WIRE[0] <= _io_output_6_sr_T @[package.scala 75:57]
    reg io_output_6_sr : Fixed<16><<8>>[1], clock with :
      reset => (reset, _io_output_6_sr_WIRE) @[ShiftRegister.scala 10:22]
    io_output_6_sr[0] <= mac_6_7.io.output @[ShiftRegister.scala 25:12]
    io.output[6] <= io_output_6_sr[0] @[InnerSystolicArray.scala 75:18]
    io.output[7] <= mac_7_7.io.output @[InnerSystolicArray.scala 75:18]

  module Queue_8 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, count : UInt<4>}

    cmem ram : Fixed<16><<8>>[8] [15] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<4>, clock with :
      reset => (reset, UInt<4>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<4>, clock with :
      reset => (reset, UInt<4>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<4>("he")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
      when wrap : @[Counter.scala 88:20]
        enq_ptr_value <= UInt<1>("h0") @[Counter.scala 88:28]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<4>("he")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
      when wrap_1 : @[Counter.scala 88:20]
        deq_ptr_value <= UInt<1>("h0") @[Counter.scala 88:28]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = mux(maybe_full, UInt<4>("hf"), UInt<1>("h0")) @[Decoupled.scala 319:10]
    node _io_count_T_1 = gt(deq_ptr_value, enq_ptr_value) @[Decoupled.scala 320:25]
    node _io_count_T_2 = add(UInt<4>("hf"), ptr_diff) @[Decoupled.scala 320:57]
    node _io_count_T_3 = tail(_io_count_T_2, 1) @[Decoupled.scala 320:57]
    node _io_count_T_4 = mux(_io_count_T_1, _io_count_T_3, ptr_diff) @[Decoupled.scala 320:10]
    node _io_count_T_5 = mux(ptr_match, _io_count_T, _io_count_T_4) @[Decoupled.scala 317:20]
    io.count <= _io_count_T_5 @[Decoupled.scala 317:14]

  module Queue_9 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { zeroes : UInt<1>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { zeroes : UInt<1>}}, count : UInt<5>}

    cmem ram : { zeroes : UInt<1>} [16] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<4>, clock with :
      reset => (reset, UInt<4>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<4>, clock with :
      reset => (reset, UInt<4>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<4>("hf")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<4>("hf")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<5>("h10"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module SystolicArray :
    input clock : Clock
    input reset : Reset
    output io : { flip control : { flip ready : UInt<1>, valid : UInt<1>, bits : { load : UInt<1>, zeroes : UInt<1>}}, flip input : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip weight : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, output : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, ran : { flip ready : UInt<1>, valid : UInt<1>, bits : { zeroes : UInt<1>}}, loaded : { flip ready : UInt<1>, valid : UInt<1>, bits : { zeroes : UInt<1>}}}

    inst array of InnerSystolicArray @[SystolicArray.scala 40:37]
    array.clock <= clock
    array.reset <= reset
    inst output of Queue_8 @[SystolicArray.scala 45:22]
    output.clock <= clock
    output.reset <= reset
    io.loaded.bits.zeroes <= io.control.bits.zeroes @[SystolicArray.scala 52:25]
    io.loaded.valid <= array.io.load @[SystolicArray.scala 53:19]
    inst ran of Queue_9 @[SystolicArray.scala 54:19]
    ran.clock <= clock
    ran.reset <= reset
    ran.io.enq.bits.zeroes <= io.control.bits.zeroes @[SystolicArray.scala 57:26]
    io.ran.bits <= ran.io.deq.bits @[SystolicArray.scala 58:15]
    io.ran.valid <= ran.io.deq.valid @[SystolicArray.scala 59:16]
    node _ran_io_deq_ready_T = and(io.ran.ready, output.io.deq.valid) @[SystolicArray.scala 60:36]
    ran.io.deq.ready <= _ran_io_deq_ready_T @[SystolicArray.scala 60:20]
    node _runInput_T = eq(io.control.bits.load, UInt<1>("h0")) @[SystolicArray.scala 62:36]
    node _runInput_T_1 = and(io.control.valid, _runInput_T) @[SystolicArray.scala 62:33]
    node _runInput_T_2 = eq(io.control.bits.zeroes, UInt<1>("h0")) @[SystolicArray.scala 62:58]
    node runInput = and(_runInput_T_1, _runInput_T_2) @[SystolicArray.scala 62:55]
    node _runZeroes_T = eq(io.control.bits.load, UInt<1>("h0")) @[SystolicArray.scala 63:36]
    node _runZeroes_T_1 = and(io.control.valid, _runZeroes_T) @[SystolicArray.scala 63:33]
    node runZeroes = and(_runZeroes_T_1, io.control.bits.zeroes) @[SystolicArray.scala 63:55]
    node _loadWeight_T = and(io.control.valid, io.control.bits.load) @[SystolicArray.scala 65:19]
    node _loadWeight_T_1 = eq(io.control.bits.zeroes, UInt<1>("h0")) @[SystolicArray.scala 65:43]
    node loadWeight = and(_loadWeight_T, _loadWeight_T_1) @[SystolicArray.scala 65:40]
    node _loadZeroes_T = and(io.control.valid, io.control.bits.load) @[SystolicArray.scala 66:34]
    node loadZeroes = and(_loadZeroes_T, io.control.bits.zeroes) @[SystolicArray.scala 66:55]
    node _running_T = and(runInput, io.input.valid) @[SystolicArray.scala 69:16]
    node _running_T_1 = and(_running_T, io.input.ready) @[SystolicArray.scala 69:31]
    node _running_T_2 = or(_running_T_1, runZeroes) @[SystolicArray.scala 69:47]
    node running = and(_running_T_2, output.io.deq.ready) @[SystolicArray.scala 69:61]
    node _loading_T = and(loadWeight, io.weight.valid) @[SystolicArray.scala 70:29]
    node _loading_T_1 = and(_loading_T, io.weight.ready) @[SystolicArray.scala 70:45]
    node loading = or(_loading_T_1, loadZeroes) @[SystolicArray.scala 70:62]
    ran.io.enq.valid <= running @[SystolicArray.scala 72:20]
    reg arrayPropagationCountdown : UInt<4>, clock with :
      reset => (reset, UInt<4>("h0")) @[SystolicArray.scala 74:42]
    when running : @[SystolicArray.scala 77:17]
      arrayPropagationCountdown <= UInt<4>("hf") @[SystolicArray.scala 78:31]
    else :
      node _T = gt(arrayPropagationCountdown, UInt<1>("h0")) @[SystolicArray.scala 80:36]
      when _T : @[SystolicArray.scala 80:43]
        node _arrayPropagationCountdown_T = sub(arrayPropagationCountdown, UInt<1>("h1")) @[SystolicArray.scala 81:62]
        node _arrayPropagationCountdown_T_1 = tail(_arrayPropagationCountdown_T, 1) @[SystolicArray.scala 81:62]
        arrayPropagationCountdown <= _arrayPropagationCountdown_T_1 @[SystolicArray.scala 81:33]
    node inputDone = eq(arrayPropagationCountdown, UInt<1>("h0")) @[SystolicArray.scala 87:45]
    node _array_io_load_T = and(inputDone, loading) @[SystolicArray.scala 89:30]
    array.io.load <= _array_io_load_T @[SystolicArray.scala 89:17]
    when io.control.bits.zeroes : @[SystolicArray.scala 90:29]
      wire _WIRE : Fixed<16><<8>>[8] @[package.scala 75:57]
      node _T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
      _WIRE[0] <= _T_1 @[package.scala 75:57]
      node _T_2 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
      _WIRE[1] <= _T_2 @[package.scala 75:57]
      node _T_3 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
      _WIRE[2] <= _T_3 @[package.scala 75:57]
      node _T_4 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
      _WIRE[3] <= _T_4 @[package.scala 75:57]
      node _T_5 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
      _WIRE[4] <= _T_5 @[package.scala 75:57]
      node _T_6 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
      _WIRE[5] <= _T_6 @[package.scala 75:57]
      node _T_7 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
      _WIRE[6] <= _T_7 @[package.scala 75:57]
      node _T_8 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
      _WIRE[7] <= _T_8 @[package.scala 75:57]
      array.io.input <= _WIRE @[SystolicArray.scala 91:20]
      wire _WIRE_1 : Fixed<16><<8>>[8] @[package.scala 75:57]
      node _T_9 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
      _WIRE_1[0] <= _T_9 @[package.scala 75:57]
      node _T_10 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
      _WIRE_1[1] <= _T_10 @[package.scala 75:57]
      node _T_11 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
      _WIRE_1[2] <= _T_11 @[package.scala 75:57]
      node _T_12 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
      _WIRE_1[3] <= _T_12 @[package.scala 75:57]
      node _T_13 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
      _WIRE_1[4] <= _T_13 @[package.scala 75:57]
      node _T_14 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
      _WIRE_1[5] <= _T_14 @[package.scala 75:57]
      node _T_15 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
      _WIRE_1[6] <= _T_15 @[package.scala 75:57]
      node _T_16 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
      _WIRE_1[7] <= _T_16 @[package.scala 75:57]
      array.io.weight <= _WIRE_1 @[SystolicArray.scala 92:21]
    else :
      array.io.input <= io.input.bits @[SystolicArray.scala 94:20]
      array.io.weight <= io.weight.bits @[SystolicArray.scala 95:21]
    output.io.enq.bits <= array.io.output @[SystolicArray.scala 97:22]
    io.output.bits <= output.io.deq.bits @[SystolicArray.scala 98:13]
    io.output.valid <= output.io.deq.valid @[SystolicArray.scala 98:13]
    output.io.deq.ready <= io.output.ready @[SystolicArray.scala 98:13]
    node _io_input_ready_T = and(runInput, output.io.deq.ready) @[SystolicArray.scala 100:27]
    io.input.ready <= _io_input_ready_T @[SystolicArray.scala 100:15]
    node _io_weight_ready_T = and(loadWeight, inputDone) @[SystolicArray.scala 101:30]
    io.weight.ready <= _io_weight_ready_T @[SystolicArray.scala 101:16]
    node _io_control_ready_T = eq(io.control.bits.load, UInt<1>("h0")) @[SystolicArray.scala 102:21]
    node _io_control_ready_T_1 = or(io.control.bits.zeroes, io.input.valid) @[SystolicArray.scala 102:64]
    node _io_control_ready_T_2 = and(_io_control_ready_T, _io_control_ready_T_1) @[SystolicArray.scala 102:40]
    node _io_control_ready_T_3 = and(_io_control_ready_T_2, output.io.deq.ready) @[SystolicArray.scala 102:80]
    node _io_control_ready_T_4 = or(io.control.bits.zeroes, io.weight.valid) @[SystolicArray.scala 103:48]
    node _io_control_ready_T_5 = and(io.control.bits.load, _io_control_ready_T_4) @[SystolicArray.scala 103:24]
    node _io_control_ready_T_6 = and(_io_control_ready_T_5, inputDone) @[SystolicArray.scala 103:65]
    node _io_control_ready_T_7 = or(_io_control_ready_T_3, _io_control_ready_T_6) @[SystolicArray.scala 102:104]
    io.control.ready <= _io_control_ready_T_7 @[SystolicArray.scala 102:17]
    wire _output_io_enq_valid_sr_WIRE : UInt<1>[15] @[package.scala 75:57]
    _output_io_enq_valid_sr_WIRE[0] <= UInt<1>("h0") @[package.scala 75:57]
    _output_io_enq_valid_sr_WIRE[1] <= UInt<1>("h0") @[package.scala 75:57]
    _output_io_enq_valid_sr_WIRE[2] <= UInt<1>("h0") @[package.scala 75:57]
    _output_io_enq_valid_sr_WIRE[3] <= UInt<1>("h0") @[package.scala 75:57]
    _output_io_enq_valid_sr_WIRE[4] <= UInt<1>("h0") @[package.scala 75:57]
    _output_io_enq_valid_sr_WIRE[5] <= UInt<1>("h0") @[package.scala 75:57]
    _output_io_enq_valid_sr_WIRE[6] <= UInt<1>("h0") @[package.scala 75:57]
    _output_io_enq_valid_sr_WIRE[7] <= UInt<1>("h0") @[package.scala 75:57]
    _output_io_enq_valid_sr_WIRE[8] <= UInt<1>("h0") @[package.scala 75:57]
    _output_io_enq_valid_sr_WIRE[9] <= UInt<1>("h0") @[package.scala 75:57]
    _output_io_enq_valid_sr_WIRE[10] <= UInt<1>("h0") @[package.scala 75:57]
    _output_io_enq_valid_sr_WIRE[11] <= UInt<1>("h0") @[package.scala 75:57]
    _output_io_enq_valid_sr_WIRE[12] <= UInt<1>("h0") @[package.scala 75:57]
    _output_io_enq_valid_sr_WIRE[13] <= UInt<1>("h0") @[package.scala 75:57]
    _output_io_enq_valid_sr_WIRE[14] <= UInt<1>("h0") @[package.scala 75:57]
    reg output_io_enq_valid_sr : UInt<1>[15], clock with :
      reset => (reset, _output_io_enq_valid_sr_WIRE) @[ShiftRegister.scala 10:22]
    output_io_enq_valid_sr[1] <= output_io_enq_valid_sr[0] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[2] <= output_io_enq_valid_sr[1] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[3] <= output_io_enq_valid_sr[2] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[4] <= output_io_enq_valid_sr[3] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[5] <= output_io_enq_valid_sr[4] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[6] <= output_io_enq_valid_sr[5] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[7] <= output_io_enq_valid_sr[6] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[8] <= output_io_enq_valid_sr[7] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[9] <= output_io_enq_valid_sr[8] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[10] <= output_io_enq_valid_sr[9] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[11] <= output_io_enq_valid_sr[10] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[12] <= output_io_enq_valid_sr[11] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[13] <= output_io_enq_valid_sr[12] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[14] <= output_io_enq_valid_sr[13] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[0] <= running @[ShiftRegister.scala 25:12]
    output.io.enq.valid <= output_io_enq_valid_sr[14] @[SystolicArray.scala 106:23]

  extmodule bram_dp_128x2048 :
    input clka : UInt<1>
    input wea : UInt<1>
    input ena : UInt<1>
    input addra : UInt<11>
    input dia : UInt<128>
    output doa : UInt<128>
    input clkb : UInt<1>
    input web : UInt<1>
    input enb : UInt<1>
    input addrb : UInt<11>
    input dib : UInt<128>
    output dob : UInt<128>
    defname = bram_dp_128x2048

  module InnerDualPortMem :
    input clock : Clock
    input reset : Reset
    output io : { portA : { flip address : UInt<11>, read : { flip enable : UInt<1>, data : Fixed<16><<8>>[8]}, write : { flip enable : UInt<1>, flip data : Fixed<16><<8>>[8]}}, portB : { flip address : UInt<11>, read : { flip enable : UInt<1>, data : Fixed<16><<8>>[8]}, write : { flip enable : UInt<1>, flip data : Fixed<16><<8>>[8]}}}

    inst mem of bram_dp_128x2048 @[DualPortMem.scala 173:25]
    mem.dob is invalid
    mem.dib is invalid
    mem.addrb is invalid
    mem.enb is invalid
    mem.web is invalid
    mem.clkb is invalid
    mem.doa is invalid
    mem.dia is invalid
    mem.addra is invalid
    mem.ena is invalid
    mem.wea is invalid
    mem.clka is invalid
    node _mem_io_clka_T = asUInt(clock) @[DualPortMem.scala 175:30]
    node _mem_io_clka_T_1 = bits(_mem_io_clka_T, 0, 0) @[DualPortMem.scala 175:30]
    mem.clka <= _mem_io_clka_T_1 @[DualPortMem.scala 175:21]
    node _mem_io_ena_T = asUInt(reset) @[DualPortMem.scala 176:30]
    node _mem_io_ena_T_1 = eq(_mem_io_ena_T, UInt<1>("h0")) @[DualPortMem.scala 176:23]
    mem.ena <= _mem_io_ena_T_1 @[DualPortMem.scala 176:20]
    mem.addra <= io.portA.address @[DualPortMem.scala 177:22]
    wire _io_portA_read_data_WIRE : Fixed<16><<8>>[8] @[DualPortMem.scala 178:50]
    wire _io_portA_read_data_WIRE_1 : UInt<128>
    _io_portA_read_data_WIRE_1 <= mem.doa
    node _io_portA_read_data_T = bits(_io_portA_read_data_WIRE_1, 15, 0) @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_1 = asFixedPoint(_io_portA_read_data_T, 8) @[DualPortMem.scala 178:50]
    _io_portA_read_data_WIRE[0] <= _io_portA_read_data_T_1 @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_2 = bits(_io_portA_read_data_WIRE_1, 31, 16) @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_3 = asFixedPoint(_io_portA_read_data_T_2, 8) @[DualPortMem.scala 178:50]
    _io_portA_read_data_WIRE[1] <= _io_portA_read_data_T_3 @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_4 = bits(_io_portA_read_data_WIRE_1, 47, 32) @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_5 = asFixedPoint(_io_portA_read_data_T_4, 8) @[DualPortMem.scala 178:50]
    _io_portA_read_data_WIRE[2] <= _io_portA_read_data_T_5 @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_6 = bits(_io_portA_read_data_WIRE_1, 63, 48) @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_7 = asFixedPoint(_io_portA_read_data_T_6, 8) @[DualPortMem.scala 178:50]
    _io_portA_read_data_WIRE[3] <= _io_portA_read_data_T_7 @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_8 = bits(_io_portA_read_data_WIRE_1, 79, 64) @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_9 = asFixedPoint(_io_portA_read_data_T_8, 8) @[DualPortMem.scala 178:50]
    _io_portA_read_data_WIRE[4] <= _io_portA_read_data_T_9 @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_10 = bits(_io_portA_read_data_WIRE_1, 95, 80) @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_11 = asFixedPoint(_io_portA_read_data_T_10, 8) @[DualPortMem.scala 178:50]
    _io_portA_read_data_WIRE[5] <= _io_portA_read_data_T_11 @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_12 = bits(_io_portA_read_data_WIRE_1, 111, 96) @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_13 = asFixedPoint(_io_portA_read_data_T_12, 8) @[DualPortMem.scala 178:50]
    _io_portA_read_data_WIRE[6] <= _io_portA_read_data_T_13 @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_14 = bits(_io_portA_read_data_WIRE_1, 127, 112) @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_15 = asFixedPoint(_io_portA_read_data_T_14, 8) @[DualPortMem.scala 178:50]
    _io_portA_read_data_WIRE[7] <= _io_portA_read_data_T_15 @[DualPortMem.scala 178:50]
    io.portA.read.data <= _io_portA_read_data_WIRE @[DualPortMem.scala 178:28]
    mem.wea <= io.portA.write.enable @[DualPortMem.scala 179:20]
    wire _mem_io_dia_WIRE : UInt<128> @[DualPortMem.scala 180:51]
    node _mem_io_dia_T = asUInt(io.portA.write.data[0]) @[DualPortMem.scala 180:51]
    node _mem_io_dia_T_1 = asUInt(io.portA.write.data[1]) @[DualPortMem.scala 180:51]
    node _mem_io_dia_T_2 = asUInt(io.portA.write.data[2]) @[DualPortMem.scala 180:51]
    node _mem_io_dia_T_3 = asUInt(io.portA.write.data[3]) @[DualPortMem.scala 180:51]
    node _mem_io_dia_T_4 = asUInt(io.portA.write.data[4]) @[DualPortMem.scala 180:51]
    node _mem_io_dia_T_5 = asUInt(io.portA.write.data[5]) @[DualPortMem.scala 180:51]
    node _mem_io_dia_T_6 = asUInt(io.portA.write.data[6]) @[DualPortMem.scala 180:51]
    node _mem_io_dia_T_7 = asUInt(io.portA.write.data[7]) @[DualPortMem.scala 180:51]
    node mem_io_dia_lo_lo = cat(_mem_io_dia_T_1, _mem_io_dia_T) @[DualPortMem.scala 180:51]
    node mem_io_dia_lo_hi = cat(_mem_io_dia_T_3, _mem_io_dia_T_2) @[DualPortMem.scala 180:51]
    node mem_io_dia_lo = cat(mem_io_dia_lo_hi, mem_io_dia_lo_lo) @[DualPortMem.scala 180:51]
    node mem_io_dia_hi_lo = cat(_mem_io_dia_T_5, _mem_io_dia_T_4) @[DualPortMem.scala 180:51]
    node mem_io_dia_hi_hi = cat(_mem_io_dia_T_7, _mem_io_dia_T_6) @[DualPortMem.scala 180:51]
    node mem_io_dia_hi = cat(mem_io_dia_hi_hi, mem_io_dia_hi_lo) @[DualPortMem.scala 180:51]
    node _mem_io_dia_T_8 = cat(mem_io_dia_hi, mem_io_dia_lo) @[DualPortMem.scala 180:51]
    _mem_io_dia_WIRE <= _mem_io_dia_T_8 @[DualPortMem.scala 180:51]
    mem.dia <= _mem_io_dia_WIRE @[DualPortMem.scala 180:20]
    node _mem_io_clkb_T = asUInt(clock) @[DualPortMem.scala 182:30]
    node _mem_io_clkb_T_1 = bits(_mem_io_clkb_T, 0, 0) @[DualPortMem.scala 182:30]
    mem.clkb <= _mem_io_clkb_T_1 @[DualPortMem.scala 182:21]
    node _mem_io_enb_T = asUInt(reset) @[DualPortMem.scala 183:30]
    node _mem_io_enb_T_1 = eq(_mem_io_enb_T, UInt<1>("h0")) @[DualPortMem.scala 183:23]
    mem.enb <= _mem_io_enb_T_1 @[DualPortMem.scala 183:20]
    mem.addrb <= io.portB.address @[DualPortMem.scala 184:22]
    wire _io_portB_read_data_WIRE : Fixed<16><<8>>[8] @[DualPortMem.scala 185:50]
    wire _io_portB_read_data_WIRE_1 : UInt<128>
    _io_portB_read_data_WIRE_1 <= mem.dob
    node _io_portB_read_data_T = bits(_io_portB_read_data_WIRE_1, 15, 0) @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_1 = asFixedPoint(_io_portB_read_data_T, 8) @[DualPortMem.scala 185:50]
    _io_portB_read_data_WIRE[0] <= _io_portB_read_data_T_1 @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_2 = bits(_io_portB_read_data_WIRE_1, 31, 16) @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_3 = asFixedPoint(_io_portB_read_data_T_2, 8) @[DualPortMem.scala 185:50]
    _io_portB_read_data_WIRE[1] <= _io_portB_read_data_T_3 @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_4 = bits(_io_portB_read_data_WIRE_1, 47, 32) @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_5 = asFixedPoint(_io_portB_read_data_T_4, 8) @[DualPortMem.scala 185:50]
    _io_portB_read_data_WIRE[2] <= _io_portB_read_data_T_5 @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_6 = bits(_io_portB_read_data_WIRE_1, 63, 48) @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_7 = asFixedPoint(_io_portB_read_data_T_6, 8) @[DualPortMem.scala 185:50]
    _io_portB_read_data_WIRE[3] <= _io_portB_read_data_T_7 @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_8 = bits(_io_portB_read_data_WIRE_1, 79, 64) @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_9 = asFixedPoint(_io_portB_read_data_T_8, 8) @[DualPortMem.scala 185:50]
    _io_portB_read_data_WIRE[4] <= _io_portB_read_data_T_9 @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_10 = bits(_io_portB_read_data_WIRE_1, 95, 80) @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_11 = asFixedPoint(_io_portB_read_data_T_10, 8) @[DualPortMem.scala 185:50]
    _io_portB_read_data_WIRE[5] <= _io_portB_read_data_T_11 @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_12 = bits(_io_portB_read_data_WIRE_1, 111, 96) @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_13 = asFixedPoint(_io_portB_read_data_T_12, 8) @[DualPortMem.scala 185:50]
    _io_portB_read_data_WIRE[6] <= _io_portB_read_data_T_13 @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_14 = bits(_io_portB_read_data_WIRE_1, 127, 112) @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_15 = asFixedPoint(_io_portB_read_data_T_14, 8) @[DualPortMem.scala 185:50]
    _io_portB_read_data_WIRE[7] <= _io_portB_read_data_T_15 @[DualPortMem.scala 185:50]
    io.portB.read.data <= _io_portB_read_data_WIRE @[DualPortMem.scala 185:28]
    mem.web <= io.portB.write.enable @[DualPortMem.scala 186:20]
    wire _mem_io_dib_WIRE : UInt<128> @[DualPortMem.scala 187:51]
    node _mem_io_dib_T = asUInt(io.portB.write.data[0]) @[DualPortMem.scala 187:51]
    node _mem_io_dib_T_1 = asUInt(io.portB.write.data[1]) @[DualPortMem.scala 187:51]
    node _mem_io_dib_T_2 = asUInt(io.portB.write.data[2]) @[DualPortMem.scala 187:51]
    node _mem_io_dib_T_3 = asUInt(io.portB.write.data[3]) @[DualPortMem.scala 187:51]
    node _mem_io_dib_T_4 = asUInt(io.portB.write.data[4]) @[DualPortMem.scala 187:51]
    node _mem_io_dib_T_5 = asUInt(io.portB.write.data[5]) @[DualPortMem.scala 187:51]
    node _mem_io_dib_T_6 = asUInt(io.portB.write.data[6]) @[DualPortMem.scala 187:51]
    node _mem_io_dib_T_7 = asUInt(io.portB.write.data[7]) @[DualPortMem.scala 187:51]
    node mem_io_dib_lo_lo = cat(_mem_io_dib_T_1, _mem_io_dib_T) @[DualPortMem.scala 187:51]
    node mem_io_dib_lo_hi = cat(_mem_io_dib_T_3, _mem_io_dib_T_2) @[DualPortMem.scala 187:51]
    node mem_io_dib_lo = cat(mem_io_dib_lo_hi, mem_io_dib_lo_lo) @[DualPortMem.scala 187:51]
    node mem_io_dib_hi_lo = cat(_mem_io_dib_T_5, _mem_io_dib_T_4) @[DualPortMem.scala 187:51]
    node mem_io_dib_hi_hi = cat(_mem_io_dib_T_7, _mem_io_dib_T_6) @[DualPortMem.scala 187:51]
    node mem_io_dib_hi = cat(mem_io_dib_hi_hi, mem_io_dib_hi_lo) @[DualPortMem.scala 187:51]
    node _mem_io_dib_T_8 = cat(mem_io_dib_hi, mem_io_dib_lo) @[DualPortMem.scala 187:51]
    _mem_io_dib_WIRE <= _mem_io_dib_T_8 @[DualPortMem.scala 187:51]
    mem.dib <= _mem_io_dib_WIRE @[DualPortMem.scala 187:20]

  module Queue_10 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, count : UInt<2>}

    cmem ram : Fixed<16><<8>>[8] [3] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<2>, clock with :
      reset => (reset, UInt<2>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<2>, clock with :
      reset => (reset, UInt<2>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<2>("h2")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
      when wrap : @[Counter.scala 88:20]
        enq_ptr_value <= UInt<1>("h0") @[Counter.scala 88:28]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<2>("h2")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
      when wrap_1 : @[Counter.scala 88:20]
        deq_ptr_value <= UInt<1>("h0") @[Counter.scala 88:28]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = mux(maybe_full, UInt<2>("h3"), UInt<1>("h0")) @[Decoupled.scala 319:10]
    node _io_count_T_1 = gt(deq_ptr_value, enq_ptr_value) @[Decoupled.scala 320:25]
    node _io_count_T_2 = add(UInt<2>("h3"), ptr_diff) @[Decoupled.scala 320:57]
    node _io_count_T_3 = tail(_io_count_T_2, 1) @[Decoupled.scala 320:57]
    node _io_count_T_4 = mux(_io_count_T_1, _io_count_T_3, ptr_diff) @[Decoupled.scala 320:10]
    node _io_count_T_5 = mux(ptr_match, _io_count_T, _io_count_T_4) @[Decoupled.scala 317:20]
    io.count <= _io_count_T_5 @[Decoupled.scala 317:14]

  module Queue_11 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<2>}

    cmem ram : UInt<1> [2] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Queue_12 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, count : UInt<2>}

    cmem ram : Fixed<16><<8>>[8] [3] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<2>, clock with :
      reset => (reset, UInt<2>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<2>, clock with :
      reset => (reset, UInt<2>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<2>("h2")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
      when wrap : @[Counter.scala 88:20]
        enq_ptr_value <= UInt<1>("h0") @[Counter.scala 88:28]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<2>("h2")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
      when wrap_1 : @[Counter.scala 88:20]
        deq_ptr_value <= UInt<1>("h0") @[Counter.scala 88:28]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = mux(maybe_full, UInt<2>("h3"), UInt<1>("h0")) @[Decoupled.scala 319:10]
    node _io_count_T_1 = gt(deq_ptr_value, enq_ptr_value) @[Decoupled.scala 320:25]
    node _io_count_T_2 = add(UInt<2>("h3"), ptr_diff) @[Decoupled.scala 320:57]
    node _io_count_T_3 = tail(_io_count_T_2, 1) @[Decoupled.scala 320:57]
    node _io_count_T_4 = mux(_io_count_T_1, _io_count_T_3, ptr_diff) @[Decoupled.scala 320:10]
    node _io_count_T_5 = mux(ptr_match, _io_count_T, _io_count_T_4) @[Decoupled.scala 317:20]
    io.count <= _io_count_T_5 @[Decoupled.scala 317:14]

  module Queue_13 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<2>}

    cmem ram : UInt<1> [2] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module DualPortMem :
    input clock : Clock
    input reset : Reset
    output io : { portA : { flip control : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<11>, size : UInt<11>}}, flip input : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, output : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, wrote : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, status : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<11>, size : UInt<11>}}, inputStatus : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, portB : { flip control : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<11>, size : UInt<11>}}, flip input : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, output : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, wrote : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, status : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<11>, size : UInt<11>}}, inputStatus : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, flip tracepoint : UInt<1>, flip programCounter : UInt<32>}

    inst mem of InnerDualPortMem @[DualPortMem.scala 33:19]
    mem.clock <= clock
    mem.reset <= reset
    inst output of Queue_10 @[DualPortMem.scala 48:24]
    output.clock <= clock
    output.reset <= reset
    node outputReady = lt(output.io.count, UInt<2>("h2")) @[DualPortMem.scala 55:39]
    mem.io.portA.address <= io.portA.control.bits.address @[DualPortMem.scala 57:19]
    when io.portA.control.bits.write : @[DualPortMem.scala 59:30]
      io.portA.control.ready <= io.portA.input.valid @[DualPortMem.scala 60:21]
      node _mem_io_portA_write_enable_T = and(io.portA.control.valid, io.portA.input.valid) @[DualPortMem.scala 61:43]
      mem.io.portA.write.enable <= _mem_io_portA_write_enable_T @[DualPortMem.scala 61:26]
      mem.io.portA.read.enable <= UInt<1>("h0") @[DualPortMem.scala 62:25]
    else :
      io.portA.control.ready <= outputReady @[DualPortMem.scala 64:21]
      mem.io.portA.write.enable <= UInt<1>("h0") @[DualPortMem.scala 65:26]
      node _mem_io_portA_read_enable_T = and(io.portA.control.valid, outputReady) @[DualPortMem.scala 66:42]
      mem.io.portA.read.enable <= _mem_io_portA_read_enable_T @[DualPortMem.scala 66:25]
    output.io.enq.bits[0] <= mem.io.portA.read.data[0] @[DualPortMem.scala 69:24]
    output.io.enq.bits[1] <= mem.io.portA.read.data[1] @[DualPortMem.scala 69:24]
    output.io.enq.bits[2] <= mem.io.portA.read.data[2] @[DualPortMem.scala 69:24]
    output.io.enq.bits[3] <= mem.io.portA.read.data[3] @[DualPortMem.scala 69:24]
    output.io.enq.bits[4] <= mem.io.portA.read.data[4] @[DualPortMem.scala 69:24]
    output.io.enq.bits[5] <= mem.io.portA.read.data[5] @[DualPortMem.scala 69:24]
    output.io.enq.bits[6] <= mem.io.portA.read.data[6] @[DualPortMem.scala 69:24]
    output.io.enq.bits[7] <= mem.io.portA.read.data[7] @[DualPortMem.scala 69:24]
    wire _output_io_enq_valid_sr_WIRE : UInt<1>[1] @[package.scala 75:57]
    _output_io_enq_valid_sr_WIRE[0] <= UInt<1>("h0") @[package.scala 75:57]
    reg output_io_enq_valid_sr : UInt<1>[1], clock with :
      reset => (reset, _output_io_enq_valid_sr_WIRE) @[ShiftRegister.scala 10:22]
    output_io_enq_valid_sr[0] <= mem.io.portA.read.enable @[ShiftRegister.scala 25:12]
    output.io.enq.valid <= output_io_enq_valid_sr[0] @[DualPortMem.scala 70:25]
    io.portA.output.bits <= output.io.deq.bits @[DualPortMem.scala 72:17]
    io.portA.output.valid <= output.io.deq.valid @[DualPortMem.scala 72:17]
    output.io.deq.ready <= io.portA.output.ready @[DualPortMem.scala 72:17]
    mem.io.portA.write.data[0] <= io.portA.input.bits[0] @[DualPortMem.scala 74:22]
    mem.io.portA.write.data[1] <= io.portA.input.bits[1] @[DualPortMem.scala 74:22]
    mem.io.portA.write.data[2] <= io.portA.input.bits[2] @[DualPortMem.scala 74:22]
    mem.io.portA.write.data[3] <= io.portA.input.bits[3] @[DualPortMem.scala 74:22]
    mem.io.portA.write.data[4] <= io.portA.input.bits[4] @[DualPortMem.scala 74:22]
    mem.io.portA.write.data[5] <= io.portA.input.bits[5] @[DualPortMem.scala 74:22]
    mem.io.portA.write.data[6] <= io.portA.input.bits[6] @[DualPortMem.scala 74:22]
    mem.io.portA.write.data[7] <= io.portA.input.bits[7] @[DualPortMem.scala 74:22]
    node _io_portA_input_ready_T = and(io.portA.control.valid, io.portA.control.bits.write) @[DualPortMem.scala 75:34]
    io.portA.input.ready <= _io_portA_input_ready_T @[DualPortMem.scala 75:17]
    io.portA.status.bits <= io.portA.control.bits @[DualPortMem.scala 89:22]
    node _io_portA_status_valid_T = and(io.portA.control.valid, io.portA.control.ready) @[DualPortMem.scala 90:40]
    io.portA.status.valid <= _io_portA_status_valid_T @[DualPortMem.scala 90:23]
    io.portA.inputStatus.bits <= io.portA.input.bits @[DualPortMem.scala 92:27]
    node _io_portA_inputStatus_valid_T = and(io.portA.input.valid, io.portA.input.ready) @[DualPortMem.scala 93:43]
    io.portA.inputStatus.valid <= _io_portA_inputStatus_valid_T @[DualPortMem.scala 93:28]
    inst wrote of Queue_11 @[Mem.scala 22:19]
    wrote.clock <= clock
    wrote.reset <= reset
    io.portA.wrote.bits <= wrote.io.deq.bits @[Mem.scala 23:7]
    io.portA.wrote.valid <= wrote.io.deq.valid @[Mem.scala 23:7]
    wrote.io.deq.ready <= io.portA.wrote.ready @[Mem.scala 23:7]
    wrote.io.enq.bits <= UInt<1>("h1") @[DualPortMem.scala 96:16]
    wrote.io.enq.valid <= mem.io.portA.write.enable @[DualPortMem.scala 97:17]
    inst output_1 of Queue_12 @[DualPortMem.scala 48:24]
    output_1.clock <= clock
    output_1.reset <= reset
    node outputReady_1 = lt(output_1.io.count, UInt<2>("h2")) @[DualPortMem.scala 55:39]
    mem.io.portB.address <= io.portB.control.bits.address @[DualPortMem.scala 57:19]
    when io.portB.control.bits.write : @[DualPortMem.scala 59:30]
      io.portB.control.ready <= io.portB.input.valid @[DualPortMem.scala 60:21]
      node _mem_io_portB_write_enable_T = and(io.portB.control.valid, io.portB.input.valid) @[DualPortMem.scala 61:43]
      mem.io.portB.write.enable <= _mem_io_portB_write_enable_T @[DualPortMem.scala 61:26]
      mem.io.portB.read.enable <= UInt<1>("h0") @[DualPortMem.scala 62:25]
    else :
      io.portB.control.ready <= outputReady_1 @[DualPortMem.scala 64:21]
      mem.io.portB.write.enable <= UInt<1>("h0") @[DualPortMem.scala 65:26]
      node _mem_io_portB_read_enable_T = and(io.portB.control.valid, outputReady_1) @[DualPortMem.scala 66:42]
      mem.io.portB.read.enable <= _mem_io_portB_read_enable_T @[DualPortMem.scala 66:25]
    output_1.io.enq.bits[0] <= mem.io.portB.read.data[0] @[DualPortMem.scala 69:24]
    output_1.io.enq.bits[1] <= mem.io.portB.read.data[1] @[DualPortMem.scala 69:24]
    output_1.io.enq.bits[2] <= mem.io.portB.read.data[2] @[DualPortMem.scala 69:24]
    output_1.io.enq.bits[3] <= mem.io.portB.read.data[3] @[DualPortMem.scala 69:24]
    output_1.io.enq.bits[4] <= mem.io.portB.read.data[4] @[DualPortMem.scala 69:24]
    output_1.io.enq.bits[5] <= mem.io.portB.read.data[5] @[DualPortMem.scala 69:24]
    output_1.io.enq.bits[6] <= mem.io.portB.read.data[6] @[DualPortMem.scala 69:24]
    output_1.io.enq.bits[7] <= mem.io.portB.read.data[7] @[DualPortMem.scala 69:24]
    wire _output_io_enq_valid_sr_WIRE_1 : UInt<1>[1] @[package.scala 75:57]
    _output_io_enq_valid_sr_WIRE_1[0] <= UInt<1>("h0") @[package.scala 75:57]
    reg output_io_enq_valid_sr_1 : UInt<1>[1], clock with :
      reset => (reset, _output_io_enq_valid_sr_WIRE_1) @[ShiftRegister.scala 10:22]
    output_io_enq_valid_sr_1[0] <= mem.io.portB.read.enable @[ShiftRegister.scala 25:12]
    output_1.io.enq.valid <= output_io_enq_valid_sr_1[0] @[DualPortMem.scala 70:25]
    io.portB.output.bits <= output_1.io.deq.bits @[DualPortMem.scala 72:17]
    io.portB.output.valid <= output_1.io.deq.valid @[DualPortMem.scala 72:17]
    output_1.io.deq.ready <= io.portB.output.ready @[DualPortMem.scala 72:17]
    mem.io.portB.write.data[0] <= io.portB.input.bits[0] @[DualPortMem.scala 74:22]
    mem.io.portB.write.data[1] <= io.portB.input.bits[1] @[DualPortMem.scala 74:22]
    mem.io.portB.write.data[2] <= io.portB.input.bits[2] @[DualPortMem.scala 74:22]
    mem.io.portB.write.data[3] <= io.portB.input.bits[3] @[DualPortMem.scala 74:22]
    mem.io.portB.write.data[4] <= io.portB.input.bits[4] @[DualPortMem.scala 74:22]
    mem.io.portB.write.data[5] <= io.portB.input.bits[5] @[DualPortMem.scala 74:22]
    mem.io.portB.write.data[6] <= io.portB.input.bits[6] @[DualPortMem.scala 74:22]
    mem.io.portB.write.data[7] <= io.portB.input.bits[7] @[DualPortMem.scala 74:22]
    node _io_portB_input_ready_T = and(io.portB.control.valid, io.portB.control.bits.write) @[DualPortMem.scala 75:34]
    io.portB.input.ready <= _io_portB_input_ready_T @[DualPortMem.scala 75:17]
    io.portB.status.bits <= io.portB.control.bits @[DualPortMem.scala 89:22]
    node _io_portB_status_valid_T = and(io.portB.control.valid, io.portB.control.ready) @[DualPortMem.scala 90:40]
    io.portB.status.valid <= _io_portB_status_valid_T @[DualPortMem.scala 90:23]
    io.portB.inputStatus.bits <= io.portB.input.bits @[DualPortMem.scala 92:27]
    node _io_portB_inputStatus_valid_T = and(io.portB.input.valid, io.portB.input.ready) @[DualPortMem.scala 93:43]
    io.portB.inputStatus.valid <= _io_portB_inputStatus_valid_T @[DualPortMem.scala 93:28]
    inst wrote_1 of Queue_13 @[Mem.scala 22:19]
    wrote_1.clock <= clock
    wrote_1.reset <= reset
    io.portB.wrote.bits <= wrote_1.io.deq.bits @[Mem.scala 23:7]
    io.portB.wrote.valid <= wrote_1.io.deq.valid @[Mem.scala 23:7]
    wrote_1.io.deq.ready <= io.portB.wrote.ready @[Mem.scala 23:7]
    wrote_1.io.enq.bits <= UInt<1>("h1") @[DualPortMem.scala 96:16]
    wrote_1.io.enq.valid <= mem.io.portB.write.enable @[DualPortMem.scala 97:17]

  module VecAdder :
    input clock : Clock
    input reset : Reset
    output io : { flip left : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip right : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, output : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}

    node _io_output_bits_0_T = asSInt(io.left.bits[0]) @[package.scala 163:37]
    node _io_output_bits_0_T_1 = asSInt(io.right.bits[0]) @[package.scala 163:49]
    node _io_output_bits_0_T_2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
    node _io_output_bits_0_mac_T = mul(_io_output_bits_0_T, _io_output_bits_0_T_2) @[package.scala 117:18]
    node _io_output_bits_0_mac_T_1 = shl(_io_output_bits_0_T_1, 8) @[package.scala 117:29]
    node io_output_bits_0_mac = add(_io_output_bits_0_mac_T, _io_output_bits_0_mac_T_1) @[package.scala 117:23]
    node io_output_bits_0_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
    node _io_output_bits_0_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
    node _io_output_bits_0_mask1_T_1 = sub(_io_output_bits_0_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
    node _io_output_bits_0_mask1_T_2 = tail(_io_output_bits_0_mask1_T_1, 1) @[package.scala 120:44]
    node io_output_bits_0_mask1 = asSInt(_io_output_bits_0_mask1_T_2) @[package.scala 120:44]
    node io_output_bits_0_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
    node _io_output_bits_0_adjustment_T = and(io_output_bits_0_mac, io_output_bits_0_mask0) @[package.scala 125:16]
    node _io_output_bits_0_adjustment_T_1 = asSInt(_io_output_bits_0_adjustment_T) @[package.scala 125:16]
    node _io_output_bits_0_adjustment_T_2 = neq(_io_output_bits_0_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
    node _io_output_bits_0_adjustment_T_3 = and(io_output_bits_0_mac, io_output_bits_0_mask1) @[package.scala 125:44]
    node _io_output_bits_0_adjustment_T_4 = asSInt(_io_output_bits_0_adjustment_T_3) @[package.scala 125:44]
    node _io_output_bits_0_adjustment_T_5 = neq(_io_output_bits_0_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
    node _io_output_bits_0_adjustment_T_6 = and(io_output_bits_0_mac, io_output_bits_0_mask2) @[package.scala 125:71]
    node _io_output_bits_0_adjustment_T_7 = asSInt(_io_output_bits_0_adjustment_T_6) @[package.scala 125:71]
    node _io_output_bits_0_adjustment_T_8 = neq(_io_output_bits_0_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
    node _io_output_bits_0_adjustment_T_9 = or(_io_output_bits_0_adjustment_T_5, _io_output_bits_0_adjustment_T_8) @[package.scala 125:62]
    node _io_output_bits_0_adjustment_T_10 = and(_io_output_bits_0_adjustment_T_2, _io_output_bits_0_adjustment_T_9) @[package.scala 125:34]
    node io_output_bits_0_adjustment = mux(_io_output_bits_0_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
    node _io_output_bits_0_adjusted_T = shr(io_output_bits_0_mac, 8) @[package.scala 130:26]
    node _io_output_bits_0_adjusted_T_1 = add(_io_output_bits_0_adjusted_T, io_output_bits_0_adjustment) @[package.scala 130:42]
    node _io_output_bits_0_adjusted_T_2 = tail(_io_output_bits_0_adjusted_T_1, 1) @[package.scala 130:42]
    node io_output_bits_0_adjusted = asSInt(_io_output_bits_0_adjusted_T_2) @[package.scala 130:42]
    node _io_output_bits_0_saturated_T = gt(io_output_bits_0_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
    node _io_output_bits_0_saturated_T_1 = lt(io_output_bits_0_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
    node _io_output_bits_0_saturated_T_2 = mux(_io_output_bits_0_saturated_T_1, asSInt(UInt<16>("h8000")), io_output_bits_0_adjusted) @[package.scala 98:26]
    node io_output_bits_0_saturated = mux(_io_output_bits_0_saturated_T, asSInt(UInt<16>("h7fff")), _io_output_bits_0_saturated_T_2) @[package.scala 98:8]
    node _io_output_bits_0_T_3 = asFixedPoint(io_output_bits_0_saturated, 8) @[package.scala 133:27]
    io.output.bits[0] <= _io_output_bits_0_T_3 @[VecAdder.scala 21:23]
    node _io_output_bits_1_T = asSInt(io.left.bits[1]) @[package.scala 163:37]
    node _io_output_bits_1_T_1 = asSInt(io.right.bits[1]) @[package.scala 163:49]
    node _io_output_bits_1_T_2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
    node _io_output_bits_1_mac_T = mul(_io_output_bits_1_T, _io_output_bits_1_T_2) @[package.scala 117:18]
    node _io_output_bits_1_mac_T_1 = shl(_io_output_bits_1_T_1, 8) @[package.scala 117:29]
    node io_output_bits_1_mac = add(_io_output_bits_1_mac_T, _io_output_bits_1_mac_T_1) @[package.scala 117:23]
    node io_output_bits_1_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
    node _io_output_bits_1_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
    node _io_output_bits_1_mask1_T_1 = sub(_io_output_bits_1_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
    node _io_output_bits_1_mask1_T_2 = tail(_io_output_bits_1_mask1_T_1, 1) @[package.scala 120:44]
    node io_output_bits_1_mask1 = asSInt(_io_output_bits_1_mask1_T_2) @[package.scala 120:44]
    node io_output_bits_1_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
    node _io_output_bits_1_adjustment_T = and(io_output_bits_1_mac, io_output_bits_1_mask0) @[package.scala 125:16]
    node _io_output_bits_1_adjustment_T_1 = asSInt(_io_output_bits_1_adjustment_T) @[package.scala 125:16]
    node _io_output_bits_1_adjustment_T_2 = neq(_io_output_bits_1_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
    node _io_output_bits_1_adjustment_T_3 = and(io_output_bits_1_mac, io_output_bits_1_mask1) @[package.scala 125:44]
    node _io_output_bits_1_adjustment_T_4 = asSInt(_io_output_bits_1_adjustment_T_3) @[package.scala 125:44]
    node _io_output_bits_1_adjustment_T_5 = neq(_io_output_bits_1_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
    node _io_output_bits_1_adjustment_T_6 = and(io_output_bits_1_mac, io_output_bits_1_mask2) @[package.scala 125:71]
    node _io_output_bits_1_adjustment_T_7 = asSInt(_io_output_bits_1_adjustment_T_6) @[package.scala 125:71]
    node _io_output_bits_1_adjustment_T_8 = neq(_io_output_bits_1_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
    node _io_output_bits_1_adjustment_T_9 = or(_io_output_bits_1_adjustment_T_5, _io_output_bits_1_adjustment_T_8) @[package.scala 125:62]
    node _io_output_bits_1_adjustment_T_10 = and(_io_output_bits_1_adjustment_T_2, _io_output_bits_1_adjustment_T_9) @[package.scala 125:34]
    node io_output_bits_1_adjustment = mux(_io_output_bits_1_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
    node _io_output_bits_1_adjusted_T = shr(io_output_bits_1_mac, 8) @[package.scala 130:26]
    node _io_output_bits_1_adjusted_T_1 = add(_io_output_bits_1_adjusted_T, io_output_bits_1_adjustment) @[package.scala 130:42]
    node _io_output_bits_1_adjusted_T_2 = tail(_io_output_bits_1_adjusted_T_1, 1) @[package.scala 130:42]
    node io_output_bits_1_adjusted = asSInt(_io_output_bits_1_adjusted_T_2) @[package.scala 130:42]
    node _io_output_bits_1_saturated_T = gt(io_output_bits_1_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
    node _io_output_bits_1_saturated_T_1 = lt(io_output_bits_1_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
    node _io_output_bits_1_saturated_T_2 = mux(_io_output_bits_1_saturated_T_1, asSInt(UInt<16>("h8000")), io_output_bits_1_adjusted) @[package.scala 98:26]
    node io_output_bits_1_saturated = mux(_io_output_bits_1_saturated_T, asSInt(UInt<16>("h7fff")), _io_output_bits_1_saturated_T_2) @[package.scala 98:8]
    node _io_output_bits_1_T_3 = asFixedPoint(io_output_bits_1_saturated, 8) @[package.scala 133:27]
    io.output.bits[1] <= _io_output_bits_1_T_3 @[VecAdder.scala 21:23]
    node _io_output_bits_2_T = asSInt(io.left.bits[2]) @[package.scala 163:37]
    node _io_output_bits_2_T_1 = asSInt(io.right.bits[2]) @[package.scala 163:49]
    node _io_output_bits_2_T_2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
    node _io_output_bits_2_mac_T = mul(_io_output_bits_2_T, _io_output_bits_2_T_2) @[package.scala 117:18]
    node _io_output_bits_2_mac_T_1 = shl(_io_output_bits_2_T_1, 8) @[package.scala 117:29]
    node io_output_bits_2_mac = add(_io_output_bits_2_mac_T, _io_output_bits_2_mac_T_1) @[package.scala 117:23]
    node io_output_bits_2_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
    node _io_output_bits_2_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
    node _io_output_bits_2_mask1_T_1 = sub(_io_output_bits_2_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
    node _io_output_bits_2_mask1_T_2 = tail(_io_output_bits_2_mask1_T_1, 1) @[package.scala 120:44]
    node io_output_bits_2_mask1 = asSInt(_io_output_bits_2_mask1_T_2) @[package.scala 120:44]
    node io_output_bits_2_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
    node _io_output_bits_2_adjustment_T = and(io_output_bits_2_mac, io_output_bits_2_mask0) @[package.scala 125:16]
    node _io_output_bits_2_adjustment_T_1 = asSInt(_io_output_bits_2_adjustment_T) @[package.scala 125:16]
    node _io_output_bits_2_adjustment_T_2 = neq(_io_output_bits_2_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
    node _io_output_bits_2_adjustment_T_3 = and(io_output_bits_2_mac, io_output_bits_2_mask1) @[package.scala 125:44]
    node _io_output_bits_2_adjustment_T_4 = asSInt(_io_output_bits_2_adjustment_T_3) @[package.scala 125:44]
    node _io_output_bits_2_adjustment_T_5 = neq(_io_output_bits_2_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
    node _io_output_bits_2_adjustment_T_6 = and(io_output_bits_2_mac, io_output_bits_2_mask2) @[package.scala 125:71]
    node _io_output_bits_2_adjustment_T_7 = asSInt(_io_output_bits_2_adjustment_T_6) @[package.scala 125:71]
    node _io_output_bits_2_adjustment_T_8 = neq(_io_output_bits_2_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
    node _io_output_bits_2_adjustment_T_9 = or(_io_output_bits_2_adjustment_T_5, _io_output_bits_2_adjustment_T_8) @[package.scala 125:62]
    node _io_output_bits_2_adjustment_T_10 = and(_io_output_bits_2_adjustment_T_2, _io_output_bits_2_adjustment_T_9) @[package.scala 125:34]
    node io_output_bits_2_adjustment = mux(_io_output_bits_2_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
    node _io_output_bits_2_adjusted_T = shr(io_output_bits_2_mac, 8) @[package.scala 130:26]
    node _io_output_bits_2_adjusted_T_1 = add(_io_output_bits_2_adjusted_T, io_output_bits_2_adjustment) @[package.scala 130:42]
    node _io_output_bits_2_adjusted_T_2 = tail(_io_output_bits_2_adjusted_T_1, 1) @[package.scala 130:42]
    node io_output_bits_2_adjusted = asSInt(_io_output_bits_2_adjusted_T_2) @[package.scala 130:42]
    node _io_output_bits_2_saturated_T = gt(io_output_bits_2_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
    node _io_output_bits_2_saturated_T_1 = lt(io_output_bits_2_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
    node _io_output_bits_2_saturated_T_2 = mux(_io_output_bits_2_saturated_T_1, asSInt(UInt<16>("h8000")), io_output_bits_2_adjusted) @[package.scala 98:26]
    node io_output_bits_2_saturated = mux(_io_output_bits_2_saturated_T, asSInt(UInt<16>("h7fff")), _io_output_bits_2_saturated_T_2) @[package.scala 98:8]
    node _io_output_bits_2_T_3 = asFixedPoint(io_output_bits_2_saturated, 8) @[package.scala 133:27]
    io.output.bits[2] <= _io_output_bits_2_T_3 @[VecAdder.scala 21:23]
    node _io_output_bits_3_T = asSInt(io.left.bits[3]) @[package.scala 163:37]
    node _io_output_bits_3_T_1 = asSInt(io.right.bits[3]) @[package.scala 163:49]
    node _io_output_bits_3_T_2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
    node _io_output_bits_3_mac_T = mul(_io_output_bits_3_T, _io_output_bits_3_T_2) @[package.scala 117:18]
    node _io_output_bits_3_mac_T_1 = shl(_io_output_bits_3_T_1, 8) @[package.scala 117:29]
    node io_output_bits_3_mac = add(_io_output_bits_3_mac_T, _io_output_bits_3_mac_T_1) @[package.scala 117:23]
    node io_output_bits_3_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
    node _io_output_bits_3_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
    node _io_output_bits_3_mask1_T_1 = sub(_io_output_bits_3_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
    node _io_output_bits_3_mask1_T_2 = tail(_io_output_bits_3_mask1_T_1, 1) @[package.scala 120:44]
    node io_output_bits_3_mask1 = asSInt(_io_output_bits_3_mask1_T_2) @[package.scala 120:44]
    node io_output_bits_3_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
    node _io_output_bits_3_adjustment_T = and(io_output_bits_3_mac, io_output_bits_3_mask0) @[package.scala 125:16]
    node _io_output_bits_3_adjustment_T_1 = asSInt(_io_output_bits_3_adjustment_T) @[package.scala 125:16]
    node _io_output_bits_3_adjustment_T_2 = neq(_io_output_bits_3_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
    node _io_output_bits_3_adjustment_T_3 = and(io_output_bits_3_mac, io_output_bits_3_mask1) @[package.scala 125:44]
    node _io_output_bits_3_adjustment_T_4 = asSInt(_io_output_bits_3_adjustment_T_3) @[package.scala 125:44]
    node _io_output_bits_3_adjustment_T_5 = neq(_io_output_bits_3_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
    node _io_output_bits_3_adjustment_T_6 = and(io_output_bits_3_mac, io_output_bits_3_mask2) @[package.scala 125:71]
    node _io_output_bits_3_adjustment_T_7 = asSInt(_io_output_bits_3_adjustment_T_6) @[package.scala 125:71]
    node _io_output_bits_3_adjustment_T_8 = neq(_io_output_bits_3_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
    node _io_output_bits_3_adjustment_T_9 = or(_io_output_bits_3_adjustment_T_5, _io_output_bits_3_adjustment_T_8) @[package.scala 125:62]
    node _io_output_bits_3_adjustment_T_10 = and(_io_output_bits_3_adjustment_T_2, _io_output_bits_3_adjustment_T_9) @[package.scala 125:34]
    node io_output_bits_3_adjustment = mux(_io_output_bits_3_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
    node _io_output_bits_3_adjusted_T = shr(io_output_bits_3_mac, 8) @[package.scala 130:26]
    node _io_output_bits_3_adjusted_T_1 = add(_io_output_bits_3_adjusted_T, io_output_bits_3_adjustment) @[package.scala 130:42]
    node _io_output_bits_3_adjusted_T_2 = tail(_io_output_bits_3_adjusted_T_1, 1) @[package.scala 130:42]
    node io_output_bits_3_adjusted = asSInt(_io_output_bits_3_adjusted_T_2) @[package.scala 130:42]
    node _io_output_bits_3_saturated_T = gt(io_output_bits_3_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
    node _io_output_bits_3_saturated_T_1 = lt(io_output_bits_3_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
    node _io_output_bits_3_saturated_T_2 = mux(_io_output_bits_3_saturated_T_1, asSInt(UInt<16>("h8000")), io_output_bits_3_adjusted) @[package.scala 98:26]
    node io_output_bits_3_saturated = mux(_io_output_bits_3_saturated_T, asSInt(UInt<16>("h7fff")), _io_output_bits_3_saturated_T_2) @[package.scala 98:8]
    node _io_output_bits_3_T_3 = asFixedPoint(io_output_bits_3_saturated, 8) @[package.scala 133:27]
    io.output.bits[3] <= _io_output_bits_3_T_3 @[VecAdder.scala 21:23]
    node _io_output_bits_4_T = asSInt(io.left.bits[4]) @[package.scala 163:37]
    node _io_output_bits_4_T_1 = asSInt(io.right.bits[4]) @[package.scala 163:49]
    node _io_output_bits_4_T_2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
    node _io_output_bits_4_mac_T = mul(_io_output_bits_4_T, _io_output_bits_4_T_2) @[package.scala 117:18]
    node _io_output_bits_4_mac_T_1 = shl(_io_output_bits_4_T_1, 8) @[package.scala 117:29]
    node io_output_bits_4_mac = add(_io_output_bits_4_mac_T, _io_output_bits_4_mac_T_1) @[package.scala 117:23]
    node io_output_bits_4_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
    node _io_output_bits_4_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
    node _io_output_bits_4_mask1_T_1 = sub(_io_output_bits_4_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
    node _io_output_bits_4_mask1_T_2 = tail(_io_output_bits_4_mask1_T_1, 1) @[package.scala 120:44]
    node io_output_bits_4_mask1 = asSInt(_io_output_bits_4_mask1_T_2) @[package.scala 120:44]
    node io_output_bits_4_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
    node _io_output_bits_4_adjustment_T = and(io_output_bits_4_mac, io_output_bits_4_mask0) @[package.scala 125:16]
    node _io_output_bits_4_adjustment_T_1 = asSInt(_io_output_bits_4_adjustment_T) @[package.scala 125:16]
    node _io_output_bits_4_adjustment_T_2 = neq(_io_output_bits_4_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
    node _io_output_bits_4_adjustment_T_3 = and(io_output_bits_4_mac, io_output_bits_4_mask1) @[package.scala 125:44]
    node _io_output_bits_4_adjustment_T_4 = asSInt(_io_output_bits_4_adjustment_T_3) @[package.scala 125:44]
    node _io_output_bits_4_adjustment_T_5 = neq(_io_output_bits_4_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
    node _io_output_bits_4_adjustment_T_6 = and(io_output_bits_4_mac, io_output_bits_4_mask2) @[package.scala 125:71]
    node _io_output_bits_4_adjustment_T_7 = asSInt(_io_output_bits_4_adjustment_T_6) @[package.scala 125:71]
    node _io_output_bits_4_adjustment_T_8 = neq(_io_output_bits_4_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
    node _io_output_bits_4_adjustment_T_9 = or(_io_output_bits_4_adjustment_T_5, _io_output_bits_4_adjustment_T_8) @[package.scala 125:62]
    node _io_output_bits_4_adjustment_T_10 = and(_io_output_bits_4_adjustment_T_2, _io_output_bits_4_adjustment_T_9) @[package.scala 125:34]
    node io_output_bits_4_adjustment = mux(_io_output_bits_4_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
    node _io_output_bits_4_adjusted_T = shr(io_output_bits_4_mac, 8) @[package.scala 130:26]
    node _io_output_bits_4_adjusted_T_1 = add(_io_output_bits_4_adjusted_T, io_output_bits_4_adjustment) @[package.scala 130:42]
    node _io_output_bits_4_adjusted_T_2 = tail(_io_output_bits_4_adjusted_T_1, 1) @[package.scala 130:42]
    node io_output_bits_4_adjusted = asSInt(_io_output_bits_4_adjusted_T_2) @[package.scala 130:42]
    node _io_output_bits_4_saturated_T = gt(io_output_bits_4_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
    node _io_output_bits_4_saturated_T_1 = lt(io_output_bits_4_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
    node _io_output_bits_4_saturated_T_2 = mux(_io_output_bits_4_saturated_T_1, asSInt(UInt<16>("h8000")), io_output_bits_4_adjusted) @[package.scala 98:26]
    node io_output_bits_4_saturated = mux(_io_output_bits_4_saturated_T, asSInt(UInt<16>("h7fff")), _io_output_bits_4_saturated_T_2) @[package.scala 98:8]
    node _io_output_bits_4_T_3 = asFixedPoint(io_output_bits_4_saturated, 8) @[package.scala 133:27]
    io.output.bits[4] <= _io_output_bits_4_T_3 @[VecAdder.scala 21:23]
    node _io_output_bits_5_T = asSInt(io.left.bits[5]) @[package.scala 163:37]
    node _io_output_bits_5_T_1 = asSInt(io.right.bits[5]) @[package.scala 163:49]
    node _io_output_bits_5_T_2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
    node _io_output_bits_5_mac_T = mul(_io_output_bits_5_T, _io_output_bits_5_T_2) @[package.scala 117:18]
    node _io_output_bits_5_mac_T_1 = shl(_io_output_bits_5_T_1, 8) @[package.scala 117:29]
    node io_output_bits_5_mac = add(_io_output_bits_5_mac_T, _io_output_bits_5_mac_T_1) @[package.scala 117:23]
    node io_output_bits_5_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
    node _io_output_bits_5_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
    node _io_output_bits_5_mask1_T_1 = sub(_io_output_bits_5_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
    node _io_output_bits_5_mask1_T_2 = tail(_io_output_bits_5_mask1_T_1, 1) @[package.scala 120:44]
    node io_output_bits_5_mask1 = asSInt(_io_output_bits_5_mask1_T_2) @[package.scala 120:44]
    node io_output_bits_5_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
    node _io_output_bits_5_adjustment_T = and(io_output_bits_5_mac, io_output_bits_5_mask0) @[package.scala 125:16]
    node _io_output_bits_5_adjustment_T_1 = asSInt(_io_output_bits_5_adjustment_T) @[package.scala 125:16]
    node _io_output_bits_5_adjustment_T_2 = neq(_io_output_bits_5_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
    node _io_output_bits_5_adjustment_T_3 = and(io_output_bits_5_mac, io_output_bits_5_mask1) @[package.scala 125:44]
    node _io_output_bits_5_adjustment_T_4 = asSInt(_io_output_bits_5_adjustment_T_3) @[package.scala 125:44]
    node _io_output_bits_5_adjustment_T_5 = neq(_io_output_bits_5_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
    node _io_output_bits_5_adjustment_T_6 = and(io_output_bits_5_mac, io_output_bits_5_mask2) @[package.scala 125:71]
    node _io_output_bits_5_adjustment_T_7 = asSInt(_io_output_bits_5_adjustment_T_6) @[package.scala 125:71]
    node _io_output_bits_5_adjustment_T_8 = neq(_io_output_bits_5_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
    node _io_output_bits_5_adjustment_T_9 = or(_io_output_bits_5_adjustment_T_5, _io_output_bits_5_adjustment_T_8) @[package.scala 125:62]
    node _io_output_bits_5_adjustment_T_10 = and(_io_output_bits_5_adjustment_T_2, _io_output_bits_5_adjustment_T_9) @[package.scala 125:34]
    node io_output_bits_5_adjustment = mux(_io_output_bits_5_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
    node _io_output_bits_5_adjusted_T = shr(io_output_bits_5_mac, 8) @[package.scala 130:26]
    node _io_output_bits_5_adjusted_T_1 = add(_io_output_bits_5_adjusted_T, io_output_bits_5_adjustment) @[package.scala 130:42]
    node _io_output_bits_5_adjusted_T_2 = tail(_io_output_bits_5_adjusted_T_1, 1) @[package.scala 130:42]
    node io_output_bits_5_adjusted = asSInt(_io_output_bits_5_adjusted_T_2) @[package.scala 130:42]
    node _io_output_bits_5_saturated_T = gt(io_output_bits_5_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
    node _io_output_bits_5_saturated_T_1 = lt(io_output_bits_5_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
    node _io_output_bits_5_saturated_T_2 = mux(_io_output_bits_5_saturated_T_1, asSInt(UInt<16>("h8000")), io_output_bits_5_adjusted) @[package.scala 98:26]
    node io_output_bits_5_saturated = mux(_io_output_bits_5_saturated_T, asSInt(UInt<16>("h7fff")), _io_output_bits_5_saturated_T_2) @[package.scala 98:8]
    node _io_output_bits_5_T_3 = asFixedPoint(io_output_bits_5_saturated, 8) @[package.scala 133:27]
    io.output.bits[5] <= _io_output_bits_5_T_3 @[VecAdder.scala 21:23]
    node _io_output_bits_6_T = asSInt(io.left.bits[6]) @[package.scala 163:37]
    node _io_output_bits_6_T_1 = asSInt(io.right.bits[6]) @[package.scala 163:49]
    node _io_output_bits_6_T_2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
    node _io_output_bits_6_mac_T = mul(_io_output_bits_6_T, _io_output_bits_6_T_2) @[package.scala 117:18]
    node _io_output_bits_6_mac_T_1 = shl(_io_output_bits_6_T_1, 8) @[package.scala 117:29]
    node io_output_bits_6_mac = add(_io_output_bits_6_mac_T, _io_output_bits_6_mac_T_1) @[package.scala 117:23]
    node io_output_bits_6_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
    node _io_output_bits_6_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
    node _io_output_bits_6_mask1_T_1 = sub(_io_output_bits_6_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
    node _io_output_bits_6_mask1_T_2 = tail(_io_output_bits_6_mask1_T_1, 1) @[package.scala 120:44]
    node io_output_bits_6_mask1 = asSInt(_io_output_bits_6_mask1_T_2) @[package.scala 120:44]
    node io_output_bits_6_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
    node _io_output_bits_6_adjustment_T = and(io_output_bits_6_mac, io_output_bits_6_mask0) @[package.scala 125:16]
    node _io_output_bits_6_adjustment_T_1 = asSInt(_io_output_bits_6_adjustment_T) @[package.scala 125:16]
    node _io_output_bits_6_adjustment_T_2 = neq(_io_output_bits_6_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
    node _io_output_bits_6_adjustment_T_3 = and(io_output_bits_6_mac, io_output_bits_6_mask1) @[package.scala 125:44]
    node _io_output_bits_6_adjustment_T_4 = asSInt(_io_output_bits_6_adjustment_T_3) @[package.scala 125:44]
    node _io_output_bits_6_adjustment_T_5 = neq(_io_output_bits_6_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
    node _io_output_bits_6_adjustment_T_6 = and(io_output_bits_6_mac, io_output_bits_6_mask2) @[package.scala 125:71]
    node _io_output_bits_6_adjustment_T_7 = asSInt(_io_output_bits_6_adjustment_T_6) @[package.scala 125:71]
    node _io_output_bits_6_adjustment_T_8 = neq(_io_output_bits_6_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
    node _io_output_bits_6_adjustment_T_9 = or(_io_output_bits_6_adjustment_T_5, _io_output_bits_6_adjustment_T_8) @[package.scala 125:62]
    node _io_output_bits_6_adjustment_T_10 = and(_io_output_bits_6_adjustment_T_2, _io_output_bits_6_adjustment_T_9) @[package.scala 125:34]
    node io_output_bits_6_adjustment = mux(_io_output_bits_6_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
    node _io_output_bits_6_adjusted_T = shr(io_output_bits_6_mac, 8) @[package.scala 130:26]
    node _io_output_bits_6_adjusted_T_1 = add(_io_output_bits_6_adjusted_T, io_output_bits_6_adjustment) @[package.scala 130:42]
    node _io_output_bits_6_adjusted_T_2 = tail(_io_output_bits_6_adjusted_T_1, 1) @[package.scala 130:42]
    node io_output_bits_6_adjusted = asSInt(_io_output_bits_6_adjusted_T_2) @[package.scala 130:42]
    node _io_output_bits_6_saturated_T = gt(io_output_bits_6_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
    node _io_output_bits_6_saturated_T_1 = lt(io_output_bits_6_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
    node _io_output_bits_6_saturated_T_2 = mux(_io_output_bits_6_saturated_T_1, asSInt(UInt<16>("h8000")), io_output_bits_6_adjusted) @[package.scala 98:26]
    node io_output_bits_6_saturated = mux(_io_output_bits_6_saturated_T, asSInt(UInt<16>("h7fff")), _io_output_bits_6_saturated_T_2) @[package.scala 98:8]
    node _io_output_bits_6_T_3 = asFixedPoint(io_output_bits_6_saturated, 8) @[package.scala 133:27]
    io.output.bits[6] <= _io_output_bits_6_T_3 @[VecAdder.scala 21:23]
    node _io_output_bits_7_T = asSInt(io.left.bits[7]) @[package.scala 163:37]
    node _io_output_bits_7_T_1 = asSInt(io.right.bits[7]) @[package.scala 163:49]
    node _io_output_bits_7_T_2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
    node _io_output_bits_7_mac_T = mul(_io_output_bits_7_T, _io_output_bits_7_T_2) @[package.scala 117:18]
    node _io_output_bits_7_mac_T_1 = shl(_io_output_bits_7_T_1, 8) @[package.scala 117:29]
    node io_output_bits_7_mac = add(_io_output_bits_7_mac_T, _io_output_bits_7_mac_T_1) @[package.scala 117:23]
    node io_output_bits_7_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
    node _io_output_bits_7_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
    node _io_output_bits_7_mask1_T_1 = sub(_io_output_bits_7_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
    node _io_output_bits_7_mask1_T_2 = tail(_io_output_bits_7_mask1_T_1, 1) @[package.scala 120:44]
    node io_output_bits_7_mask1 = asSInt(_io_output_bits_7_mask1_T_2) @[package.scala 120:44]
    node io_output_bits_7_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
    node _io_output_bits_7_adjustment_T = and(io_output_bits_7_mac, io_output_bits_7_mask0) @[package.scala 125:16]
    node _io_output_bits_7_adjustment_T_1 = asSInt(_io_output_bits_7_adjustment_T) @[package.scala 125:16]
    node _io_output_bits_7_adjustment_T_2 = neq(_io_output_bits_7_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
    node _io_output_bits_7_adjustment_T_3 = and(io_output_bits_7_mac, io_output_bits_7_mask1) @[package.scala 125:44]
    node _io_output_bits_7_adjustment_T_4 = asSInt(_io_output_bits_7_adjustment_T_3) @[package.scala 125:44]
    node _io_output_bits_7_adjustment_T_5 = neq(_io_output_bits_7_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
    node _io_output_bits_7_adjustment_T_6 = and(io_output_bits_7_mac, io_output_bits_7_mask2) @[package.scala 125:71]
    node _io_output_bits_7_adjustment_T_7 = asSInt(_io_output_bits_7_adjustment_T_6) @[package.scala 125:71]
    node _io_output_bits_7_adjustment_T_8 = neq(_io_output_bits_7_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
    node _io_output_bits_7_adjustment_T_9 = or(_io_output_bits_7_adjustment_T_5, _io_output_bits_7_adjustment_T_8) @[package.scala 125:62]
    node _io_output_bits_7_adjustment_T_10 = and(_io_output_bits_7_adjustment_T_2, _io_output_bits_7_adjustment_T_9) @[package.scala 125:34]
    node io_output_bits_7_adjustment = mux(_io_output_bits_7_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
    node _io_output_bits_7_adjusted_T = shr(io_output_bits_7_mac, 8) @[package.scala 130:26]
    node _io_output_bits_7_adjusted_T_1 = add(_io_output_bits_7_adjusted_T, io_output_bits_7_adjustment) @[package.scala 130:42]
    node _io_output_bits_7_adjusted_T_2 = tail(_io_output_bits_7_adjusted_T_1, 1) @[package.scala 130:42]
    node io_output_bits_7_adjusted = asSInt(_io_output_bits_7_adjusted_T_2) @[package.scala 130:42]
    node _io_output_bits_7_saturated_T = gt(io_output_bits_7_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
    node _io_output_bits_7_saturated_T_1 = lt(io_output_bits_7_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
    node _io_output_bits_7_saturated_T_2 = mux(_io_output_bits_7_saturated_T_1, asSInt(UInt<16>("h8000")), io_output_bits_7_adjusted) @[package.scala 98:26]
    node io_output_bits_7_saturated = mux(_io_output_bits_7_saturated_T, asSInt(UInt<16>("h7fff")), _io_output_bits_7_saturated_T_2) @[package.scala 98:8]
    node _io_output_bits_7_T_3 = asFixedPoint(io_output_bits_7_saturated, 8) @[package.scala 133:27]
    io.output.bits[7] <= _io_output_bits_7_T_3 @[VecAdder.scala 21:23]
    node _io_output_valid_T = and(io.left.valid, io.right.valid) @[VecAdder.scala 23:33]
    io.output.valid <= _io_output_valid_T @[VecAdder.scala 23:19]
    node _io_left_ready_T = and(io.output.ready, io.right.valid) @[VecAdder.scala 24:33]
    io.left.ready <= _io_left_ready_T @[VecAdder.scala 24:14]
    node _io_right_ready_T = and(io.output.ready, io.left.valid) @[VecAdder.scala 25:34]
    io.right.ready <= _io_right_ready_T @[VecAdder.scala 25:15]

  module LockPool_1 :
    input clock : Clock
    input reset : Reset
    output io : { actor : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<11>, size : UInt<11>}}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<11>, size : UInt<11>}}}[2], flip lock : { flip ready : UInt<1>, valid : UInt<1>, bits : { cond : { write : UInt<1>, address : UInt<11>, size : UInt<11>}, lock : UInt<0>, acquire : UInt<1>, by : UInt<1>, delayRelease : UInt<4>}}, locked : { flip ready : UInt<1>, valid : UInt<1>, bits : { cond : { write : UInt<1>, address : UInt<11>, size : UInt<11>}, lock : UInt<0>, acquire : UInt<1>, by : UInt<1>, delayRelease : UInt<4>}}, deadlocked : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}}

    wire actor : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<11>, size : UInt<11>}}[2] @[LockPool.scala 52:28]
    actor[0] <= io.actor[0].in @[LockPool.scala 52:28]
    actor[1] <= io.actor[1].in @[LockPool.scala 52:28]
    wire _lock_WIRE : { cond : { write : UInt<1>, address : UInt<11>, size : UInt<11>}, held : UInt<1>, by : UInt<1>, delayRelease : UInt<4>} @[package.scala 75:57]
    _lock_WIRE.delayRelease <= UInt<4>("h0") @[package.scala 75:57]
    _lock_WIRE.by <= UInt<1>("h0") @[package.scala 75:57]
    _lock_WIRE.held <= UInt<1>("h0") @[package.scala 75:57]
    _lock_WIRE.cond.size <= UInt<11>("h0") @[package.scala 75:57]
    _lock_WIRE.cond.address <= UInt<11>("h0") @[package.scala 75:57]
    _lock_WIRE.cond.write <= UInt<1>("h0") @[package.scala 75:57]
    wire _lock_WIRE_1 : { cond : { write : UInt<1>, address : UInt<11>, size : UInt<11>}, held : UInt<1>, by : UInt<1>, delayRelease : UInt<4>}[1] @[LockPool.scala 56:12]
    _lock_WIRE_1[0] <= _lock_WIRE @[LockPool.scala 56:12]
    reg lock : { cond : { write : UInt<1>, address : UInt<11>, size : UInt<11>}, held : UInt<1>, by : UInt<1>, delayRelease : UInt<4>}[1], clock with :
      reset => (reset, _lock_WIRE_1) @[LockPool.scala 55:21]
    io.actor[0].out.valid <= UInt<1>("h0") @[Decoupled.scala 72:20]
    io.actor[0].out.bits.size is invalid @[Decoupled.scala 73:19]
    io.actor[0].out.bits.address is invalid @[Decoupled.scala 73:19]
    io.actor[0].out.bits.write is invalid @[Decoupled.scala 73:19]
    actor[0].ready <= UInt<1>("h0") @[LockPool.scala 66:13]
    node _block_blocked_T = neq(lock[UInt<1>("h0")].by, UInt<1>("h0")) @[LockPool.scala 70:45]
    node _block_blocked_T_1 = and(lock[UInt<1>("h0")].held, _block_blocked_T) @[LockPool.scala 70:26]
    node _block_blocked_T_2 = and(io.lock.ready, io.lock.valid) @[Decoupled.scala 50:35]
    node _block_blocked_T_3 = eq(io.lock.bits.lock, UInt<1>("h0")) @[LockPool.scala 70:101]
    node _block_blocked_T_4 = and(_block_blocked_T_2, _block_blocked_T_3) @[LockPool.scala 70:76]
    node _block_blocked_T_5 = neq(io.lock.bits.by, UInt<1>("h0")) @[LockPool.scala 70:143]
    node _block_blocked_T_6 = and(_block_blocked_T_4, _block_blocked_T_5) @[LockPool.scala 70:120]
    node block_blocked = or(_block_blocked_T_1, _block_blocked_T_6) @[LockPool.scala 70:55]
    node _block_T = eq(block_blocked, UInt<1>("h0")) @[LockPool.scala 71:10]
    when _block_T : @[LockPool.scala 71:20]
      io.actor[0].out <= actor[0] @[LockPool.scala 73:24]
    io.actor[1].out.valid <= UInt<1>("h0") @[Decoupled.scala 72:20]
    io.actor[1].out.bits.size is invalid @[Decoupled.scala 73:19]
    io.actor[1].out.bits.address is invalid @[Decoupled.scala 73:19]
    io.actor[1].out.bits.write is invalid @[Decoupled.scala 73:19]
    actor[1].ready <= UInt<1>("h0") @[LockPool.scala 66:13]
    node _block_blocked_T_7 = neq(lock[UInt<1>("h0")].by, UInt<1>("h1")) @[LockPool.scala 70:45]
    node _block_blocked_T_8 = and(lock[UInt<1>("h0")].held, _block_blocked_T_7) @[LockPool.scala 70:26]
    node _block_blocked_T_9 = and(io.lock.ready, io.lock.valid) @[Decoupled.scala 50:35]
    node _block_blocked_T_10 = eq(io.lock.bits.lock, UInt<1>("h0")) @[LockPool.scala 70:101]
    node _block_blocked_T_11 = and(_block_blocked_T_9, _block_blocked_T_10) @[LockPool.scala 70:76]
    node _block_blocked_T_12 = neq(io.lock.bits.by, UInt<1>("h1")) @[LockPool.scala 70:143]
    node _block_blocked_T_13 = and(_block_blocked_T_11, _block_blocked_T_12) @[LockPool.scala 70:120]
    node block_blocked_1 = or(_block_blocked_T_8, _block_blocked_T_13) @[LockPool.scala 70:55]
    node _block_T_1 = eq(block_blocked_1, UInt<1>("h0")) @[LockPool.scala 71:10]
    when _block_T_1 : @[LockPool.scala 71:20]
      io.actor[1].out <= actor[1] @[LockPool.scala 73:24]
    wire block : UInt<1>[2] @[LockPool.scala 63:22]
    block[0] <= block_blocked @[LockPool.scala 63:22]
    block[1] <= block_blocked_1 @[LockPool.scala 63:22]
    io.locked.bits <= io.lock.bits @[LockPool.scala 79:18]
    node _io_locked_valid_T = and(io.lock.ready, io.lock.valid) @[Decoupled.scala 50:35]
    io.locked.valid <= _io_locked_valid_T @[LockPool.scala 80:19]
    io.deadlocked.valid <= UInt<1>("h0") @[Decoupled.scala 72:20]
    io.deadlocked.bits is invalid @[Decoupled.scala 73:19]
    node _incomingObserved_T = and(actor[io.lock.bits.by].ready, actor[io.lock.bits.by].valid) @[Decoupled.scala 50:35]
    node _incomingObserved_T_1 = and(io.lock.valid, _incomingObserved_T) @[LockPool.scala 98:23]
    node _incomingObserved_T_2 = eq(actor[io.lock.bits.by].bits.write, io.lock.bits.cond.write) @[MemControl.scala 59:11]
    node _incomingObserved_T_3 = eq(actor[io.lock.bits.by].bits.address, io.lock.bits.cond.address) @[MemControl.scala 59:38]
    node _incomingObserved_T_4 = and(_incomingObserved_T_2, _incomingObserved_T_3) @[MemControl.scala 59:27]
    node _incomingObserved_T_5 = eq(actor[io.lock.bits.by].bits.size, io.lock.bits.cond.size) @[MemControl.scala 59:64]
    node _incomingObserved_T_6 = and(_incomingObserved_T_4, _incomingObserved_T_5) @[MemControl.scala 59:56]
    node incomingObserved = and(_incomingObserved_T_1, _incomingObserved_T_6) @[LockPool.scala 98:58]
    node _io_lock_ready_T = neq(io.lock.bits.by, lock[UInt<1>("h0")].by) @[LockPool.scala 104:68]
    node _io_lock_ready_T_1 = and(lock[UInt<1>("h0")].held, _io_lock_ready_T) @[LockPool.scala 104:45]
    node _io_lock_ready_T_2 = eq(_io_lock_ready_T_1, UInt<1>("h0")) @[LockPool.scala 104:24]
    io.lock.ready <= _io_lock_ready_T_2 @[LockPool.scala 104:21]
    node incoming = eq(io.lock.bits.lock, UInt<1>("h0")) @[LockPool.scala 106:42]
    node _observed_T = and(actor[lock[0].by].ready, actor[lock[0].by].valid) @[Decoupled.scala 50:35]
    node _observed_T_1 = eq(actor[lock[0].by].bits.write, lock[0].cond.write) @[MemControl.scala 59:11]
    node _observed_T_2 = eq(actor[lock[0].by].bits.address, lock[0].cond.address) @[MemControl.scala 59:38]
    node _observed_T_3 = and(_observed_T_1, _observed_T_2) @[MemControl.scala 59:27]
    node _observed_T_4 = eq(actor[lock[0].by].bits.size, lock[0].cond.size) @[MemControl.scala 59:64]
    node _observed_T_5 = and(_observed_T_3, _observed_T_4) @[MemControl.scala 59:56]
    node observed = and(_observed_T, _observed_T_5) @[LockPool.scala 107:37]
    when lock[0].held : @[LockPool.scala 108:18]
      when observed : @[LockPool.scala 109:22]
        when incoming : @[LockPool.scala 110:24]
          when incomingObserved : @[LockPool.scala 111:34]
            lock[0].held <= UInt<1>("h0") @[LockPool.scala 93:12]
          else :
            lock[0].held <= UInt<1>("h0") @[LockPool.scala 93:12]
            when io.lock.valid : @[LockPool.scala 86:29]
              lock[0].held <= io.lock.bits.acquire @[LockPool.scala 87:14]
              lock[0].by <= io.lock.bits.by @[LockPool.scala 88:12]
              lock[0].cond <= io.lock.bits.cond @[LockPool.scala 89:14]
        else :
          lock[0].held <= UInt<1>("h0") @[LockPool.scala 93:12]
      else :
        when incoming : @[LockPool.scala 122:24]
          node _T = eq(lock[0].by, io.lock.bits.by) @[LockPool.scala 123:21]
          when _T : @[LockPool.scala 123:46]
            when io.lock.valid : @[LockPool.scala 86:29]
              lock[0].held <= io.lock.bits.acquire @[LockPool.scala 87:14]
              lock[0].by <= io.lock.bits.by @[LockPool.scala 88:12]
              lock[0].cond <= io.lock.bits.cond @[LockPool.scala 89:14]
    else :
      when incoming : @[LockPool.scala 130:22]
        node _T_1 = eq(incomingObserved, UInt<1>("h0")) @[LockPool.scala 131:14]
        when _T_1 : @[LockPool.scala 131:33]
          when io.lock.valid : @[LockPool.scala 86:29]
            lock[0].held <= io.lock.bits.acquire @[LockPool.scala 87:14]
            lock[0].by <= io.lock.bits.by @[LockPool.scala 88:12]
            lock[0].cond <= io.lock.bits.cond @[LockPool.scala 89:14]
    node _T_2 = and(block[0], block[1]) @[LockPool.scala 139:33]
    when _T_2 : @[LockPool.scala 139:40]
      io.actor[lock[UInt<1>("h0")].by].out <= actor[lock[UInt<1>("h0")].by] @[LockPool.scala 140:32]
      io.deadlocked.bits <= UInt<1>("h1") @[LockPool.scala 142:24]
      io.deadlocked.valid <= UInt<1>("h1") @[LockPool.scala 143:25]

  module Queue_14 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<11>, size : UInt<11>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<11>, size : UInt<11>}}, count : UInt<1>}

    cmem ram : { write : UInt<1>, address : UInt<11>, size : UInt<11>} [1] @[Decoupled.scala 259:95]
    wire enq_ptr_value : UInt
    enq_ptr_value <= UInt<1>("h0")
    wire deq_ptr_value : UInt
    deq_ptr_value <= UInt<1>("h0")
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[UInt<1>("h0")], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
    when do_deq : @[Decoupled.scala 276:16]
      skip
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[UInt<1>("h0")], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    when io.deq.ready : @[Decoupled.scala 309:24]
      io.enq.ready <= UInt<1>("h1") @[Decoupled.scala 309:39]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<1>("h1"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Demux :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip sel : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2]}

    wire _io_out_0_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 75:57]
    node _io_out_0_bits_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[0] <= _io_out_0_bits_T @[package.scala 75:57]
    node _io_out_0_bits_T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[1] <= _io_out_0_bits_T_1 @[package.scala 75:57]
    node _io_out_0_bits_T_2 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[2] <= _io_out_0_bits_T_2 @[package.scala 75:57]
    node _io_out_0_bits_T_3 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[3] <= _io_out_0_bits_T_3 @[package.scala 75:57]
    node _io_out_0_bits_T_4 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[4] <= _io_out_0_bits_T_4 @[package.scala 75:57]
    node _io_out_0_bits_T_5 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[5] <= _io_out_0_bits_T_5 @[package.scala 75:57]
    node _io_out_0_bits_T_6 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[6] <= _io_out_0_bits_T_6 @[package.scala 75:57]
    node _io_out_0_bits_T_7 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[7] <= _io_out_0_bits_T_7 @[package.scala 75:57]
    io.out[0].bits <= _io_out_0_bits_WIRE @[Demux.scala 27:14]
    io.out[0].valid <= UInt<1>("h0") @[Demux.scala 28:15]
    wire _io_out_1_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 75:57]
    node _io_out_1_bits_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[0] <= _io_out_1_bits_T @[package.scala 75:57]
    node _io_out_1_bits_T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[1] <= _io_out_1_bits_T_1 @[package.scala 75:57]
    node _io_out_1_bits_T_2 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[2] <= _io_out_1_bits_T_2 @[package.scala 75:57]
    node _io_out_1_bits_T_3 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[3] <= _io_out_1_bits_T_3 @[package.scala 75:57]
    node _io_out_1_bits_T_4 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[4] <= _io_out_1_bits_T_4 @[package.scala 75:57]
    node _io_out_1_bits_T_5 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[5] <= _io_out_1_bits_T_5 @[package.scala 75:57]
    node _io_out_1_bits_T_6 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[6] <= _io_out_1_bits_T_6 @[package.scala 75:57]
    node _io_out_1_bits_T_7 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[7] <= _io_out_1_bits_T_7 @[package.scala 75:57]
    io.out[1].bits <= _io_out_1_bits_WIRE @[Demux.scala 27:14]
    io.out[1].valid <= UInt<1>("h0") @[Demux.scala 28:15]
    io.out[io.sel.bits].bits <= io.in.bits @[Demux.scala 32:12]
    node _io_out_valid_T = and(io.sel.valid, io.in.valid) @[Demux.scala 33:26]
    io.out[io.sel.bits].valid <= _io_out_valid_T @[Demux.scala 33:13]
    node _io_sel_ready_T = and(io.in.valid, io.out[io.sel.bits].ready) @[Demux.scala 34:25]
    io.sel.ready <= _io_sel_ready_T @[Demux.scala 34:13]
    node _io_in_ready_T = and(io.sel.valid, io.out[io.sel.bits].ready) @[Demux.scala 35:25]
    io.in.ready <= _io_in_ready_T @[Demux.scala 35:12]

  module Queue_15 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<1>}

    cmem ram : UInt<1> [1] @[Decoupled.scala 259:95]
    wire enq_ptr_value : UInt
    enq_ptr_value <= UInt<1>("h0")
    wire deq_ptr_value : UInt
    deq_ptr_value <= UInt<1>("h0")
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[UInt<1>("h0")], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
    when do_deq : @[Decoupled.scala 276:16]
      skip
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[UInt<1>("h0")], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    when io.deq.ready : @[Decoupled.scala 309:24]
      io.enq.ready <= UInt<1>("h1") @[Decoupled.scala 309:39]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<1>("h1"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Mux :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2], flip sel : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}

    wire in : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2] @[Mux.scala 47:19]
    in[0] <= io.in[0] @[Mux.scala 47:19]
    in[1] <= io.in[1] @[Mux.scala 47:19]
    in[UInt<1>("h0")].ready <= UInt<1>("h0") @[Mux.scala 52:19]
    in[UInt<1>("h1")].ready <= UInt<1>("h0") @[Mux.scala 52:19]
    io.out.bits <= in[io.sel.bits].bits @[Mux.scala 57:15]
    node _io_out_valid_T = and(io.sel.valid, in[io.sel.bits].valid) @[Mux.scala 58:29]
    io.out.valid <= _io_out_valid_T @[Mux.scala 58:16]
    node _io_sel_ready_T = and(in[io.sel.bits].valid, io.out.ready) @[Mux.scala 59:26]
    io.sel.ready <= _io_sel_ready_T @[Mux.scala 59:13]
    node _in_ready_T = and(io.sel.valid, io.out.ready) @[Mux.scala 60:26]
    in[io.sel.bits].ready <= _in_ready_T @[Mux.scala 60:13]

  module Queue_16 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<1>}

    cmem ram : UInt<1> [1] @[Decoupled.scala 259:95]
    wire enq_ptr_value : UInt
    enq_ptr_value <= UInt<1>("h0")
    wire deq_ptr_value : UInt
    deq_ptr_value <= UInt<1>("h0")
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[UInt<1>("h0")], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
    when do_deq : @[Decoupled.scala 276:16]
      skip
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[UInt<1>("h0")], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    when io.deq.ready : @[Decoupled.scala 309:24]
      io.enq.ready <= UInt<1>("h1") @[Decoupled.scala 309:39]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<1>("h1"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module MultiEnqueue_5 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>}[4]}

    reg enq_0 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_2 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_3 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_2 = or(io.out[2].ready, enq_2) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_3 = or(io.out[3].ready, enq_3) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_4 = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _allEnqueued_T_5 = and(_allEnqueued_T_4, _allEnqueued_T_2) @[MultiEnqueue.scala 24:15]
    node allEnqueued = and(_allEnqueued_T_5, _allEnqueued_T_3) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_1 = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
    node _io_out_2_valid_T = eq(enq_2, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_2_valid_T_1 = and(io.in.valid, _io_out_2_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[2].valid <= _io_out_2_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_2 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_2 = eq(enq_2, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_2 : @[MultiEnqueue.scala 31:21]
        node _enq_2_T = and(io.out[2].valid, io.out[2].ready) @[MultiEnqueue.scala 32:35]
        enq_2 <= _enq_2_T @[MultiEnqueue.scala 32:16]
    node _io_out_3_valid_T = eq(enq_3, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_3_valid_T_1 = and(io.in.valid, _io_out_3_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[3].valid <= _io_out_3_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_3 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_3 = eq(enq_3, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_3 : @[MultiEnqueue.scala 31:21]
        node _enq_3_T = and(io.out[3].valid, io.out[3].ready) @[MultiEnqueue.scala 32:35]
        enq_3 <= _enq_3_T @[MultiEnqueue.scala 32:16]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]

  module MultiEnqueue_6 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>}[1]}

    reg enq_0 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    node allEnqueued = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]

  module MultiEnqueue_7 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>}[4]}

    reg enq_0 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_2 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_3 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_2 = or(io.out[2].ready, enq_2) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_3 = or(io.out[3].ready, enq_3) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_4 = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _allEnqueued_T_5 = and(_allEnqueued_T_4, _allEnqueued_T_2) @[MultiEnqueue.scala 24:15]
    node allEnqueued = and(_allEnqueued_T_5, _allEnqueued_T_3) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_1 = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
    node _io_out_2_valid_T = eq(enq_2, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_2_valid_T_1 = and(io.in.valid, _io_out_2_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[2].valid <= _io_out_2_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_2 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_2 = eq(enq_2, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_2 : @[MultiEnqueue.scala 31:21]
        node _enq_2_T = and(io.out[2].valid, io.out[2].ready) @[MultiEnqueue.scala 32:35]
        enq_2 <= _enq_2_T @[MultiEnqueue.scala 32:16]
    node _io_out_3_valid_T = eq(enq_3, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_3_valid_T_1 = and(io.in.valid, _io_out_3_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[3].valid <= _io_out_3_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_3 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_3 = eq(enq_3, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_3 : @[MultiEnqueue.scala 31:21]
        node _enq_3_T = and(io.out[3].valid, io.out[3].ready) @[MultiEnqueue.scala 32:35]
        enq_3 <= _enq_3_T @[MultiEnqueue.scala 32:16]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]

  module Accumulator :
    input clock : Clock
    input reset : Reset
    output io : { flip input : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, output : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip control : { flip ready : UInt<1>, valid : UInt<1>, bits : { address : UInt<11>, accumulate : UInt<1>, write : UInt<1>}}, wrote : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, flip tracepoint : UInt<1>, flip programCounter : UInt<32>}

    inst mem of DualPortMem @[Accumulator.scala 40:19]
    mem.clock <= clock
    mem.reset <= reset
    inst adder of VecAdder @[Accumulator.scala 49:23]
    adder.clock <= clock
    adder.reset <= reset
    inst lockPool of LockPool_1 @[Accumulator.scala 60:24]
    lockPool.clock <= clock
    lockPool.reset <= reset
    inst portAControl of Queue_14 @[Mem.scala 22:19]
    portAControl.clock <= clock
    portAControl.reset <= reset
    lockPool.io.actor[0].in <= portAControl.io.deq @[Mem.scala 23:7]
    mem.io.portA.control <= lockPool.io.actor[0].out @[Accumulator.scala 66:19]
    mem.io.portB.control <= lockPool.io.actor[1].out @[Accumulator.scala 67:19]
    lockPool.io.lock.valid <= UInt<1>("h0") @[Decoupled.scala 72:20]
    lockPool.io.lock.bits.delayRelease is invalid @[Decoupled.scala 73:19]
    lockPool.io.lock.bits.by is invalid @[Decoupled.scala 73:19]
    lockPool.io.lock.bits.acquire is invalid @[Decoupled.scala 73:19]
    lockPool.io.lock.bits.lock is invalid @[Decoupled.scala 73:19]
    lockPool.io.lock.bits.cond.size is invalid @[Decoupled.scala 73:19]
    lockPool.io.lock.bits.cond.address is invalid @[Decoupled.scala 73:19]
    lockPool.io.lock.bits.cond.write is invalid @[Decoupled.scala 73:19]
    lockPool.io.locked.ready <= UInt<1>("h0") @[Decoupled.scala 88:20]
    lockPool.io.deadlocked.ready <= UInt<1>("h0") @[Decoupled.scala 88:20]
    mem.io.programCounter <= io.programCounter @[Accumulator.scala 73:25]
    mem.io.tracepoint <= io.tracepoint @[Accumulator.scala 74:21]
    wire _portAControl_io_enq_bits_WIRE : { write : UInt<1>, address : UInt<11>, size : UInt<11>} @[package.scala 75:57]
    _portAControl_io_enq_bits_WIRE.size <= UInt<11>("h0") @[package.scala 75:57]
    _portAControl_io_enq_bits_WIRE.address <= UInt<11>("h0") @[package.scala 75:57]
    _portAControl_io_enq_bits_WIRE.write <= UInt<1>("h0") @[package.scala 75:57]
    portAControl.io.enq.bits.size <= _portAControl_io_enq_bits_WIRE.size @[package.scala 404:14]
    portAControl.io.enq.bits.address <= _portAControl_io_enq_bits_WIRE.address @[package.scala 404:14]
    portAControl.io.enq.bits.write <= _portAControl_io_enq_bits_WIRE.write @[package.scala 404:14]
    portAControl.io.enq.valid <= UInt<1>("h0") @[package.scala 405:15]
    wire _lockPool_io_actor_1_in_bits_WIRE : { write : UInt<1>, address : UInt<11>, size : UInt<11>} @[package.scala 75:57]
    _lockPool_io_actor_1_in_bits_WIRE.size <= UInt<11>("h0") @[package.scala 75:57]
    _lockPool_io_actor_1_in_bits_WIRE.address <= UInt<11>("h0") @[package.scala 75:57]
    _lockPool_io_actor_1_in_bits_WIRE.write <= UInt<1>("h0") @[package.scala 75:57]
    lockPool.io.actor[1].in.bits.size <= _lockPool_io_actor_1_in_bits_WIRE.size @[package.scala 404:14]
    lockPool.io.actor[1].in.bits.address <= _lockPool_io_actor_1_in_bits_WIRE.address @[package.scala 404:14]
    lockPool.io.actor[1].in.bits.write <= _lockPool_io_actor_1_in_bits_WIRE.write @[package.scala 404:14]
    lockPool.io.actor[1].in.valid <= UInt<1>("h0") @[package.scala 405:15]
    mem.io.portA.status.ready <= UInt<1>("h1") @[Accumulator.scala 77:22]
    mem.io.portA.inputStatus.ready <= UInt<1>("h1") @[Accumulator.scala 78:27]
    mem.io.portB.status.ready <= UInt<1>("h1") @[Accumulator.scala 79:22]
    mem.io.portB.inputStatus.ready <= UInt<1>("h1") @[Accumulator.scala 80:27]
    io.wrote.bits <= mem.io.portA.wrote.bits @[Accumulator.scala 81:12]
    io.wrote.valid <= mem.io.portA.wrote.valid @[Accumulator.scala 81:12]
    mem.io.portA.wrote.ready <= io.wrote.ready @[Accumulator.scala 81:12]
    mem.io.portB.wrote.ready <= UInt<1>("h0") @[Decoupled.scala 88:20]
    io.output.bits <= mem.io.portA.output.bits @[Accumulator.scala 84:13]
    io.output.valid <= mem.io.portA.output.valid @[Accumulator.scala 84:13]
    mem.io.portA.output.ready <= io.output.ready @[Accumulator.scala 84:13]
    mem.io.portB.input.valid <= UInt<1>("h0") @[Decoupled.scala 72:20]
    mem.io.portB.input.bits[0] is invalid @[Decoupled.scala 73:19]
    mem.io.portB.input.bits[1] is invalid @[Decoupled.scala 73:19]
    mem.io.portB.input.bits[2] is invalid @[Decoupled.scala 73:19]
    mem.io.portB.input.bits[3] is invalid @[Decoupled.scala 73:19]
    mem.io.portB.input.bits[4] is invalid @[Decoupled.scala 73:19]
    mem.io.portB.input.bits[5] is invalid @[Decoupled.scala 73:19]
    mem.io.portB.input.bits[6] is invalid @[Decoupled.scala 73:19]
    mem.io.portB.input.bits[7] is invalid @[Decoupled.scala 73:19]
    adder.io.right <= mem.io.portB.output @[Accumulator.scala 86:18]
    inst inputDemuxModule of Demux @[Accumulator.scala 88:32]
    inputDemuxModule.clock <= clock
    inputDemuxModule.reset <= reset
    inst inputDemux of Queue_15 @[Mem.scala 22:19]
    inputDemux.clock <= clock
    inputDemux.reset <= reset
    inputDemuxModule.io.sel <= inputDemux.io.deq @[Mem.scala 23:7]
    inputDemuxModule.io.in <= io.input @[Accumulator.scala 93:26]
    adder.io.left <= inputDemuxModule.io.out[1] @[Accumulator.scala 94:17]
    inst portAInputMux_x14_mux of Mux @[Mux.scala 71:21]
    portAInputMux_x14_mux.clock <= clock
    portAInputMux_x14_mux.reset <= reset
    portAInputMux_x14_mux.io.in[0] <= inputDemuxModule.io.out[0] @[Mux.scala 79:18]
    portAInputMux_x14_mux.io.in[1] <= adder.io.output @[Mux.scala 80:18]
    mem.io.portA.input <= portAInputMux_x14_mux.io.out @[Mux.scala 81:9]
    inst portAInputMux of Queue_16 @[Mem.scala 22:19]
    portAInputMux.clock <= clock
    portAInputMux.reset <= reset
    portAInputMux_x14_mux.io.sel <= portAInputMux.io.deq @[Mem.scala 23:7]
    inputDemux.io.enq.valid <= UInt<1>("h0") @[Decoupled.scala 72:20]
    inputDemux.io.enq.bits is invalid @[Decoupled.scala 73:19]
    portAInputMux.io.enq.valid <= UInt<1>("h0") @[Decoupled.scala 72:20]
    portAInputMux.io.enq.bits is invalid @[Decoupled.scala 73:19]
    inst writeEnqueuer of MultiEnqueue_5 @[MultiEnqueue.scala 182:43]
    writeEnqueuer.clock <= clock
    writeEnqueuer.reset <= reset
    inst readEnqueuer of MultiEnqueue_6 @[MultiEnqueue.scala 182:43]
    readEnqueuer.clock <= clock
    readEnqueuer.reset <= reset
    inst accEnqueuer of MultiEnqueue_7 @[MultiEnqueue.scala 182:43]
    accEnqueuer.clock <= clock
    accEnqueuer.reset <= reset
    writeEnqueuer.io.in.valid <= UInt<1>("h0") @[MultiEnqueue.scala 40:17]
    writeEnqueuer.io.out[0].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    writeEnqueuer.io.out[1].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    writeEnqueuer.io.out[2].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    writeEnqueuer.io.out[3].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    readEnqueuer.io.in.valid <= UInt<1>("h0") @[MultiEnqueue.scala 40:17]
    readEnqueuer.io.out[0].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    accEnqueuer.io.in.valid <= UInt<1>("h0") @[MultiEnqueue.scala 40:17]
    accEnqueuer.io.out[0].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    accEnqueuer.io.out[1].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    accEnqueuer.io.out[2].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    accEnqueuer.io.out[3].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    when io.control.bits.write : @[Accumulator.scala 111:28]
      when io.control.bits.accumulate : @[Accumulator.scala 112:35]
        wire io_control_ready_w : { write : UInt<1>, address : UInt<11>, size : UInt<11>} @[MemControl.scala 67:17]
        io_control_ready_w.address <= io.control.bits.address @[MemControl.scala 68:15]
        io_control_ready_w.write <= UInt<1>("h1") @[MemControl.scala 69:13]
        io_control_ready_w.size <= UInt<1>("h0") @[MemControl.scala 70:12]
        wire io_control_ready_w_1 : { write : UInt<1>, address : UInt<11>, size : UInt<11>} @[MemControl.scala 67:17]
        io_control_ready_w_1.address <= io.control.bits.address @[MemControl.scala 68:15]
        io_control_ready_w_1.write <= UInt<1>("h0") @[MemControl.scala 69:13]
        io_control_ready_w_1.size <= UInt<1>("h0") @[MemControl.scala 70:12]
        accEnqueuer.io.in.valid <= io.control.valid @[MultiEnqueue.scala 150:17]
        wire io_control_ready_portAControl_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<11>, size : UInt<11>}} @[ReadyValid.scala 16:17]
        io_control_ready_portAControl_io_enq_w.bits <= io_control_ready_w @[ReadyValid.scala 17:12]
        io_control_ready_portAControl_io_enq_w.valid <= accEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
        accEnqueuer.io.out[0].ready <= io_control_ready_portAControl_io_enq_w.ready @[ReadyValid.scala 19:11]
        portAControl.io.enq <= io_control_ready_portAControl_io_enq_w @[MultiEnqueue.scala 151:10]
        wire io_control_ready_lockPool_io_actor_1_in_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<11>, size : UInt<11>}} @[ReadyValid.scala 16:17]
        io_control_ready_lockPool_io_actor_1_in_w.bits <= io_control_ready_w_1 @[ReadyValid.scala 17:12]
        io_control_ready_lockPool_io_actor_1_in_w.valid <= accEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
        accEnqueuer.io.out[1].ready <= io_control_ready_lockPool_io_actor_1_in_w.ready @[ReadyValid.scala 19:11]
        lockPool.io.actor[1].in <= io_control_ready_lockPool_io_actor_1_in_w @[MultiEnqueue.scala 152:10]
        wire io_control_ready_inputDemux_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
        io_control_ready_inputDemux_io_enq_w.bits <= UInt<1>("h1") @[ReadyValid.scala 17:12]
        io_control_ready_inputDemux_io_enq_w.valid <= accEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
        accEnqueuer.io.out[2].ready <= io_control_ready_inputDemux_io_enq_w.ready @[ReadyValid.scala 19:11]
        inputDemux.io.enq <= io_control_ready_inputDemux_io_enq_w @[MultiEnqueue.scala 153:10]
        wire io_control_ready_portAInputMux_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
        io_control_ready_portAInputMux_io_enq_w.bits <= UInt<1>("h1") @[ReadyValid.scala 17:12]
        io_control_ready_portAInputMux_io_enq_w.valid <= accEnqueuer.io.out[3].valid @[ReadyValid.scala 18:13]
        accEnqueuer.io.out[3].ready <= io_control_ready_portAInputMux_io_enq_w.ready @[ReadyValid.scala 19:11]
        portAInputMux.io.enq <= io_control_ready_portAInputMux_io_enq_w @[MultiEnqueue.scala 154:10]
        io.control.ready <= accEnqueuer.io.in.ready @[Accumulator.scala 113:21]
      else :
        wire req : { write : UInt<1>, address : UInt<11>, size : UInt<11>} @[MemControl.scala 67:17]
        req.address <= io.control.bits.address @[MemControl.scala 68:15]
        req.write <= UInt<1>("h1") @[MemControl.scala 69:13]
        req.size <= UInt<1>("h0") @[MemControl.scala 70:12]
        wire io_control_ready_w_2 : { cond : { write : UInt<1>, address : UInt<11>, size : UInt<11>}, lock : UInt<0>, acquire : UInt<1>, by : UInt<1>, delayRelease : UInt<4>} @[Accumulator.scala 154:17]
        io_control_ready_w_2.lock <= UInt<1>("h0") @[Accumulator.scala 157:12]
        io_control_ready_w_2.acquire <= UInt<1>("h1") @[Accumulator.scala 158:15]
        io_control_ready_w_2.by <= UInt<1>("h0") @[Accumulator.scala 159:10]
        io_control_ready_w_2.delayRelease <= UInt<1>("h0") @[Accumulator.scala 160:20]
        io_control_ready_w_2.cond <= req @[Accumulator.scala 161:12]
        writeEnqueuer.io.in.valid <= io.control.valid @[MultiEnqueue.scala 150:17]
        wire io_control_ready_portAControl_io_enq_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<11>, size : UInt<11>}} @[ReadyValid.scala 16:17]
        io_control_ready_portAControl_io_enq_w_1.bits <= req @[ReadyValid.scala 17:12]
        io_control_ready_portAControl_io_enq_w_1.valid <= writeEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
        writeEnqueuer.io.out[0].ready <= io_control_ready_portAControl_io_enq_w_1.ready @[ReadyValid.scala 19:11]
        portAControl.io.enq <= io_control_ready_portAControl_io_enq_w_1 @[MultiEnqueue.scala 151:10]
        wire io_control_ready_inputDemux_io_enq_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
        io_control_ready_inputDemux_io_enq_w_1.bits <= UInt<1>("h0") @[ReadyValid.scala 17:12]
        io_control_ready_inputDemux_io_enq_w_1.valid <= writeEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
        writeEnqueuer.io.out[1].ready <= io_control_ready_inputDemux_io_enq_w_1.ready @[ReadyValid.scala 19:11]
        inputDemux.io.enq <= io_control_ready_inputDemux_io_enq_w_1 @[MultiEnqueue.scala 152:10]
        wire io_control_ready_portAInputMux_io_enq_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
        io_control_ready_portAInputMux_io_enq_w_1.bits <= UInt<1>("h0") @[ReadyValid.scala 17:12]
        io_control_ready_portAInputMux_io_enq_w_1.valid <= writeEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
        writeEnqueuer.io.out[2].ready <= io_control_ready_portAInputMux_io_enq_w_1.ready @[ReadyValid.scala 19:11]
        portAInputMux.io.enq <= io_control_ready_portAInputMux_io_enq_w_1 @[MultiEnqueue.scala 153:10]
        wire io_control_ready_lockPool_io_lock_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { cond : { write : UInt<1>, address : UInt<11>, size : UInt<11>}, lock : UInt<0>, acquire : UInt<1>, by : UInt<1>, delayRelease : UInt<4>}} @[ReadyValid.scala 16:17]
        io_control_ready_lockPool_io_lock_w.bits <= io_control_ready_w_2 @[ReadyValid.scala 17:12]
        io_control_ready_lockPool_io_lock_w.valid <= writeEnqueuer.io.out[3].valid @[ReadyValid.scala 18:13]
        writeEnqueuer.io.out[3].ready <= io_control_ready_lockPool_io_lock_w.ready @[ReadyValid.scala 19:11]
        lockPool.io.lock <= io_control_ready_lockPool_io_lock_w @[MultiEnqueue.scala 154:10]
        io.control.ready <= writeEnqueuer.io.in.ready @[Accumulator.scala 129:21]
    else :
      wire io_control_ready_w_3 : { write : UInt<1>, address : UInt<11>, size : UInt<11>} @[MemControl.scala 67:17]
      io_control_ready_w_3.address <= io.control.bits.address @[MemControl.scala 68:15]
      io_control_ready_w_3.write <= UInt<1>("h0") @[MemControl.scala 69:13]
      io_control_ready_w_3.size <= UInt<1>("h0") @[MemControl.scala 70:12]
      readEnqueuer.io.in.valid <= io.control.valid @[MultiEnqueue.scala 60:17]
      wire io_control_ready_portAControl_io_enq_w_2 : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<11>, size : UInt<11>}} @[ReadyValid.scala 16:17]
      io_control_ready_portAControl_io_enq_w_2.bits <= io_control_ready_w_3 @[ReadyValid.scala 17:12]
      io_control_ready_portAControl_io_enq_w_2.valid <= readEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
      readEnqueuer.io.out[0].ready <= io_control_ready_portAControl_io_enq_w_2.ready @[ReadyValid.scala 19:11]
      portAControl.io.enq <= io_control_ready_portAControl_io_enq_w_2 @[MultiEnqueue.scala 61:10]
      io.control.ready <= readEnqueuer.io.in.ready @[Accumulator.scala 143:19]

  module Queue_17 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, count : UInt<2>}

    cmem ram : Fixed<16><<8>>[8] [2] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module ALU :
    input clock : Clock
    input reset : Reset
    output io : { flip op : UInt<4>, flip input : Fixed<16><<8>>, flip sourceLeft : UInt<1>, flip sourceRight : UInt<1>, flip dest : UInt<1>, output : Fixed<16><<8>>}

    reg op : UInt, clock with :
      reset => (UInt<1>("h0"), op) @[ALU.scala 35:42]
    op <= io.op @[ALU.scala 35:42]
    reg input : Fixed<<8>>, clock with :
      reset => (UInt<1>("h0"), input) @[ALU.scala 36:42]
    input <= io.input @[ALU.scala 36:42]
    reg sourceLeftInput : UInt, clock with :
      reset => (UInt<1>("h0"), sourceLeftInput) @[ALU.scala 38:32]
    sourceLeftInput <= io.sourceLeft @[ALU.scala 38:32]
    reg sourceRightInput : UInt, clock with :
      reset => (UInt<1>("h0"), sourceRightInput) @[ALU.scala 40:32]
    sourceRightInput <= io.sourceRight @[ALU.scala 40:32]
    reg destInput : UInt, clock with :
      reset => (UInt<1>("h0"), destInput) @[ALU.scala 41:46]
    destInput <= io.dest @[ALU.scala 41:46]
    wire _reg_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _reg_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _reg_T_1 = asFixedPoint(_reg_T, 8) @[package.scala 74:56]
    _reg_WIRE <= _reg_T_1 @[package.scala 74:56]
    wire _reg_WIRE_1 : Fixed<16><<8>>[1] @[ALU.scala 43:28]
    _reg_WIRE_1[0] <= _reg_WIRE @[ALU.scala 43:28]
    reg reg : Fixed<16><<8>>[1], clock with :
      reset => (reset, _reg_WIRE_1) @[ALU.scala 43:20]
    node _sourceLeft_T = eq(sourceLeftInput, UInt<1>("h0")) @[ALU.scala 45:25]
    node _sourceLeft_T_1 = sub(sourceLeftInput, UInt<1>("h1")) @[ALU.scala 45:61]
    node _sourceLeft_T_2 = tail(_sourceLeft_T_1, 1) @[ALU.scala 45:61]
    node sourceLeft = mux(_sourceLeft_T, input, reg[UInt<1>("h0")]) @[ALU.scala 45:8]
    node _sourceRight_T = eq(sourceRightInput, UInt<1>("h0")) @[ALU.scala 47:26]
    node _sourceRight_T_1 = sub(sourceRightInput, UInt<1>("h1")) @[ALU.scala 47:63]
    node _sourceRight_T_2 = tail(_sourceRight_T_1, 1) @[ALU.scala 47:63]
    node sourceRight = mux(_sourceRight_T, input, reg[UInt<1>("h0")]) @[ALU.scala 47:8]
    node _dest_T = eq(destInput, UInt<1>("h0")) @[ALU.scala 51:17]
    node _dest_T_1 = eq(op, UInt<1>("h0")) @[ALU.scala 51:31]
    node _dest_T_2 = or(_dest_T, _dest_T_1) @[ALU.scala 51:25]
    node _dest_T_3 = sub(destInput, UInt<1>("h1")) @[ALU.scala 53:21]
    node _dest_T_4 = tail(_dest_T_3, 1) @[ALU.scala 53:21]
    wire dest : Fixed<16><<8>> @[Demux.scala 11:21]
    when _dest_T_2 : @[Demux.scala 12:16]
      io.output <= dest @[Demux.scala 13:11]
    else :
      reg[UInt<1>("h0")] <= dest @[Demux.scala 15:11]
    wire result : Fixed<16><<8>> @[ALU.scala 56:20]
    reg output : Fixed<<8>>, clock with :
      reset => (UInt<1>("h0"), output) @[ALU.scala 57:43]
    output <= result @[ALU.scala 57:43]
    io.output <= output @[ALU.scala 58:13]
    dest <= result @[ALU.scala 59:8]
    result <= input @[ALU.scala 62:10]
    node _T = eq(op, UInt<1>("h1")) @[ALU.scala 64:11]
    when _T : @[ALU.scala 64:26]
      wire _result_WIRE : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_1 = asFixedPoint(_result_T, 8) @[package.scala 74:56]
      _result_WIRE <= _result_T_1 @[package.scala 74:56]
      result <= _result_WIRE @[ALU.scala 65:12]
    node _T_1 = eq(op, UInt<2>("h2")) @[ALU.scala 67:11]
    when _T_1 : @[ALU.scala 67:26]
      result <= sourceLeft @[ALU.scala 68:12]
    node _T_2 = eq(op, UInt<2>("h3")) @[ALU.scala 72:11]
    when _T_2 : @[ALU.scala 72:25]
      wire _result_WIRE_1 : Fixed<16><<8>> @[package.scala 82:56]
      node _result_T_2 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
      node _result_T_3 = asFixedPoint(_result_T_2, 8) @[package.scala 82:56]
      _result_WIRE_1 <= _result_T_3 @[package.scala 82:56]
      result <= _result_WIRE_1 @[ALU.scala 73:12]
      wire _WIRE : Fixed<<8>> @[package.scala 74:56]
      node _T_3 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_4 = asFixedPoint(_T_3, 8) @[package.scala 74:56]
      _WIRE <= _T_4 @[package.scala 74:56]
      node _T_5 = geq(sourceLeft, _WIRE) @[ALU.scala 132:45]
      node _T_6 = geq(_WIRE, sourceLeft) @[ALU.scala 132:63]
      node _T_7 = and(_T_5, _T_6) @[ALU.scala 132:54]
      node _T_8 = eq(_T_7, UInt<1>("h0")) @[ALU.scala 131:40]
      when _T_8 : @[ALU.scala 74:30]
        wire _result_WIRE_2 : Fixed<16><<8>> @[package.scala 74:56]
        node _result_T_4 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
        node _result_T_5 = asFixedPoint(_result_T_4, 8) @[package.scala 74:56]
        _result_WIRE_2 <= _result_T_5 @[package.scala 74:56]
        result <= _result_WIRE_2 @[ALU.scala 75:14]
    node _T_9 = eq(op, UInt<3>("h4")) @[ALU.scala 78:11]
    when _T_9 : @[ALU.scala 78:25]
      wire _result_WIRE_3 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_6 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_7 = asFixedPoint(_result_T_6, 8) @[package.scala 74:56]
      _result_WIRE_3 <= _result_T_7 @[package.scala 74:56]
      result <= _result_WIRE_3 @[ALU.scala 79:12]
      wire _WIRE_1 : Fixed<<8>> @[package.scala 74:56]
      node _T_10 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_11 = asFixedPoint(_T_10, 8) @[package.scala 74:56]
      _WIRE_1 <= _T_11 @[package.scala 74:56]
      node _T_12 = geq(sourceLeft, _WIRE_1) @[ALU.scala 132:45]
      node _T_13 = geq(_WIRE_1, sourceLeft) @[ALU.scala 132:63]
      node _T_14 = and(_T_12, _T_13) @[ALU.scala 132:54]
      node _T_15 = eq(_T_14, UInt<1>("h0")) @[ALU.scala 131:40]
      wire _WIRE_2 : Fixed<<8>> @[package.scala 74:56]
      node _T_16 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_17 = asFixedPoint(_T_16, 8) @[package.scala 74:56]
      _WIRE_2 <= _T_17 @[package.scala 74:56]
      node _T_18 = geq(sourceRight, _WIRE_2) @[ALU.scala 132:45]
      node _T_19 = geq(_WIRE_2, sourceRight) @[ALU.scala 132:63]
      node _T_20 = and(_T_18, _T_19) @[ALU.scala 132:54]
      node _T_21 = eq(_T_20, UInt<1>("h0")) @[ALU.scala 131:40]
      node _T_22 = and(_T_15, _T_21) @[ALU.scala 80:29]
      when _T_22 : @[ALU.scala 80:53]
        wire _result_WIRE_4 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_8 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_9 = asFixedPoint(_result_T_8, 8) @[package.scala 82:56]
        _result_WIRE_4 <= _result_T_9 @[package.scala 82:56]
        result <= _result_WIRE_4 @[ALU.scala 81:14]
    node _T_23 = eq(op, UInt<3>("h5")) @[ALU.scala 84:11]
    when _T_23 : @[ALU.scala 84:24]
      wire _result_WIRE_5 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_10 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_11 = asFixedPoint(_result_T_10, 8) @[package.scala 74:56]
      _result_WIRE_5 <= _result_T_11 @[package.scala 74:56]
      result <= _result_WIRE_5 @[ALU.scala 85:12]
      wire _WIRE_3 : Fixed<<8>> @[package.scala 74:56]
      node _T_24 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_25 = asFixedPoint(_T_24, 8) @[package.scala 74:56]
      _WIRE_3 <= _T_25 @[package.scala 74:56]
      node _T_26 = geq(sourceLeft, _WIRE_3) @[ALU.scala 132:45]
      node _T_27 = geq(_WIRE_3, sourceLeft) @[ALU.scala 132:63]
      node _T_28 = and(_T_26, _T_27) @[ALU.scala 132:54]
      node _T_29 = eq(_T_28, UInt<1>("h0")) @[ALU.scala 131:40]
      wire _WIRE_4 : Fixed<<8>> @[package.scala 74:56]
      node _T_30 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_31 = asFixedPoint(_T_30, 8) @[package.scala 74:56]
      _WIRE_4 <= _T_31 @[package.scala 74:56]
      node _T_32 = geq(sourceRight, _WIRE_4) @[ALU.scala 132:45]
      node _T_33 = geq(_WIRE_4, sourceRight) @[ALU.scala 132:63]
      node _T_34 = and(_T_32, _T_33) @[ALU.scala 132:54]
      node _T_35 = eq(_T_34, UInt<1>("h0")) @[ALU.scala 131:40]
      node _T_36 = or(_T_29, _T_35) @[ALU.scala 86:29]
      when _T_36 : @[ALU.scala 86:53]
        wire _result_WIRE_6 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_12 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_13 = asFixedPoint(_result_T_12, 8) @[package.scala 82:56]
        _result_WIRE_6 <= _result_T_13 @[package.scala 82:56]
        result <= _result_WIRE_6 @[ALU.scala 87:14]
    node _T_37 = eq(op, UInt<3>("h6")) @[ALU.scala 92:11]
    when _T_37 : @[ALU.scala 92:31]
      wire _result_WIRE_7 : Fixed<16><<8>> @[package.scala 82:56]
      node _result_T_14 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
      node _result_T_15 = asFixedPoint(_result_T_14, 8) @[package.scala 82:56]
      _result_WIRE_7 <= _result_T_15 @[package.scala 82:56]
      node _result_T_16 = asSInt(sourceLeft) @[package.scala 163:37]
      node _result_T_17 = asSInt(_result_WIRE_7) @[package.scala 163:49]
      node _result_T_18 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T = mul(_result_T_16, _result_T_18) @[package.scala 117:18]
      node _result_mac_T_1 = shl(_result_T_17, 8) @[package.scala 117:29]
      node result_mac = add(_result_mac_T, _result_mac_T_1) @[package.scala 117:23]
      node result_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_1 = sub(_result_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_2 = tail(_result_mask1_T_1, 1) @[package.scala 120:44]
      node result_mask1 = asSInt(_result_mask1_T_2) @[package.scala 120:44]
      node result_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T = and(result_mac, result_mask0) @[package.scala 125:16]
      node _result_adjustment_T_1 = asSInt(_result_adjustment_T) @[package.scala 125:16]
      node _result_adjustment_T_2 = neq(_result_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_3 = and(result_mac, result_mask1) @[package.scala 125:44]
      node _result_adjustment_T_4 = asSInt(_result_adjustment_T_3) @[package.scala 125:44]
      node _result_adjustment_T_5 = neq(_result_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_6 = and(result_mac, result_mask2) @[package.scala 125:71]
      node _result_adjustment_T_7 = asSInt(_result_adjustment_T_6) @[package.scala 125:71]
      node _result_adjustment_T_8 = neq(_result_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_9 = or(_result_adjustment_T_5, _result_adjustment_T_8) @[package.scala 125:62]
      node _result_adjustment_T_10 = and(_result_adjustment_T_2, _result_adjustment_T_9) @[package.scala 125:34]
      node result_adjustment = mux(_result_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T = shr(result_mac, 8) @[package.scala 130:26]
      node _result_adjusted_T_1 = add(_result_adjusted_T, result_adjustment) @[package.scala 130:42]
      node _result_adjusted_T_2 = tail(_result_adjusted_T_1, 1) @[package.scala 130:42]
      node result_adjusted = asSInt(_result_adjusted_T_2) @[package.scala 130:42]
      node _result_saturated_T = gt(result_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_1 = lt(result_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_2 = mux(_result_saturated_T_1, asSInt(UInt<16>("h8000")), result_adjusted) @[package.scala 98:26]
      node result_saturated = mux(_result_saturated_T, asSInt(UInt<16>("h7fff")), _result_saturated_T_2) @[package.scala 98:8]
      node _result_T_19 = asFixedPoint(result_saturated, 8) @[package.scala 133:27]
      result <= _result_T_19 @[ALU.scala 93:12]
    node _T_38 = eq(op, UInt<3>("h7")) @[ALU.scala 95:11]
    when _T_38 : @[ALU.scala 95:31]
      wire _result_WIRE_8 : Fixed<16><<8>> @[package.scala 82:56]
      node _result_T_20 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
      node _result_T_21 = asFixedPoint(_result_T_20, 8) @[package.scala 82:56]
      _result_WIRE_8 <= _result_T_21 @[package.scala 82:56]
      node _result_T_22 = asSInt(sourceLeft) @[package.scala 171:37]
      node _result_T_23 = asSInt(_result_WIRE_8) @[package.scala 171:56]
      node _result_T_24 = sub(asSInt(UInt<1>("h0")), _result_T_23) @[package.scala 171:45]
      node _result_T_25 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T_2 = mul(_result_T_22, _result_T_25) @[package.scala 117:18]
      node _result_mac_T_3 = shl(_result_T_24, 8) @[package.scala 117:29]
      node result_mac_1 = add(_result_mac_T_2, _result_mac_T_3) @[package.scala 117:23]
      node result_mask0_1 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_3 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_4 = sub(_result_mask1_T_3, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_5 = tail(_result_mask1_T_4, 1) @[package.scala 120:44]
      node result_mask1_1 = asSInt(_result_mask1_T_5) @[package.scala 120:44]
      node result_mask2_1 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_11 = and(result_mac_1, result_mask0_1) @[package.scala 125:16]
      node _result_adjustment_T_12 = asSInt(_result_adjustment_T_11) @[package.scala 125:16]
      node _result_adjustment_T_13 = neq(_result_adjustment_T_12, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_14 = and(result_mac_1, result_mask1_1) @[package.scala 125:44]
      node _result_adjustment_T_15 = asSInt(_result_adjustment_T_14) @[package.scala 125:44]
      node _result_adjustment_T_16 = neq(_result_adjustment_T_15, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_17 = and(result_mac_1, result_mask2_1) @[package.scala 125:71]
      node _result_adjustment_T_18 = asSInt(_result_adjustment_T_17) @[package.scala 125:71]
      node _result_adjustment_T_19 = neq(_result_adjustment_T_18, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_20 = or(_result_adjustment_T_16, _result_adjustment_T_19) @[package.scala 125:62]
      node _result_adjustment_T_21 = and(_result_adjustment_T_13, _result_adjustment_T_20) @[package.scala 125:34]
      node result_adjustment_1 = mux(_result_adjustment_T_21, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_3 = shr(result_mac_1, 8) @[package.scala 130:26]
      node _result_adjusted_T_4 = add(_result_adjusted_T_3, result_adjustment_1) @[package.scala 130:42]
      node _result_adjusted_T_5 = tail(_result_adjusted_T_4, 1) @[package.scala 130:42]
      node result_adjusted_1 = asSInt(_result_adjusted_T_5) @[package.scala 130:42]
      node _result_saturated_T_3 = gt(result_adjusted_1, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_4 = lt(result_adjusted_1, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_5 = mux(_result_saturated_T_4, asSInt(UInt<16>("h8000")), result_adjusted_1) @[package.scala 98:26]
      node result_saturated_1 = mux(_result_saturated_T_3, asSInt(UInt<16>("h7fff")), _result_saturated_T_5) @[package.scala 98:8]
      node _result_T_26 = asFixedPoint(result_saturated_1, 8) @[package.scala 133:27]
      result <= _result_T_26 @[ALU.scala 96:12]
    node _T_39 = eq(op, UInt<4>("h8")) @[ALU.scala 98:11]
    when _T_39 : @[ALU.scala 98:25]
      node _result_T_27 = asSInt(sourceLeft) @[package.scala 163:37]
      node _result_T_28 = asSInt(sourceRight) @[package.scala 163:49]
      node _result_T_29 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T_4 = mul(_result_T_27, _result_T_29) @[package.scala 117:18]
      node _result_mac_T_5 = shl(_result_T_28, 8) @[package.scala 117:29]
      node result_mac_2 = add(_result_mac_T_4, _result_mac_T_5) @[package.scala 117:23]
      node result_mask0_2 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_6 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_7 = sub(_result_mask1_T_6, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_8 = tail(_result_mask1_T_7, 1) @[package.scala 120:44]
      node result_mask1_2 = asSInt(_result_mask1_T_8) @[package.scala 120:44]
      node result_mask2_2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_22 = and(result_mac_2, result_mask0_2) @[package.scala 125:16]
      node _result_adjustment_T_23 = asSInt(_result_adjustment_T_22) @[package.scala 125:16]
      node _result_adjustment_T_24 = neq(_result_adjustment_T_23, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_25 = and(result_mac_2, result_mask1_2) @[package.scala 125:44]
      node _result_adjustment_T_26 = asSInt(_result_adjustment_T_25) @[package.scala 125:44]
      node _result_adjustment_T_27 = neq(_result_adjustment_T_26, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_28 = and(result_mac_2, result_mask2_2) @[package.scala 125:71]
      node _result_adjustment_T_29 = asSInt(_result_adjustment_T_28) @[package.scala 125:71]
      node _result_adjustment_T_30 = neq(_result_adjustment_T_29, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_31 = or(_result_adjustment_T_27, _result_adjustment_T_30) @[package.scala 125:62]
      node _result_adjustment_T_32 = and(_result_adjustment_T_24, _result_adjustment_T_31) @[package.scala 125:34]
      node result_adjustment_2 = mux(_result_adjustment_T_32, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_6 = shr(result_mac_2, 8) @[package.scala 130:26]
      node _result_adjusted_T_7 = add(_result_adjusted_T_6, result_adjustment_2) @[package.scala 130:42]
      node _result_adjusted_T_8 = tail(_result_adjusted_T_7, 1) @[package.scala 130:42]
      node result_adjusted_2 = asSInt(_result_adjusted_T_8) @[package.scala 130:42]
      node _result_saturated_T_6 = gt(result_adjusted_2, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_7 = lt(result_adjusted_2, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_8 = mux(_result_saturated_T_7, asSInt(UInt<16>("h8000")), result_adjusted_2) @[package.scala 98:26]
      node result_saturated_2 = mux(_result_saturated_T_6, asSInt(UInt<16>("h7fff")), _result_saturated_T_8) @[package.scala 98:8]
      node _result_T_30 = asFixedPoint(result_saturated_2, 8) @[package.scala 133:27]
      result <= _result_T_30 @[ALU.scala 99:12]
    node _T_40 = eq(op, UInt<4>("h9")) @[ALU.scala 101:11]
    when _T_40 : @[ALU.scala 101:30]
      node _result_T_31 = asSInt(sourceLeft) @[package.scala 171:37]
      node _result_T_32 = asSInt(sourceRight) @[package.scala 171:56]
      node _result_T_33 = sub(asSInt(UInt<1>("h0")), _result_T_32) @[package.scala 171:45]
      node _result_T_34 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T_6 = mul(_result_T_31, _result_T_34) @[package.scala 117:18]
      node _result_mac_T_7 = shl(_result_T_33, 8) @[package.scala 117:29]
      node result_mac_3 = add(_result_mac_T_6, _result_mac_T_7) @[package.scala 117:23]
      node result_mask0_3 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_9 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_10 = sub(_result_mask1_T_9, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_11 = tail(_result_mask1_T_10, 1) @[package.scala 120:44]
      node result_mask1_3 = asSInt(_result_mask1_T_11) @[package.scala 120:44]
      node result_mask2_3 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_33 = and(result_mac_3, result_mask0_3) @[package.scala 125:16]
      node _result_adjustment_T_34 = asSInt(_result_adjustment_T_33) @[package.scala 125:16]
      node _result_adjustment_T_35 = neq(_result_adjustment_T_34, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_36 = and(result_mac_3, result_mask1_3) @[package.scala 125:44]
      node _result_adjustment_T_37 = asSInt(_result_adjustment_T_36) @[package.scala 125:44]
      node _result_adjustment_T_38 = neq(_result_adjustment_T_37, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_39 = and(result_mac_3, result_mask2_3) @[package.scala 125:71]
      node _result_adjustment_T_40 = asSInt(_result_adjustment_T_39) @[package.scala 125:71]
      node _result_adjustment_T_41 = neq(_result_adjustment_T_40, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_42 = or(_result_adjustment_T_38, _result_adjustment_T_41) @[package.scala 125:62]
      node _result_adjustment_T_43 = and(_result_adjustment_T_35, _result_adjustment_T_42) @[package.scala 125:34]
      node result_adjustment_3 = mux(_result_adjustment_T_43, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_9 = shr(result_mac_3, 8) @[package.scala 130:26]
      node _result_adjusted_T_10 = add(_result_adjusted_T_9, result_adjustment_3) @[package.scala 130:42]
      node _result_adjusted_T_11 = tail(_result_adjusted_T_10, 1) @[package.scala 130:42]
      node result_adjusted_3 = asSInt(_result_adjusted_T_11) @[package.scala 130:42]
      node _result_saturated_T_9 = gt(result_adjusted_3, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_10 = lt(result_adjusted_3, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_11 = mux(_result_saturated_T_10, asSInt(UInt<16>("h8000")), result_adjusted_3) @[package.scala 98:26]
      node result_saturated_3 = mux(_result_saturated_T_9, asSInt(UInt<16>("h7fff")), _result_saturated_T_11) @[package.scala 98:8]
      node _result_T_35 = asFixedPoint(result_saturated_3, 8) @[package.scala 133:27]
      result <= _result_T_35 @[ALU.scala 102:12]
    node _T_41 = eq(op, UInt<4>("ha")) @[ALU.scala 104:11]
    when _T_41 : @[ALU.scala 104:30]
      node _result_T_36 = asSInt(sourceLeft) @[package.scala 155:38]
      node _result_T_37 = asSInt(sourceRight) @[package.scala 155:50]
      node _result_mac_T_8 = mul(_result_T_36, _result_T_37) @[package.scala 117:18]
      node _result_mac_T_9 = shl(asSInt(UInt<1>("h0")), 8) @[package.scala 117:29]
      node result_mac_4 = add(_result_mac_T_8, _result_mac_T_9) @[package.scala 117:23]
      node result_mask0_4 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_12 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_13 = sub(_result_mask1_T_12, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_14 = tail(_result_mask1_T_13, 1) @[package.scala 120:44]
      node result_mask1_4 = asSInt(_result_mask1_T_14) @[package.scala 120:44]
      node result_mask2_4 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_44 = and(result_mac_4, result_mask0_4) @[package.scala 125:16]
      node _result_adjustment_T_45 = asSInt(_result_adjustment_T_44) @[package.scala 125:16]
      node _result_adjustment_T_46 = neq(_result_adjustment_T_45, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_47 = and(result_mac_4, result_mask1_4) @[package.scala 125:44]
      node _result_adjustment_T_48 = asSInt(_result_adjustment_T_47) @[package.scala 125:44]
      node _result_adjustment_T_49 = neq(_result_adjustment_T_48, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_50 = and(result_mac_4, result_mask2_4) @[package.scala 125:71]
      node _result_adjustment_T_51 = asSInt(_result_adjustment_T_50) @[package.scala 125:71]
      node _result_adjustment_T_52 = neq(_result_adjustment_T_51, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_53 = or(_result_adjustment_T_49, _result_adjustment_T_52) @[package.scala 125:62]
      node _result_adjustment_T_54 = and(_result_adjustment_T_46, _result_adjustment_T_53) @[package.scala 125:34]
      node result_adjustment_4 = mux(_result_adjustment_T_54, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_12 = shr(result_mac_4, 8) @[package.scala 130:26]
      node _result_adjusted_T_13 = add(_result_adjusted_T_12, result_adjustment_4) @[package.scala 130:42]
      node _result_adjusted_T_14 = tail(_result_adjusted_T_13, 1) @[package.scala 130:42]
      node result_adjusted_4 = asSInt(_result_adjusted_T_14) @[package.scala 130:42]
      node _result_saturated_T_12 = gt(result_adjusted_4, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_13 = lt(result_adjusted_4, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_14 = mux(_result_saturated_T_13, asSInt(UInt<16>("h8000")), result_adjusted_4) @[package.scala 98:26]
      node result_saturated_4 = mux(_result_saturated_T_12, asSInt(UInt<16>("h7fff")), _result_saturated_T_14) @[package.scala 98:8]
      node _result_T_38 = asFixedPoint(result_saturated_4, 8) @[package.scala 133:27]
      result <= _result_T_38 @[ALU.scala 105:12]
    node _T_42 = eq(op, UInt<4>("hb")) @[ALU.scala 107:11]
    when _T_42 : @[ALU.scala 107:25]
      node _result_T_39 = lt(sourceLeft, asFixedPoint(UInt<1>("h0"), 0)) @[ALU.scala 108:26]
      node _result_T_40 = sub(asFixedPoint(UInt<1>("h0"), 0), sourceLeft) @[ALU.scala 108:26]
      node _result_T_41 = tail(_result_T_40, 1) @[ALU.scala 108:26]
      node _result_T_42 = asFixedPoint(_result_T_41, 8) @[ALU.scala 108:26]
      node _result_T_43 = mux(_result_T_39, _result_T_42, sourceLeft) @[ALU.scala 108:26]
      result <= _result_T_43 @[ALU.scala 108:12]
    node _T_43 = eq(op, UInt<4>("hc")) @[ALU.scala 112:11]
    when _T_43 : @[ALU.scala 112:33]
      wire _result_WIRE_9 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_44 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_45 = asFixedPoint(_result_T_44, 8) @[package.scala 74:56]
      _result_WIRE_9 <= _result_T_45 @[package.scala 74:56]
      result <= _result_WIRE_9 @[ALU.scala 113:12]
      node _T_44 = gt(sourceLeft, sourceRight) @[ALU.scala 114:21]
      when _T_44 : @[ALU.scala 114:36]
        wire _result_WIRE_10 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_46 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_47 = asFixedPoint(_result_T_46, 8) @[package.scala 82:56]
        _result_WIRE_10 <= _result_T_47 @[package.scala 82:56]
        result <= _result_WIRE_10 @[ALU.scala 115:14]
    node _T_45 = eq(op, UInt<4>("hd")) @[ALU.scala 118:11]
    when _T_45 : @[ALU.scala 118:38]
      wire _result_WIRE_11 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_48 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_49 = asFixedPoint(_result_T_48, 8) @[package.scala 74:56]
      _result_WIRE_11 <= _result_T_49 @[package.scala 74:56]
      result <= _result_WIRE_11 @[ALU.scala 119:12]
      node _T_46 = geq(sourceLeft, sourceRight) @[ALU.scala 120:21]
      when _T_46 : @[ALU.scala 120:37]
        wire _result_WIRE_12 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_50 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_51 = asFixedPoint(_result_T_50, 8) @[package.scala 82:56]
        _result_WIRE_12 <= _result_T_51 @[package.scala 82:56]
        result <= _result_WIRE_12 @[ALU.scala 121:14]
    node _T_47 = eq(op, UInt<4>("he")) @[ALU.scala 124:11]
    when _T_47 : @[ALU.scala 124:25]
      node _result_T_52 = lt(sourceLeft, sourceRight) @[ALU.scala 125:29]
      node _result_T_53 = mux(_result_T_52, sourceLeft, sourceRight) @[ALU.scala 125:29]
      result <= _result_T_53 @[ALU.scala 125:12]
    node _T_48 = eq(op, UInt<4>("hf")) @[ALU.scala 127:11]
    when _T_48 : @[ALU.scala 127:25]
      node _result_T_54 = lt(sourceLeft, sourceRight) @[ALU.scala 128:29]
      node _result_T_55 = mux(_result_T_54, sourceRight, sourceLeft) @[ALU.scala 128:29]
      result <= _result_T_55 @[ALU.scala 128:12]

  module ALU_1 :
    input clock : Clock
    input reset : Reset
    output io : { flip op : UInt<4>, flip input : Fixed<16><<8>>, flip sourceLeft : UInt<1>, flip sourceRight : UInt<1>, flip dest : UInt<1>, output : Fixed<16><<8>>}

    reg op : UInt, clock with :
      reset => (UInt<1>("h0"), op) @[ALU.scala 35:42]
    op <= io.op @[ALU.scala 35:42]
    reg input : Fixed<<8>>, clock with :
      reset => (UInt<1>("h0"), input) @[ALU.scala 36:42]
    input <= io.input @[ALU.scala 36:42]
    reg sourceLeftInput : UInt, clock with :
      reset => (UInt<1>("h0"), sourceLeftInput) @[ALU.scala 38:32]
    sourceLeftInput <= io.sourceLeft @[ALU.scala 38:32]
    reg sourceRightInput : UInt, clock with :
      reset => (UInt<1>("h0"), sourceRightInput) @[ALU.scala 40:32]
    sourceRightInput <= io.sourceRight @[ALU.scala 40:32]
    reg destInput : UInt, clock with :
      reset => (UInt<1>("h0"), destInput) @[ALU.scala 41:46]
    destInput <= io.dest @[ALU.scala 41:46]
    wire _reg_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _reg_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _reg_T_1 = asFixedPoint(_reg_T, 8) @[package.scala 74:56]
    _reg_WIRE <= _reg_T_1 @[package.scala 74:56]
    wire _reg_WIRE_1 : Fixed<16><<8>>[1] @[ALU.scala 43:28]
    _reg_WIRE_1[0] <= _reg_WIRE @[ALU.scala 43:28]
    reg reg : Fixed<16><<8>>[1], clock with :
      reset => (reset, _reg_WIRE_1) @[ALU.scala 43:20]
    node _sourceLeft_T = eq(sourceLeftInput, UInt<1>("h0")) @[ALU.scala 45:25]
    node _sourceLeft_T_1 = sub(sourceLeftInput, UInt<1>("h1")) @[ALU.scala 45:61]
    node _sourceLeft_T_2 = tail(_sourceLeft_T_1, 1) @[ALU.scala 45:61]
    node sourceLeft = mux(_sourceLeft_T, input, reg[UInt<1>("h0")]) @[ALU.scala 45:8]
    node _sourceRight_T = eq(sourceRightInput, UInt<1>("h0")) @[ALU.scala 47:26]
    node _sourceRight_T_1 = sub(sourceRightInput, UInt<1>("h1")) @[ALU.scala 47:63]
    node _sourceRight_T_2 = tail(_sourceRight_T_1, 1) @[ALU.scala 47:63]
    node sourceRight = mux(_sourceRight_T, input, reg[UInt<1>("h0")]) @[ALU.scala 47:8]
    node _dest_T = eq(destInput, UInt<1>("h0")) @[ALU.scala 51:17]
    node _dest_T_1 = eq(op, UInt<1>("h0")) @[ALU.scala 51:31]
    node _dest_T_2 = or(_dest_T, _dest_T_1) @[ALU.scala 51:25]
    node _dest_T_3 = sub(destInput, UInt<1>("h1")) @[ALU.scala 53:21]
    node _dest_T_4 = tail(_dest_T_3, 1) @[ALU.scala 53:21]
    wire dest : Fixed<16><<8>> @[Demux.scala 11:21]
    when _dest_T_2 : @[Demux.scala 12:16]
      io.output <= dest @[Demux.scala 13:11]
    else :
      reg[UInt<1>("h0")] <= dest @[Demux.scala 15:11]
    wire result : Fixed<16><<8>> @[ALU.scala 56:20]
    reg output : Fixed<<8>>, clock with :
      reset => (UInt<1>("h0"), output) @[ALU.scala 57:43]
    output <= result @[ALU.scala 57:43]
    io.output <= output @[ALU.scala 58:13]
    dest <= result @[ALU.scala 59:8]
    result <= input @[ALU.scala 62:10]
    node _T = eq(op, UInt<1>("h1")) @[ALU.scala 64:11]
    when _T : @[ALU.scala 64:26]
      wire _result_WIRE : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_1 = asFixedPoint(_result_T, 8) @[package.scala 74:56]
      _result_WIRE <= _result_T_1 @[package.scala 74:56]
      result <= _result_WIRE @[ALU.scala 65:12]
    node _T_1 = eq(op, UInt<2>("h2")) @[ALU.scala 67:11]
    when _T_1 : @[ALU.scala 67:26]
      result <= sourceLeft @[ALU.scala 68:12]
    node _T_2 = eq(op, UInt<2>("h3")) @[ALU.scala 72:11]
    when _T_2 : @[ALU.scala 72:25]
      wire _result_WIRE_1 : Fixed<16><<8>> @[package.scala 82:56]
      node _result_T_2 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
      node _result_T_3 = asFixedPoint(_result_T_2, 8) @[package.scala 82:56]
      _result_WIRE_1 <= _result_T_3 @[package.scala 82:56]
      result <= _result_WIRE_1 @[ALU.scala 73:12]
      wire _WIRE : Fixed<<8>> @[package.scala 74:56]
      node _T_3 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_4 = asFixedPoint(_T_3, 8) @[package.scala 74:56]
      _WIRE <= _T_4 @[package.scala 74:56]
      node _T_5 = geq(sourceLeft, _WIRE) @[ALU.scala 132:45]
      node _T_6 = geq(_WIRE, sourceLeft) @[ALU.scala 132:63]
      node _T_7 = and(_T_5, _T_6) @[ALU.scala 132:54]
      node _T_8 = eq(_T_7, UInt<1>("h0")) @[ALU.scala 131:40]
      when _T_8 : @[ALU.scala 74:30]
        wire _result_WIRE_2 : Fixed<16><<8>> @[package.scala 74:56]
        node _result_T_4 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
        node _result_T_5 = asFixedPoint(_result_T_4, 8) @[package.scala 74:56]
        _result_WIRE_2 <= _result_T_5 @[package.scala 74:56]
        result <= _result_WIRE_2 @[ALU.scala 75:14]
    node _T_9 = eq(op, UInt<3>("h4")) @[ALU.scala 78:11]
    when _T_9 : @[ALU.scala 78:25]
      wire _result_WIRE_3 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_6 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_7 = asFixedPoint(_result_T_6, 8) @[package.scala 74:56]
      _result_WIRE_3 <= _result_T_7 @[package.scala 74:56]
      result <= _result_WIRE_3 @[ALU.scala 79:12]
      wire _WIRE_1 : Fixed<<8>> @[package.scala 74:56]
      node _T_10 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_11 = asFixedPoint(_T_10, 8) @[package.scala 74:56]
      _WIRE_1 <= _T_11 @[package.scala 74:56]
      node _T_12 = geq(sourceLeft, _WIRE_1) @[ALU.scala 132:45]
      node _T_13 = geq(_WIRE_1, sourceLeft) @[ALU.scala 132:63]
      node _T_14 = and(_T_12, _T_13) @[ALU.scala 132:54]
      node _T_15 = eq(_T_14, UInt<1>("h0")) @[ALU.scala 131:40]
      wire _WIRE_2 : Fixed<<8>> @[package.scala 74:56]
      node _T_16 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_17 = asFixedPoint(_T_16, 8) @[package.scala 74:56]
      _WIRE_2 <= _T_17 @[package.scala 74:56]
      node _T_18 = geq(sourceRight, _WIRE_2) @[ALU.scala 132:45]
      node _T_19 = geq(_WIRE_2, sourceRight) @[ALU.scala 132:63]
      node _T_20 = and(_T_18, _T_19) @[ALU.scala 132:54]
      node _T_21 = eq(_T_20, UInt<1>("h0")) @[ALU.scala 131:40]
      node _T_22 = and(_T_15, _T_21) @[ALU.scala 80:29]
      when _T_22 : @[ALU.scala 80:53]
        wire _result_WIRE_4 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_8 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_9 = asFixedPoint(_result_T_8, 8) @[package.scala 82:56]
        _result_WIRE_4 <= _result_T_9 @[package.scala 82:56]
        result <= _result_WIRE_4 @[ALU.scala 81:14]
    node _T_23 = eq(op, UInt<3>("h5")) @[ALU.scala 84:11]
    when _T_23 : @[ALU.scala 84:24]
      wire _result_WIRE_5 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_10 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_11 = asFixedPoint(_result_T_10, 8) @[package.scala 74:56]
      _result_WIRE_5 <= _result_T_11 @[package.scala 74:56]
      result <= _result_WIRE_5 @[ALU.scala 85:12]
      wire _WIRE_3 : Fixed<<8>> @[package.scala 74:56]
      node _T_24 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_25 = asFixedPoint(_T_24, 8) @[package.scala 74:56]
      _WIRE_3 <= _T_25 @[package.scala 74:56]
      node _T_26 = geq(sourceLeft, _WIRE_3) @[ALU.scala 132:45]
      node _T_27 = geq(_WIRE_3, sourceLeft) @[ALU.scala 132:63]
      node _T_28 = and(_T_26, _T_27) @[ALU.scala 132:54]
      node _T_29 = eq(_T_28, UInt<1>("h0")) @[ALU.scala 131:40]
      wire _WIRE_4 : Fixed<<8>> @[package.scala 74:56]
      node _T_30 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_31 = asFixedPoint(_T_30, 8) @[package.scala 74:56]
      _WIRE_4 <= _T_31 @[package.scala 74:56]
      node _T_32 = geq(sourceRight, _WIRE_4) @[ALU.scala 132:45]
      node _T_33 = geq(_WIRE_4, sourceRight) @[ALU.scala 132:63]
      node _T_34 = and(_T_32, _T_33) @[ALU.scala 132:54]
      node _T_35 = eq(_T_34, UInt<1>("h0")) @[ALU.scala 131:40]
      node _T_36 = or(_T_29, _T_35) @[ALU.scala 86:29]
      when _T_36 : @[ALU.scala 86:53]
        wire _result_WIRE_6 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_12 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_13 = asFixedPoint(_result_T_12, 8) @[package.scala 82:56]
        _result_WIRE_6 <= _result_T_13 @[package.scala 82:56]
        result <= _result_WIRE_6 @[ALU.scala 87:14]
    node _T_37 = eq(op, UInt<3>("h6")) @[ALU.scala 92:11]
    when _T_37 : @[ALU.scala 92:31]
      wire _result_WIRE_7 : Fixed<16><<8>> @[package.scala 82:56]
      node _result_T_14 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
      node _result_T_15 = asFixedPoint(_result_T_14, 8) @[package.scala 82:56]
      _result_WIRE_7 <= _result_T_15 @[package.scala 82:56]
      node _result_T_16 = asSInt(sourceLeft) @[package.scala 163:37]
      node _result_T_17 = asSInt(_result_WIRE_7) @[package.scala 163:49]
      node _result_T_18 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T = mul(_result_T_16, _result_T_18) @[package.scala 117:18]
      node _result_mac_T_1 = shl(_result_T_17, 8) @[package.scala 117:29]
      node result_mac = add(_result_mac_T, _result_mac_T_1) @[package.scala 117:23]
      node result_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_1 = sub(_result_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_2 = tail(_result_mask1_T_1, 1) @[package.scala 120:44]
      node result_mask1 = asSInt(_result_mask1_T_2) @[package.scala 120:44]
      node result_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T = and(result_mac, result_mask0) @[package.scala 125:16]
      node _result_adjustment_T_1 = asSInt(_result_adjustment_T) @[package.scala 125:16]
      node _result_adjustment_T_2 = neq(_result_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_3 = and(result_mac, result_mask1) @[package.scala 125:44]
      node _result_adjustment_T_4 = asSInt(_result_adjustment_T_3) @[package.scala 125:44]
      node _result_adjustment_T_5 = neq(_result_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_6 = and(result_mac, result_mask2) @[package.scala 125:71]
      node _result_adjustment_T_7 = asSInt(_result_adjustment_T_6) @[package.scala 125:71]
      node _result_adjustment_T_8 = neq(_result_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_9 = or(_result_adjustment_T_5, _result_adjustment_T_8) @[package.scala 125:62]
      node _result_adjustment_T_10 = and(_result_adjustment_T_2, _result_adjustment_T_9) @[package.scala 125:34]
      node result_adjustment = mux(_result_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T = shr(result_mac, 8) @[package.scala 130:26]
      node _result_adjusted_T_1 = add(_result_adjusted_T, result_adjustment) @[package.scala 130:42]
      node _result_adjusted_T_2 = tail(_result_adjusted_T_1, 1) @[package.scala 130:42]
      node result_adjusted = asSInt(_result_adjusted_T_2) @[package.scala 130:42]
      node _result_saturated_T = gt(result_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_1 = lt(result_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_2 = mux(_result_saturated_T_1, asSInt(UInt<16>("h8000")), result_adjusted) @[package.scala 98:26]
      node result_saturated = mux(_result_saturated_T, asSInt(UInt<16>("h7fff")), _result_saturated_T_2) @[package.scala 98:8]
      node _result_T_19 = asFixedPoint(result_saturated, 8) @[package.scala 133:27]
      result <= _result_T_19 @[ALU.scala 93:12]
    node _T_38 = eq(op, UInt<3>("h7")) @[ALU.scala 95:11]
    when _T_38 : @[ALU.scala 95:31]
      wire _result_WIRE_8 : Fixed<16><<8>> @[package.scala 82:56]
      node _result_T_20 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
      node _result_T_21 = asFixedPoint(_result_T_20, 8) @[package.scala 82:56]
      _result_WIRE_8 <= _result_T_21 @[package.scala 82:56]
      node _result_T_22 = asSInt(sourceLeft) @[package.scala 171:37]
      node _result_T_23 = asSInt(_result_WIRE_8) @[package.scala 171:56]
      node _result_T_24 = sub(asSInt(UInt<1>("h0")), _result_T_23) @[package.scala 171:45]
      node _result_T_25 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T_2 = mul(_result_T_22, _result_T_25) @[package.scala 117:18]
      node _result_mac_T_3 = shl(_result_T_24, 8) @[package.scala 117:29]
      node result_mac_1 = add(_result_mac_T_2, _result_mac_T_3) @[package.scala 117:23]
      node result_mask0_1 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_3 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_4 = sub(_result_mask1_T_3, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_5 = tail(_result_mask1_T_4, 1) @[package.scala 120:44]
      node result_mask1_1 = asSInt(_result_mask1_T_5) @[package.scala 120:44]
      node result_mask2_1 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_11 = and(result_mac_1, result_mask0_1) @[package.scala 125:16]
      node _result_adjustment_T_12 = asSInt(_result_adjustment_T_11) @[package.scala 125:16]
      node _result_adjustment_T_13 = neq(_result_adjustment_T_12, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_14 = and(result_mac_1, result_mask1_1) @[package.scala 125:44]
      node _result_adjustment_T_15 = asSInt(_result_adjustment_T_14) @[package.scala 125:44]
      node _result_adjustment_T_16 = neq(_result_adjustment_T_15, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_17 = and(result_mac_1, result_mask2_1) @[package.scala 125:71]
      node _result_adjustment_T_18 = asSInt(_result_adjustment_T_17) @[package.scala 125:71]
      node _result_adjustment_T_19 = neq(_result_adjustment_T_18, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_20 = or(_result_adjustment_T_16, _result_adjustment_T_19) @[package.scala 125:62]
      node _result_adjustment_T_21 = and(_result_adjustment_T_13, _result_adjustment_T_20) @[package.scala 125:34]
      node result_adjustment_1 = mux(_result_adjustment_T_21, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_3 = shr(result_mac_1, 8) @[package.scala 130:26]
      node _result_adjusted_T_4 = add(_result_adjusted_T_3, result_adjustment_1) @[package.scala 130:42]
      node _result_adjusted_T_5 = tail(_result_adjusted_T_4, 1) @[package.scala 130:42]
      node result_adjusted_1 = asSInt(_result_adjusted_T_5) @[package.scala 130:42]
      node _result_saturated_T_3 = gt(result_adjusted_1, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_4 = lt(result_adjusted_1, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_5 = mux(_result_saturated_T_4, asSInt(UInt<16>("h8000")), result_adjusted_1) @[package.scala 98:26]
      node result_saturated_1 = mux(_result_saturated_T_3, asSInt(UInt<16>("h7fff")), _result_saturated_T_5) @[package.scala 98:8]
      node _result_T_26 = asFixedPoint(result_saturated_1, 8) @[package.scala 133:27]
      result <= _result_T_26 @[ALU.scala 96:12]
    node _T_39 = eq(op, UInt<4>("h8")) @[ALU.scala 98:11]
    when _T_39 : @[ALU.scala 98:25]
      node _result_T_27 = asSInt(sourceLeft) @[package.scala 163:37]
      node _result_T_28 = asSInt(sourceRight) @[package.scala 163:49]
      node _result_T_29 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T_4 = mul(_result_T_27, _result_T_29) @[package.scala 117:18]
      node _result_mac_T_5 = shl(_result_T_28, 8) @[package.scala 117:29]
      node result_mac_2 = add(_result_mac_T_4, _result_mac_T_5) @[package.scala 117:23]
      node result_mask0_2 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_6 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_7 = sub(_result_mask1_T_6, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_8 = tail(_result_mask1_T_7, 1) @[package.scala 120:44]
      node result_mask1_2 = asSInt(_result_mask1_T_8) @[package.scala 120:44]
      node result_mask2_2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_22 = and(result_mac_2, result_mask0_2) @[package.scala 125:16]
      node _result_adjustment_T_23 = asSInt(_result_adjustment_T_22) @[package.scala 125:16]
      node _result_adjustment_T_24 = neq(_result_adjustment_T_23, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_25 = and(result_mac_2, result_mask1_2) @[package.scala 125:44]
      node _result_adjustment_T_26 = asSInt(_result_adjustment_T_25) @[package.scala 125:44]
      node _result_adjustment_T_27 = neq(_result_adjustment_T_26, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_28 = and(result_mac_2, result_mask2_2) @[package.scala 125:71]
      node _result_adjustment_T_29 = asSInt(_result_adjustment_T_28) @[package.scala 125:71]
      node _result_adjustment_T_30 = neq(_result_adjustment_T_29, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_31 = or(_result_adjustment_T_27, _result_adjustment_T_30) @[package.scala 125:62]
      node _result_adjustment_T_32 = and(_result_adjustment_T_24, _result_adjustment_T_31) @[package.scala 125:34]
      node result_adjustment_2 = mux(_result_adjustment_T_32, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_6 = shr(result_mac_2, 8) @[package.scala 130:26]
      node _result_adjusted_T_7 = add(_result_adjusted_T_6, result_adjustment_2) @[package.scala 130:42]
      node _result_adjusted_T_8 = tail(_result_adjusted_T_7, 1) @[package.scala 130:42]
      node result_adjusted_2 = asSInt(_result_adjusted_T_8) @[package.scala 130:42]
      node _result_saturated_T_6 = gt(result_adjusted_2, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_7 = lt(result_adjusted_2, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_8 = mux(_result_saturated_T_7, asSInt(UInt<16>("h8000")), result_adjusted_2) @[package.scala 98:26]
      node result_saturated_2 = mux(_result_saturated_T_6, asSInt(UInt<16>("h7fff")), _result_saturated_T_8) @[package.scala 98:8]
      node _result_T_30 = asFixedPoint(result_saturated_2, 8) @[package.scala 133:27]
      result <= _result_T_30 @[ALU.scala 99:12]
    node _T_40 = eq(op, UInt<4>("h9")) @[ALU.scala 101:11]
    when _T_40 : @[ALU.scala 101:30]
      node _result_T_31 = asSInt(sourceLeft) @[package.scala 171:37]
      node _result_T_32 = asSInt(sourceRight) @[package.scala 171:56]
      node _result_T_33 = sub(asSInt(UInt<1>("h0")), _result_T_32) @[package.scala 171:45]
      node _result_T_34 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T_6 = mul(_result_T_31, _result_T_34) @[package.scala 117:18]
      node _result_mac_T_7 = shl(_result_T_33, 8) @[package.scala 117:29]
      node result_mac_3 = add(_result_mac_T_6, _result_mac_T_7) @[package.scala 117:23]
      node result_mask0_3 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_9 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_10 = sub(_result_mask1_T_9, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_11 = tail(_result_mask1_T_10, 1) @[package.scala 120:44]
      node result_mask1_3 = asSInt(_result_mask1_T_11) @[package.scala 120:44]
      node result_mask2_3 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_33 = and(result_mac_3, result_mask0_3) @[package.scala 125:16]
      node _result_adjustment_T_34 = asSInt(_result_adjustment_T_33) @[package.scala 125:16]
      node _result_adjustment_T_35 = neq(_result_adjustment_T_34, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_36 = and(result_mac_3, result_mask1_3) @[package.scala 125:44]
      node _result_adjustment_T_37 = asSInt(_result_adjustment_T_36) @[package.scala 125:44]
      node _result_adjustment_T_38 = neq(_result_adjustment_T_37, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_39 = and(result_mac_3, result_mask2_3) @[package.scala 125:71]
      node _result_adjustment_T_40 = asSInt(_result_adjustment_T_39) @[package.scala 125:71]
      node _result_adjustment_T_41 = neq(_result_adjustment_T_40, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_42 = or(_result_adjustment_T_38, _result_adjustment_T_41) @[package.scala 125:62]
      node _result_adjustment_T_43 = and(_result_adjustment_T_35, _result_adjustment_T_42) @[package.scala 125:34]
      node result_adjustment_3 = mux(_result_adjustment_T_43, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_9 = shr(result_mac_3, 8) @[package.scala 130:26]
      node _result_adjusted_T_10 = add(_result_adjusted_T_9, result_adjustment_3) @[package.scala 130:42]
      node _result_adjusted_T_11 = tail(_result_adjusted_T_10, 1) @[package.scala 130:42]
      node result_adjusted_3 = asSInt(_result_adjusted_T_11) @[package.scala 130:42]
      node _result_saturated_T_9 = gt(result_adjusted_3, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_10 = lt(result_adjusted_3, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_11 = mux(_result_saturated_T_10, asSInt(UInt<16>("h8000")), result_adjusted_3) @[package.scala 98:26]
      node result_saturated_3 = mux(_result_saturated_T_9, asSInt(UInt<16>("h7fff")), _result_saturated_T_11) @[package.scala 98:8]
      node _result_T_35 = asFixedPoint(result_saturated_3, 8) @[package.scala 133:27]
      result <= _result_T_35 @[ALU.scala 102:12]
    node _T_41 = eq(op, UInt<4>("ha")) @[ALU.scala 104:11]
    when _T_41 : @[ALU.scala 104:30]
      node _result_T_36 = asSInt(sourceLeft) @[package.scala 155:38]
      node _result_T_37 = asSInt(sourceRight) @[package.scala 155:50]
      node _result_mac_T_8 = mul(_result_T_36, _result_T_37) @[package.scala 117:18]
      node _result_mac_T_9 = shl(asSInt(UInt<1>("h0")), 8) @[package.scala 117:29]
      node result_mac_4 = add(_result_mac_T_8, _result_mac_T_9) @[package.scala 117:23]
      node result_mask0_4 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_12 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_13 = sub(_result_mask1_T_12, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_14 = tail(_result_mask1_T_13, 1) @[package.scala 120:44]
      node result_mask1_4 = asSInt(_result_mask1_T_14) @[package.scala 120:44]
      node result_mask2_4 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_44 = and(result_mac_4, result_mask0_4) @[package.scala 125:16]
      node _result_adjustment_T_45 = asSInt(_result_adjustment_T_44) @[package.scala 125:16]
      node _result_adjustment_T_46 = neq(_result_adjustment_T_45, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_47 = and(result_mac_4, result_mask1_4) @[package.scala 125:44]
      node _result_adjustment_T_48 = asSInt(_result_adjustment_T_47) @[package.scala 125:44]
      node _result_adjustment_T_49 = neq(_result_adjustment_T_48, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_50 = and(result_mac_4, result_mask2_4) @[package.scala 125:71]
      node _result_adjustment_T_51 = asSInt(_result_adjustment_T_50) @[package.scala 125:71]
      node _result_adjustment_T_52 = neq(_result_adjustment_T_51, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_53 = or(_result_adjustment_T_49, _result_adjustment_T_52) @[package.scala 125:62]
      node _result_adjustment_T_54 = and(_result_adjustment_T_46, _result_adjustment_T_53) @[package.scala 125:34]
      node result_adjustment_4 = mux(_result_adjustment_T_54, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_12 = shr(result_mac_4, 8) @[package.scala 130:26]
      node _result_adjusted_T_13 = add(_result_adjusted_T_12, result_adjustment_4) @[package.scala 130:42]
      node _result_adjusted_T_14 = tail(_result_adjusted_T_13, 1) @[package.scala 130:42]
      node result_adjusted_4 = asSInt(_result_adjusted_T_14) @[package.scala 130:42]
      node _result_saturated_T_12 = gt(result_adjusted_4, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_13 = lt(result_adjusted_4, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_14 = mux(_result_saturated_T_13, asSInt(UInt<16>("h8000")), result_adjusted_4) @[package.scala 98:26]
      node result_saturated_4 = mux(_result_saturated_T_12, asSInt(UInt<16>("h7fff")), _result_saturated_T_14) @[package.scala 98:8]
      node _result_T_38 = asFixedPoint(result_saturated_4, 8) @[package.scala 133:27]
      result <= _result_T_38 @[ALU.scala 105:12]
    node _T_42 = eq(op, UInt<4>("hb")) @[ALU.scala 107:11]
    when _T_42 : @[ALU.scala 107:25]
      node _result_T_39 = lt(sourceLeft, asFixedPoint(UInt<1>("h0"), 0)) @[ALU.scala 108:26]
      node _result_T_40 = sub(asFixedPoint(UInt<1>("h0"), 0), sourceLeft) @[ALU.scala 108:26]
      node _result_T_41 = tail(_result_T_40, 1) @[ALU.scala 108:26]
      node _result_T_42 = asFixedPoint(_result_T_41, 8) @[ALU.scala 108:26]
      node _result_T_43 = mux(_result_T_39, _result_T_42, sourceLeft) @[ALU.scala 108:26]
      result <= _result_T_43 @[ALU.scala 108:12]
    node _T_43 = eq(op, UInt<4>("hc")) @[ALU.scala 112:11]
    when _T_43 : @[ALU.scala 112:33]
      wire _result_WIRE_9 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_44 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_45 = asFixedPoint(_result_T_44, 8) @[package.scala 74:56]
      _result_WIRE_9 <= _result_T_45 @[package.scala 74:56]
      result <= _result_WIRE_9 @[ALU.scala 113:12]
      node _T_44 = gt(sourceLeft, sourceRight) @[ALU.scala 114:21]
      when _T_44 : @[ALU.scala 114:36]
        wire _result_WIRE_10 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_46 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_47 = asFixedPoint(_result_T_46, 8) @[package.scala 82:56]
        _result_WIRE_10 <= _result_T_47 @[package.scala 82:56]
        result <= _result_WIRE_10 @[ALU.scala 115:14]
    node _T_45 = eq(op, UInt<4>("hd")) @[ALU.scala 118:11]
    when _T_45 : @[ALU.scala 118:38]
      wire _result_WIRE_11 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_48 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_49 = asFixedPoint(_result_T_48, 8) @[package.scala 74:56]
      _result_WIRE_11 <= _result_T_49 @[package.scala 74:56]
      result <= _result_WIRE_11 @[ALU.scala 119:12]
      node _T_46 = geq(sourceLeft, sourceRight) @[ALU.scala 120:21]
      when _T_46 : @[ALU.scala 120:37]
        wire _result_WIRE_12 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_50 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_51 = asFixedPoint(_result_T_50, 8) @[package.scala 82:56]
        _result_WIRE_12 <= _result_T_51 @[package.scala 82:56]
        result <= _result_WIRE_12 @[ALU.scala 121:14]
    node _T_47 = eq(op, UInt<4>("he")) @[ALU.scala 124:11]
    when _T_47 : @[ALU.scala 124:25]
      node _result_T_52 = lt(sourceLeft, sourceRight) @[ALU.scala 125:29]
      node _result_T_53 = mux(_result_T_52, sourceLeft, sourceRight) @[ALU.scala 125:29]
      result <= _result_T_53 @[ALU.scala 125:12]
    node _T_48 = eq(op, UInt<4>("hf")) @[ALU.scala 127:11]
    when _T_48 : @[ALU.scala 127:25]
      node _result_T_54 = lt(sourceLeft, sourceRight) @[ALU.scala 128:29]
      node _result_T_55 = mux(_result_T_54, sourceRight, sourceLeft) @[ALU.scala 128:29]
      result <= _result_T_55 @[ALU.scala 128:12]

  module ALU_2 :
    input clock : Clock
    input reset : Reset
    output io : { flip op : UInt<4>, flip input : Fixed<16><<8>>, flip sourceLeft : UInt<1>, flip sourceRight : UInt<1>, flip dest : UInt<1>, output : Fixed<16><<8>>}

    reg op : UInt, clock with :
      reset => (UInt<1>("h0"), op) @[ALU.scala 35:42]
    op <= io.op @[ALU.scala 35:42]
    reg input : Fixed<<8>>, clock with :
      reset => (UInt<1>("h0"), input) @[ALU.scala 36:42]
    input <= io.input @[ALU.scala 36:42]
    reg sourceLeftInput : UInt, clock with :
      reset => (UInt<1>("h0"), sourceLeftInput) @[ALU.scala 38:32]
    sourceLeftInput <= io.sourceLeft @[ALU.scala 38:32]
    reg sourceRightInput : UInt, clock with :
      reset => (UInt<1>("h0"), sourceRightInput) @[ALU.scala 40:32]
    sourceRightInput <= io.sourceRight @[ALU.scala 40:32]
    reg destInput : UInt, clock with :
      reset => (UInt<1>("h0"), destInput) @[ALU.scala 41:46]
    destInput <= io.dest @[ALU.scala 41:46]
    wire _reg_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _reg_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _reg_T_1 = asFixedPoint(_reg_T, 8) @[package.scala 74:56]
    _reg_WIRE <= _reg_T_1 @[package.scala 74:56]
    wire _reg_WIRE_1 : Fixed<16><<8>>[1] @[ALU.scala 43:28]
    _reg_WIRE_1[0] <= _reg_WIRE @[ALU.scala 43:28]
    reg reg : Fixed<16><<8>>[1], clock with :
      reset => (reset, _reg_WIRE_1) @[ALU.scala 43:20]
    node _sourceLeft_T = eq(sourceLeftInput, UInt<1>("h0")) @[ALU.scala 45:25]
    node _sourceLeft_T_1 = sub(sourceLeftInput, UInt<1>("h1")) @[ALU.scala 45:61]
    node _sourceLeft_T_2 = tail(_sourceLeft_T_1, 1) @[ALU.scala 45:61]
    node sourceLeft = mux(_sourceLeft_T, input, reg[UInt<1>("h0")]) @[ALU.scala 45:8]
    node _sourceRight_T = eq(sourceRightInput, UInt<1>("h0")) @[ALU.scala 47:26]
    node _sourceRight_T_1 = sub(sourceRightInput, UInt<1>("h1")) @[ALU.scala 47:63]
    node _sourceRight_T_2 = tail(_sourceRight_T_1, 1) @[ALU.scala 47:63]
    node sourceRight = mux(_sourceRight_T, input, reg[UInt<1>("h0")]) @[ALU.scala 47:8]
    node _dest_T = eq(destInput, UInt<1>("h0")) @[ALU.scala 51:17]
    node _dest_T_1 = eq(op, UInt<1>("h0")) @[ALU.scala 51:31]
    node _dest_T_2 = or(_dest_T, _dest_T_1) @[ALU.scala 51:25]
    node _dest_T_3 = sub(destInput, UInt<1>("h1")) @[ALU.scala 53:21]
    node _dest_T_4 = tail(_dest_T_3, 1) @[ALU.scala 53:21]
    wire dest : Fixed<16><<8>> @[Demux.scala 11:21]
    when _dest_T_2 : @[Demux.scala 12:16]
      io.output <= dest @[Demux.scala 13:11]
    else :
      reg[UInt<1>("h0")] <= dest @[Demux.scala 15:11]
    wire result : Fixed<16><<8>> @[ALU.scala 56:20]
    reg output : Fixed<<8>>, clock with :
      reset => (UInt<1>("h0"), output) @[ALU.scala 57:43]
    output <= result @[ALU.scala 57:43]
    io.output <= output @[ALU.scala 58:13]
    dest <= result @[ALU.scala 59:8]
    result <= input @[ALU.scala 62:10]
    node _T = eq(op, UInt<1>("h1")) @[ALU.scala 64:11]
    when _T : @[ALU.scala 64:26]
      wire _result_WIRE : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_1 = asFixedPoint(_result_T, 8) @[package.scala 74:56]
      _result_WIRE <= _result_T_1 @[package.scala 74:56]
      result <= _result_WIRE @[ALU.scala 65:12]
    node _T_1 = eq(op, UInt<2>("h2")) @[ALU.scala 67:11]
    when _T_1 : @[ALU.scala 67:26]
      result <= sourceLeft @[ALU.scala 68:12]
    node _T_2 = eq(op, UInt<2>("h3")) @[ALU.scala 72:11]
    when _T_2 : @[ALU.scala 72:25]
      wire _result_WIRE_1 : Fixed<16><<8>> @[package.scala 82:56]
      node _result_T_2 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
      node _result_T_3 = asFixedPoint(_result_T_2, 8) @[package.scala 82:56]
      _result_WIRE_1 <= _result_T_3 @[package.scala 82:56]
      result <= _result_WIRE_1 @[ALU.scala 73:12]
      wire _WIRE : Fixed<<8>> @[package.scala 74:56]
      node _T_3 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_4 = asFixedPoint(_T_3, 8) @[package.scala 74:56]
      _WIRE <= _T_4 @[package.scala 74:56]
      node _T_5 = geq(sourceLeft, _WIRE) @[ALU.scala 132:45]
      node _T_6 = geq(_WIRE, sourceLeft) @[ALU.scala 132:63]
      node _T_7 = and(_T_5, _T_6) @[ALU.scala 132:54]
      node _T_8 = eq(_T_7, UInt<1>("h0")) @[ALU.scala 131:40]
      when _T_8 : @[ALU.scala 74:30]
        wire _result_WIRE_2 : Fixed<16><<8>> @[package.scala 74:56]
        node _result_T_4 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
        node _result_T_5 = asFixedPoint(_result_T_4, 8) @[package.scala 74:56]
        _result_WIRE_2 <= _result_T_5 @[package.scala 74:56]
        result <= _result_WIRE_2 @[ALU.scala 75:14]
    node _T_9 = eq(op, UInt<3>("h4")) @[ALU.scala 78:11]
    when _T_9 : @[ALU.scala 78:25]
      wire _result_WIRE_3 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_6 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_7 = asFixedPoint(_result_T_6, 8) @[package.scala 74:56]
      _result_WIRE_3 <= _result_T_7 @[package.scala 74:56]
      result <= _result_WIRE_3 @[ALU.scala 79:12]
      wire _WIRE_1 : Fixed<<8>> @[package.scala 74:56]
      node _T_10 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_11 = asFixedPoint(_T_10, 8) @[package.scala 74:56]
      _WIRE_1 <= _T_11 @[package.scala 74:56]
      node _T_12 = geq(sourceLeft, _WIRE_1) @[ALU.scala 132:45]
      node _T_13 = geq(_WIRE_1, sourceLeft) @[ALU.scala 132:63]
      node _T_14 = and(_T_12, _T_13) @[ALU.scala 132:54]
      node _T_15 = eq(_T_14, UInt<1>("h0")) @[ALU.scala 131:40]
      wire _WIRE_2 : Fixed<<8>> @[package.scala 74:56]
      node _T_16 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_17 = asFixedPoint(_T_16, 8) @[package.scala 74:56]
      _WIRE_2 <= _T_17 @[package.scala 74:56]
      node _T_18 = geq(sourceRight, _WIRE_2) @[ALU.scala 132:45]
      node _T_19 = geq(_WIRE_2, sourceRight) @[ALU.scala 132:63]
      node _T_20 = and(_T_18, _T_19) @[ALU.scala 132:54]
      node _T_21 = eq(_T_20, UInt<1>("h0")) @[ALU.scala 131:40]
      node _T_22 = and(_T_15, _T_21) @[ALU.scala 80:29]
      when _T_22 : @[ALU.scala 80:53]
        wire _result_WIRE_4 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_8 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_9 = asFixedPoint(_result_T_8, 8) @[package.scala 82:56]
        _result_WIRE_4 <= _result_T_9 @[package.scala 82:56]
        result <= _result_WIRE_4 @[ALU.scala 81:14]
    node _T_23 = eq(op, UInt<3>("h5")) @[ALU.scala 84:11]
    when _T_23 : @[ALU.scala 84:24]
      wire _result_WIRE_5 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_10 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_11 = asFixedPoint(_result_T_10, 8) @[package.scala 74:56]
      _result_WIRE_5 <= _result_T_11 @[package.scala 74:56]
      result <= _result_WIRE_5 @[ALU.scala 85:12]
      wire _WIRE_3 : Fixed<<8>> @[package.scala 74:56]
      node _T_24 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_25 = asFixedPoint(_T_24, 8) @[package.scala 74:56]
      _WIRE_3 <= _T_25 @[package.scala 74:56]
      node _T_26 = geq(sourceLeft, _WIRE_3) @[ALU.scala 132:45]
      node _T_27 = geq(_WIRE_3, sourceLeft) @[ALU.scala 132:63]
      node _T_28 = and(_T_26, _T_27) @[ALU.scala 132:54]
      node _T_29 = eq(_T_28, UInt<1>("h0")) @[ALU.scala 131:40]
      wire _WIRE_4 : Fixed<<8>> @[package.scala 74:56]
      node _T_30 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_31 = asFixedPoint(_T_30, 8) @[package.scala 74:56]
      _WIRE_4 <= _T_31 @[package.scala 74:56]
      node _T_32 = geq(sourceRight, _WIRE_4) @[ALU.scala 132:45]
      node _T_33 = geq(_WIRE_4, sourceRight) @[ALU.scala 132:63]
      node _T_34 = and(_T_32, _T_33) @[ALU.scala 132:54]
      node _T_35 = eq(_T_34, UInt<1>("h0")) @[ALU.scala 131:40]
      node _T_36 = or(_T_29, _T_35) @[ALU.scala 86:29]
      when _T_36 : @[ALU.scala 86:53]
        wire _result_WIRE_6 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_12 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_13 = asFixedPoint(_result_T_12, 8) @[package.scala 82:56]
        _result_WIRE_6 <= _result_T_13 @[package.scala 82:56]
        result <= _result_WIRE_6 @[ALU.scala 87:14]
    node _T_37 = eq(op, UInt<3>("h6")) @[ALU.scala 92:11]
    when _T_37 : @[ALU.scala 92:31]
      wire _result_WIRE_7 : Fixed<16><<8>> @[package.scala 82:56]
      node _result_T_14 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
      node _result_T_15 = asFixedPoint(_result_T_14, 8) @[package.scala 82:56]
      _result_WIRE_7 <= _result_T_15 @[package.scala 82:56]
      node _result_T_16 = asSInt(sourceLeft) @[package.scala 163:37]
      node _result_T_17 = asSInt(_result_WIRE_7) @[package.scala 163:49]
      node _result_T_18 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T = mul(_result_T_16, _result_T_18) @[package.scala 117:18]
      node _result_mac_T_1 = shl(_result_T_17, 8) @[package.scala 117:29]
      node result_mac = add(_result_mac_T, _result_mac_T_1) @[package.scala 117:23]
      node result_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_1 = sub(_result_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_2 = tail(_result_mask1_T_1, 1) @[package.scala 120:44]
      node result_mask1 = asSInt(_result_mask1_T_2) @[package.scala 120:44]
      node result_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T = and(result_mac, result_mask0) @[package.scala 125:16]
      node _result_adjustment_T_1 = asSInt(_result_adjustment_T) @[package.scala 125:16]
      node _result_adjustment_T_2 = neq(_result_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_3 = and(result_mac, result_mask1) @[package.scala 125:44]
      node _result_adjustment_T_4 = asSInt(_result_adjustment_T_3) @[package.scala 125:44]
      node _result_adjustment_T_5 = neq(_result_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_6 = and(result_mac, result_mask2) @[package.scala 125:71]
      node _result_adjustment_T_7 = asSInt(_result_adjustment_T_6) @[package.scala 125:71]
      node _result_adjustment_T_8 = neq(_result_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_9 = or(_result_adjustment_T_5, _result_adjustment_T_8) @[package.scala 125:62]
      node _result_adjustment_T_10 = and(_result_adjustment_T_2, _result_adjustment_T_9) @[package.scala 125:34]
      node result_adjustment = mux(_result_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T = shr(result_mac, 8) @[package.scala 130:26]
      node _result_adjusted_T_1 = add(_result_adjusted_T, result_adjustment) @[package.scala 130:42]
      node _result_adjusted_T_2 = tail(_result_adjusted_T_1, 1) @[package.scala 130:42]
      node result_adjusted = asSInt(_result_adjusted_T_2) @[package.scala 130:42]
      node _result_saturated_T = gt(result_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_1 = lt(result_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_2 = mux(_result_saturated_T_1, asSInt(UInt<16>("h8000")), result_adjusted) @[package.scala 98:26]
      node result_saturated = mux(_result_saturated_T, asSInt(UInt<16>("h7fff")), _result_saturated_T_2) @[package.scala 98:8]
      node _result_T_19 = asFixedPoint(result_saturated, 8) @[package.scala 133:27]
      result <= _result_T_19 @[ALU.scala 93:12]
    node _T_38 = eq(op, UInt<3>("h7")) @[ALU.scala 95:11]
    when _T_38 : @[ALU.scala 95:31]
      wire _result_WIRE_8 : Fixed<16><<8>> @[package.scala 82:56]
      node _result_T_20 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
      node _result_T_21 = asFixedPoint(_result_T_20, 8) @[package.scala 82:56]
      _result_WIRE_8 <= _result_T_21 @[package.scala 82:56]
      node _result_T_22 = asSInt(sourceLeft) @[package.scala 171:37]
      node _result_T_23 = asSInt(_result_WIRE_8) @[package.scala 171:56]
      node _result_T_24 = sub(asSInt(UInt<1>("h0")), _result_T_23) @[package.scala 171:45]
      node _result_T_25 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T_2 = mul(_result_T_22, _result_T_25) @[package.scala 117:18]
      node _result_mac_T_3 = shl(_result_T_24, 8) @[package.scala 117:29]
      node result_mac_1 = add(_result_mac_T_2, _result_mac_T_3) @[package.scala 117:23]
      node result_mask0_1 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_3 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_4 = sub(_result_mask1_T_3, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_5 = tail(_result_mask1_T_4, 1) @[package.scala 120:44]
      node result_mask1_1 = asSInt(_result_mask1_T_5) @[package.scala 120:44]
      node result_mask2_1 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_11 = and(result_mac_1, result_mask0_1) @[package.scala 125:16]
      node _result_adjustment_T_12 = asSInt(_result_adjustment_T_11) @[package.scala 125:16]
      node _result_adjustment_T_13 = neq(_result_adjustment_T_12, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_14 = and(result_mac_1, result_mask1_1) @[package.scala 125:44]
      node _result_adjustment_T_15 = asSInt(_result_adjustment_T_14) @[package.scala 125:44]
      node _result_adjustment_T_16 = neq(_result_adjustment_T_15, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_17 = and(result_mac_1, result_mask2_1) @[package.scala 125:71]
      node _result_adjustment_T_18 = asSInt(_result_adjustment_T_17) @[package.scala 125:71]
      node _result_adjustment_T_19 = neq(_result_adjustment_T_18, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_20 = or(_result_adjustment_T_16, _result_adjustment_T_19) @[package.scala 125:62]
      node _result_adjustment_T_21 = and(_result_adjustment_T_13, _result_adjustment_T_20) @[package.scala 125:34]
      node result_adjustment_1 = mux(_result_adjustment_T_21, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_3 = shr(result_mac_1, 8) @[package.scala 130:26]
      node _result_adjusted_T_4 = add(_result_adjusted_T_3, result_adjustment_1) @[package.scala 130:42]
      node _result_adjusted_T_5 = tail(_result_adjusted_T_4, 1) @[package.scala 130:42]
      node result_adjusted_1 = asSInt(_result_adjusted_T_5) @[package.scala 130:42]
      node _result_saturated_T_3 = gt(result_adjusted_1, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_4 = lt(result_adjusted_1, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_5 = mux(_result_saturated_T_4, asSInt(UInt<16>("h8000")), result_adjusted_1) @[package.scala 98:26]
      node result_saturated_1 = mux(_result_saturated_T_3, asSInt(UInt<16>("h7fff")), _result_saturated_T_5) @[package.scala 98:8]
      node _result_T_26 = asFixedPoint(result_saturated_1, 8) @[package.scala 133:27]
      result <= _result_T_26 @[ALU.scala 96:12]
    node _T_39 = eq(op, UInt<4>("h8")) @[ALU.scala 98:11]
    when _T_39 : @[ALU.scala 98:25]
      node _result_T_27 = asSInt(sourceLeft) @[package.scala 163:37]
      node _result_T_28 = asSInt(sourceRight) @[package.scala 163:49]
      node _result_T_29 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T_4 = mul(_result_T_27, _result_T_29) @[package.scala 117:18]
      node _result_mac_T_5 = shl(_result_T_28, 8) @[package.scala 117:29]
      node result_mac_2 = add(_result_mac_T_4, _result_mac_T_5) @[package.scala 117:23]
      node result_mask0_2 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_6 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_7 = sub(_result_mask1_T_6, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_8 = tail(_result_mask1_T_7, 1) @[package.scala 120:44]
      node result_mask1_2 = asSInt(_result_mask1_T_8) @[package.scala 120:44]
      node result_mask2_2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_22 = and(result_mac_2, result_mask0_2) @[package.scala 125:16]
      node _result_adjustment_T_23 = asSInt(_result_adjustment_T_22) @[package.scala 125:16]
      node _result_adjustment_T_24 = neq(_result_adjustment_T_23, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_25 = and(result_mac_2, result_mask1_2) @[package.scala 125:44]
      node _result_adjustment_T_26 = asSInt(_result_adjustment_T_25) @[package.scala 125:44]
      node _result_adjustment_T_27 = neq(_result_adjustment_T_26, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_28 = and(result_mac_2, result_mask2_2) @[package.scala 125:71]
      node _result_adjustment_T_29 = asSInt(_result_adjustment_T_28) @[package.scala 125:71]
      node _result_adjustment_T_30 = neq(_result_adjustment_T_29, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_31 = or(_result_adjustment_T_27, _result_adjustment_T_30) @[package.scala 125:62]
      node _result_adjustment_T_32 = and(_result_adjustment_T_24, _result_adjustment_T_31) @[package.scala 125:34]
      node result_adjustment_2 = mux(_result_adjustment_T_32, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_6 = shr(result_mac_2, 8) @[package.scala 130:26]
      node _result_adjusted_T_7 = add(_result_adjusted_T_6, result_adjustment_2) @[package.scala 130:42]
      node _result_adjusted_T_8 = tail(_result_adjusted_T_7, 1) @[package.scala 130:42]
      node result_adjusted_2 = asSInt(_result_adjusted_T_8) @[package.scala 130:42]
      node _result_saturated_T_6 = gt(result_adjusted_2, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_7 = lt(result_adjusted_2, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_8 = mux(_result_saturated_T_7, asSInt(UInt<16>("h8000")), result_adjusted_2) @[package.scala 98:26]
      node result_saturated_2 = mux(_result_saturated_T_6, asSInt(UInt<16>("h7fff")), _result_saturated_T_8) @[package.scala 98:8]
      node _result_T_30 = asFixedPoint(result_saturated_2, 8) @[package.scala 133:27]
      result <= _result_T_30 @[ALU.scala 99:12]
    node _T_40 = eq(op, UInt<4>("h9")) @[ALU.scala 101:11]
    when _T_40 : @[ALU.scala 101:30]
      node _result_T_31 = asSInt(sourceLeft) @[package.scala 171:37]
      node _result_T_32 = asSInt(sourceRight) @[package.scala 171:56]
      node _result_T_33 = sub(asSInt(UInt<1>("h0")), _result_T_32) @[package.scala 171:45]
      node _result_T_34 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T_6 = mul(_result_T_31, _result_T_34) @[package.scala 117:18]
      node _result_mac_T_7 = shl(_result_T_33, 8) @[package.scala 117:29]
      node result_mac_3 = add(_result_mac_T_6, _result_mac_T_7) @[package.scala 117:23]
      node result_mask0_3 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_9 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_10 = sub(_result_mask1_T_9, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_11 = tail(_result_mask1_T_10, 1) @[package.scala 120:44]
      node result_mask1_3 = asSInt(_result_mask1_T_11) @[package.scala 120:44]
      node result_mask2_3 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_33 = and(result_mac_3, result_mask0_3) @[package.scala 125:16]
      node _result_adjustment_T_34 = asSInt(_result_adjustment_T_33) @[package.scala 125:16]
      node _result_adjustment_T_35 = neq(_result_adjustment_T_34, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_36 = and(result_mac_3, result_mask1_3) @[package.scala 125:44]
      node _result_adjustment_T_37 = asSInt(_result_adjustment_T_36) @[package.scala 125:44]
      node _result_adjustment_T_38 = neq(_result_adjustment_T_37, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_39 = and(result_mac_3, result_mask2_3) @[package.scala 125:71]
      node _result_adjustment_T_40 = asSInt(_result_adjustment_T_39) @[package.scala 125:71]
      node _result_adjustment_T_41 = neq(_result_adjustment_T_40, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_42 = or(_result_adjustment_T_38, _result_adjustment_T_41) @[package.scala 125:62]
      node _result_adjustment_T_43 = and(_result_adjustment_T_35, _result_adjustment_T_42) @[package.scala 125:34]
      node result_adjustment_3 = mux(_result_adjustment_T_43, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_9 = shr(result_mac_3, 8) @[package.scala 130:26]
      node _result_adjusted_T_10 = add(_result_adjusted_T_9, result_adjustment_3) @[package.scala 130:42]
      node _result_adjusted_T_11 = tail(_result_adjusted_T_10, 1) @[package.scala 130:42]
      node result_adjusted_3 = asSInt(_result_adjusted_T_11) @[package.scala 130:42]
      node _result_saturated_T_9 = gt(result_adjusted_3, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_10 = lt(result_adjusted_3, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_11 = mux(_result_saturated_T_10, asSInt(UInt<16>("h8000")), result_adjusted_3) @[package.scala 98:26]
      node result_saturated_3 = mux(_result_saturated_T_9, asSInt(UInt<16>("h7fff")), _result_saturated_T_11) @[package.scala 98:8]
      node _result_T_35 = asFixedPoint(result_saturated_3, 8) @[package.scala 133:27]
      result <= _result_T_35 @[ALU.scala 102:12]
    node _T_41 = eq(op, UInt<4>("ha")) @[ALU.scala 104:11]
    when _T_41 : @[ALU.scala 104:30]
      node _result_T_36 = asSInt(sourceLeft) @[package.scala 155:38]
      node _result_T_37 = asSInt(sourceRight) @[package.scala 155:50]
      node _result_mac_T_8 = mul(_result_T_36, _result_T_37) @[package.scala 117:18]
      node _result_mac_T_9 = shl(asSInt(UInt<1>("h0")), 8) @[package.scala 117:29]
      node result_mac_4 = add(_result_mac_T_8, _result_mac_T_9) @[package.scala 117:23]
      node result_mask0_4 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_12 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_13 = sub(_result_mask1_T_12, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_14 = tail(_result_mask1_T_13, 1) @[package.scala 120:44]
      node result_mask1_4 = asSInt(_result_mask1_T_14) @[package.scala 120:44]
      node result_mask2_4 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_44 = and(result_mac_4, result_mask0_4) @[package.scala 125:16]
      node _result_adjustment_T_45 = asSInt(_result_adjustment_T_44) @[package.scala 125:16]
      node _result_adjustment_T_46 = neq(_result_adjustment_T_45, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_47 = and(result_mac_4, result_mask1_4) @[package.scala 125:44]
      node _result_adjustment_T_48 = asSInt(_result_adjustment_T_47) @[package.scala 125:44]
      node _result_adjustment_T_49 = neq(_result_adjustment_T_48, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_50 = and(result_mac_4, result_mask2_4) @[package.scala 125:71]
      node _result_adjustment_T_51 = asSInt(_result_adjustment_T_50) @[package.scala 125:71]
      node _result_adjustment_T_52 = neq(_result_adjustment_T_51, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_53 = or(_result_adjustment_T_49, _result_adjustment_T_52) @[package.scala 125:62]
      node _result_adjustment_T_54 = and(_result_adjustment_T_46, _result_adjustment_T_53) @[package.scala 125:34]
      node result_adjustment_4 = mux(_result_adjustment_T_54, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_12 = shr(result_mac_4, 8) @[package.scala 130:26]
      node _result_adjusted_T_13 = add(_result_adjusted_T_12, result_adjustment_4) @[package.scala 130:42]
      node _result_adjusted_T_14 = tail(_result_adjusted_T_13, 1) @[package.scala 130:42]
      node result_adjusted_4 = asSInt(_result_adjusted_T_14) @[package.scala 130:42]
      node _result_saturated_T_12 = gt(result_adjusted_4, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_13 = lt(result_adjusted_4, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_14 = mux(_result_saturated_T_13, asSInt(UInt<16>("h8000")), result_adjusted_4) @[package.scala 98:26]
      node result_saturated_4 = mux(_result_saturated_T_12, asSInt(UInt<16>("h7fff")), _result_saturated_T_14) @[package.scala 98:8]
      node _result_T_38 = asFixedPoint(result_saturated_4, 8) @[package.scala 133:27]
      result <= _result_T_38 @[ALU.scala 105:12]
    node _T_42 = eq(op, UInt<4>("hb")) @[ALU.scala 107:11]
    when _T_42 : @[ALU.scala 107:25]
      node _result_T_39 = lt(sourceLeft, asFixedPoint(UInt<1>("h0"), 0)) @[ALU.scala 108:26]
      node _result_T_40 = sub(asFixedPoint(UInt<1>("h0"), 0), sourceLeft) @[ALU.scala 108:26]
      node _result_T_41 = tail(_result_T_40, 1) @[ALU.scala 108:26]
      node _result_T_42 = asFixedPoint(_result_T_41, 8) @[ALU.scala 108:26]
      node _result_T_43 = mux(_result_T_39, _result_T_42, sourceLeft) @[ALU.scala 108:26]
      result <= _result_T_43 @[ALU.scala 108:12]
    node _T_43 = eq(op, UInt<4>("hc")) @[ALU.scala 112:11]
    when _T_43 : @[ALU.scala 112:33]
      wire _result_WIRE_9 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_44 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_45 = asFixedPoint(_result_T_44, 8) @[package.scala 74:56]
      _result_WIRE_9 <= _result_T_45 @[package.scala 74:56]
      result <= _result_WIRE_9 @[ALU.scala 113:12]
      node _T_44 = gt(sourceLeft, sourceRight) @[ALU.scala 114:21]
      when _T_44 : @[ALU.scala 114:36]
        wire _result_WIRE_10 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_46 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_47 = asFixedPoint(_result_T_46, 8) @[package.scala 82:56]
        _result_WIRE_10 <= _result_T_47 @[package.scala 82:56]
        result <= _result_WIRE_10 @[ALU.scala 115:14]
    node _T_45 = eq(op, UInt<4>("hd")) @[ALU.scala 118:11]
    when _T_45 : @[ALU.scala 118:38]
      wire _result_WIRE_11 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_48 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_49 = asFixedPoint(_result_T_48, 8) @[package.scala 74:56]
      _result_WIRE_11 <= _result_T_49 @[package.scala 74:56]
      result <= _result_WIRE_11 @[ALU.scala 119:12]
      node _T_46 = geq(sourceLeft, sourceRight) @[ALU.scala 120:21]
      when _T_46 : @[ALU.scala 120:37]
        wire _result_WIRE_12 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_50 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_51 = asFixedPoint(_result_T_50, 8) @[package.scala 82:56]
        _result_WIRE_12 <= _result_T_51 @[package.scala 82:56]
        result <= _result_WIRE_12 @[ALU.scala 121:14]
    node _T_47 = eq(op, UInt<4>("he")) @[ALU.scala 124:11]
    when _T_47 : @[ALU.scala 124:25]
      node _result_T_52 = lt(sourceLeft, sourceRight) @[ALU.scala 125:29]
      node _result_T_53 = mux(_result_T_52, sourceLeft, sourceRight) @[ALU.scala 125:29]
      result <= _result_T_53 @[ALU.scala 125:12]
    node _T_48 = eq(op, UInt<4>("hf")) @[ALU.scala 127:11]
    when _T_48 : @[ALU.scala 127:25]
      node _result_T_54 = lt(sourceLeft, sourceRight) @[ALU.scala 128:29]
      node _result_T_55 = mux(_result_T_54, sourceRight, sourceLeft) @[ALU.scala 128:29]
      result <= _result_T_55 @[ALU.scala 128:12]

  module ALU_3 :
    input clock : Clock
    input reset : Reset
    output io : { flip op : UInt<4>, flip input : Fixed<16><<8>>, flip sourceLeft : UInt<1>, flip sourceRight : UInt<1>, flip dest : UInt<1>, output : Fixed<16><<8>>}

    reg op : UInt, clock with :
      reset => (UInt<1>("h0"), op) @[ALU.scala 35:42]
    op <= io.op @[ALU.scala 35:42]
    reg input : Fixed<<8>>, clock with :
      reset => (UInt<1>("h0"), input) @[ALU.scala 36:42]
    input <= io.input @[ALU.scala 36:42]
    reg sourceLeftInput : UInt, clock with :
      reset => (UInt<1>("h0"), sourceLeftInput) @[ALU.scala 38:32]
    sourceLeftInput <= io.sourceLeft @[ALU.scala 38:32]
    reg sourceRightInput : UInt, clock with :
      reset => (UInt<1>("h0"), sourceRightInput) @[ALU.scala 40:32]
    sourceRightInput <= io.sourceRight @[ALU.scala 40:32]
    reg destInput : UInt, clock with :
      reset => (UInt<1>("h0"), destInput) @[ALU.scala 41:46]
    destInput <= io.dest @[ALU.scala 41:46]
    wire _reg_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _reg_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _reg_T_1 = asFixedPoint(_reg_T, 8) @[package.scala 74:56]
    _reg_WIRE <= _reg_T_1 @[package.scala 74:56]
    wire _reg_WIRE_1 : Fixed<16><<8>>[1] @[ALU.scala 43:28]
    _reg_WIRE_1[0] <= _reg_WIRE @[ALU.scala 43:28]
    reg reg : Fixed<16><<8>>[1], clock with :
      reset => (reset, _reg_WIRE_1) @[ALU.scala 43:20]
    node _sourceLeft_T = eq(sourceLeftInput, UInt<1>("h0")) @[ALU.scala 45:25]
    node _sourceLeft_T_1 = sub(sourceLeftInput, UInt<1>("h1")) @[ALU.scala 45:61]
    node _sourceLeft_T_2 = tail(_sourceLeft_T_1, 1) @[ALU.scala 45:61]
    node sourceLeft = mux(_sourceLeft_T, input, reg[UInt<1>("h0")]) @[ALU.scala 45:8]
    node _sourceRight_T = eq(sourceRightInput, UInt<1>("h0")) @[ALU.scala 47:26]
    node _sourceRight_T_1 = sub(sourceRightInput, UInt<1>("h1")) @[ALU.scala 47:63]
    node _sourceRight_T_2 = tail(_sourceRight_T_1, 1) @[ALU.scala 47:63]
    node sourceRight = mux(_sourceRight_T, input, reg[UInt<1>("h0")]) @[ALU.scala 47:8]
    node _dest_T = eq(destInput, UInt<1>("h0")) @[ALU.scala 51:17]
    node _dest_T_1 = eq(op, UInt<1>("h0")) @[ALU.scala 51:31]
    node _dest_T_2 = or(_dest_T, _dest_T_1) @[ALU.scala 51:25]
    node _dest_T_3 = sub(destInput, UInt<1>("h1")) @[ALU.scala 53:21]
    node _dest_T_4 = tail(_dest_T_3, 1) @[ALU.scala 53:21]
    wire dest : Fixed<16><<8>> @[Demux.scala 11:21]
    when _dest_T_2 : @[Demux.scala 12:16]
      io.output <= dest @[Demux.scala 13:11]
    else :
      reg[UInt<1>("h0")] <= dest @[Demux.scala 15:11]
    wire result : Fixed<16><<8>> @[ALU.scala 56:20]
    reg output : Fixed<<8>>, clock with :
      reset => (UInt<1>("h0"), output) @[ALU.scala 57:43]
    output <= result @[ALU.scala 57:43]
    io.output <= output @[ALU.scala 58:13]
    dest <= result @[ALU.scala 59:8]
    result <= input @[ALU.scala 62:10]
    node _T = eq(op, UInt<1>("h1")) @[ALU.scala 64:11]
    when _T : @[ALU.scala 64:26]
      wire _result_WIRE : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_1 = asFixedPoint(_result_T, 8) @[package.scala 74:56]
      _result_WIRE <= _result_T_1 @[package.scala 74:56]
      result <= _result_WIRE @[ALU.scala 65:12]
    node _T_1 = eq(op, UInt<2>("h2")) @[ALU.scala 67:11]
    when _T_1 : @[ALU.scala 67:26]
      result <= sourceLeft @[ALU.scala 68:12]
    node _T_2 = eq(op, UInt<2>("h3")) @[ALU.scala 72:11]
    when _T_2 : @[ALU.scala 72:25]
      wire _result_WIRE_1 : Fixed<16><<8>> @[package.scala 82:56]
      node _result_T_2 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
      node _result_T_3 = asFixedPoint(_result_T_2, 8) @[package.scala 82:56]
      _result_WIRE_1 <= _result_T_3 @[package.scala 82:56]
      result <= _result_WIRE_1 @[ALU.scala 73:12]
      wire _WIRE : Fixed<<8>> @[package.scala 74:56]
      node _T_3 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_4 = asFixedPoint(_T_3, 8) @[package.scala 74:56]
      _WIRE <= _T_4 @[package.scala 74:56]
      node _T_5 = geq(sourceLeft, _WIRE) @[ALU.scala 132:45]
      node _T_6 = geq(_WIRE, sourceLeft) @[ALU.scala 132:63]
      node _T_7 = and(_T_5, _T_6) @[ALU.scala 132:54]
      node _T_8 = eq(_T_7, UInt<1>("h0")) @[ALU.scala 131:40]
      when _T_8 : @[ALU.scala 74:30]
        wire _result_WIRE_2 : Fixed<16><<8>> @[package.scala 74:56]
        node _result_T_4 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
        node _result_T_5 = asFixedPoint(_result_T_4, 8) @[package.scala 74:56]
        _result_WIRE_2 <= _result_T_5 @[package.scala 74:56]
        result <= _result_WIRE_2 @[ALU.scala 75:14]
    node _T_9 = eq(op, UInt<3>("h4")) @[ALU.scala 78:11]
    when _T_9 : @[ALU.scala 78:25]
      wire _result_WIRE_3 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_6 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_7 = asFixedPoint(_result_T_6, 8) @[package.scala 74:56]
      _result_WIRE_3 <= _result_T_7 @[package.scala 74:56]
      result <= _result_WIRE_3 @[ALU.scala 79:12]
      wire _WIRE_1 : Fixed<<8>> @[package.scala 74:56]
      node _T_10 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_11 = asFixedPoint(_T_10, 8) @[package.scala 74:56]
      _WIRE_1 <= _T_11 @[package.scala 74:56]
      node _T_12 = geq(sourceLeft, _WIRE_1) @[ALU.scala 132:45]
      node _T_13 = geq(_WIRE_1, sourceLeft) @[ALU.scala 132:63]
      node _T_14 = and(_T_12, _T_13) @[ALU.scala 132:54]
      node _T_15 = eq(_T_14, UInt<1>("h0")) @[ALU.scala 131:40]
      wire _WIRE_2 : Fixed<<8>> @[package.scala 74:56]
      node _T_16 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_17 = asFixedPoint(_T_16, 8) @[package.scala 74:56]
      _WIRE_2 <= _T_17 @[package.scala 74:56]
      node _T_18 = geq(sourceRight, _WIRE_2) @[ALU.scala 132:45]
      node _T_19 = geq(_WIRE_2, sourceRight) @[ALU.scala 132:63]
      node _T_20 = and(_T_18, _T_19) @[ALU.scala 132:54]
      node _T_21 = eq(_T_20, UInt<1>("h0")) @[ALU.scala 131:40]
      node _T_22 = and(_T_15, _T_21) @[ALU.scala 80:29]
      when _T_22 : @[ALU.scala 80:53]
        wire _result_WIRE_4 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_8 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_9 = asFixedPoint(_result_T_8, 8) @[package.scala 82:56]
        _result_WIRE_4 <= _result_T_9 @[package.scala 82:56]
        result <= _result_WIRE_4 @[ALU.scala 81:14]
    node _T_23 = eq(op, UInt<3>("h5")) @[ALU.scala 84:11]
    when _T_23 : @[ALU.scala 84:24]
      wire _result_WIRE_5 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_10 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_11 = asFixedPoint(_result_T_10, 8) @[package.scala 74:56]
      _result_WIRE_5 <= _result_T_11 @[package.scala 74:56]
      result <= _result_WIRE_5 @[ALU.scala 85:12]
      wire _WIRE_3 : Fixed<<8>> @[package.scala 74:56]
      node _T_24 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_25 = asFixedPoint(_T_24, 8) @[package.scala 74:56]
      _WIRE_3 <= _T_25 @[package.scala 74:56]
      node _T_26 = geq(sourceLeft, _WIRE_3) @[ALU.scala 132:45]
      node _T_27 = geq(_WIRE_3, sourceLeft) @[ALU.scala 132:63]
      node _T_28 = and(_T_26, _T_27) @[ALU.scala 132:54]
      node _T_29 = eq(_T_28, UInt<1>("h0")) @[ALU.scala 131:40]
      wire _WIRE_4 : Fixed<<8>> @[package.scala 74:56]
      node _T_30 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_31 = asFixedPoint(_T_30, 8) @[package.scala 74:56]
      _WIRE_4 <= _T_31 @[package.scala 74:56]
      node _T_32 = geq(sourceRight, _WIRE_4) @[ALU.scala 132:45]
      node _T_33 = geq(_WIRE_4, sourceRight) @[ALU.scala 132:63]
      node _T_34 = and(_T_32, _T_33) @[ALU.scala 132:54]
      node _T_35 = eq(_T_34, UInt<1>("h0")) @[ALU.scala 131:40]
      node _T_36 = or(_T_29, _T_35) @[ALU.scala 86:29]
      when _T_36 : @[ALU.scala 86:53]
        wire _result_WIRE_6 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_12 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_13 = asFixedPoint(_result_T_12, 8) @[package.scala 82:56]
        _result_WIRE_6 <= _result_T_13 @[package.scala 82:56]
        result <= _result_WIRE_6 @[ALU.scala 87:14]
    node _T_37 = eq(op, UInt<3>("h6")) @[ALU.scala 92:11]
    when _T_37 : @[ALU.scala 92:31]
      wire _result_WIRE_7 : Fixed<16><<8>> @[package.scala 82:56]
      node _result_T_14 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
      node _result_T_15 = asFixedPoint(_result_T_14, 8) @[package.scala 82:56]
      _result_WIRE_7 <= _result_T_15 @[package.scala 82:56]
      node _result_T_16 = asSInt(sourceLeft) @[package.scala 163:37]
      node _result_T_17 = asSInt(_result_WIRE_7) @[package.scala 163:49]
      node _result_T_18 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T = mul(_result_T_16, _result_T_18) @[package.scala 117:18]
      node _result_mac_T_1 = shl(_result_T_17, 8) @[package.scala 117:29]
      node result_mac = add(_result_mac_T, _result_mac_T_1) @[package.scala 117:23]
      node result_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_1 = sub(_result_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_2 = tail(_result_mask1_T_1, 1) @[package.scala 120:44]
      node result_mask1 = asSInt(_result_mask1_T_2) @[package.scala 120:44]
      node result_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T = and(result_mac, result_mask0) @[package.scala 125:16]
      node _result_adjustment_T_1 = asSInt(_result_adjustment_T) @[package.scala 125:16]
      node _result_adjustment_T_2 = neq(_result_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_3 = and(result_mac, result_mask1) @[package.scala 125:44]
      node _result_adjustment_T_4 = asSInt(_result_adjustment_T_3) @[package.scala 125:44]
      node _result_adjustment_T_5 = neq(_result_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_6 = and(result_mac, result_mask2) @[package.scala 125:71]
      node _result_adjustment_T_7 = asSInt(_result_adjustment_T_6) @[package.scala 125:71]
      node _result_adjustment_T_8 = neq(_result_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_9 = or(_result_adjustment_T_5, _result_adjustment_T_8) @[package.scala 125:62]
      node _result_adjustment_T_10 = and(_result_adjustment_T_2, _result_adjustment_T_9) @[package.scala 125:34]
      node result_adjustment = mux(_result_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T = shr(result_mac, 8) @[package.scala 130:26]
      node _result_adjusted_T_1 = add(_result_adjusted_T, result_adjustment) @[package.scala 130:42]
      node _result_adjusted_T_2 = tail(_result_adjusted_T_1, 1) @[package.scala 130:42]
      node result_adjusted = asSInt(_result_adjusted_T_2) @[package.scala 130:42]
      node _result_saturated_T = gt(result_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_1 = lt(result_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_2 = mux(_result_saturated_T_1, asSInt(UInt<16>("h8000")), result_adjusted) @[package.scala 98:26]
      node result_saturated = mux(_result_saturated_T, asSInt(UInt<16>("h7fff")), _result_saturated_T_2) @[package.scala 98:8]
      node _result_T_19 = asFixedPoint(result_saturated, 8) @[package.scala 133:27]
      result <= _result_T_19 @[ALU.scala 93:12]
    node _T_38 = eq(op, UInt<3>("h7")) @[ALU.scala 95:11]
    when _T_38 : @[ALU.scala 95:31]
      wire _result_WIRE_8 : Fixed<16><<8>> @[package.scala 82:56]
      node _result_T_20 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
      node _result_T_21 = asFixedPoint(_result_T_20, 8) @[package.scala 82:56]
      _result_WIRE_8 <= _result_T_21 @[package.scala 82:56]
      node _result_T_22 = asSInt(sourceLeft) @[package.scala 171:37]
      node _result_T_23 = asSInt(_result_WIRE_8) @[package.scala 171:56]
      node _result_T_24 = sub(asSInt(UInt<1>("h0")), _result_T_23) @[package.scala 171:45]
      node _result_T_25 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T_2 = mul(_result_T_22, _result_T_25) @[package.scala 117:18]
      node _result_mac_T_3 = shl(_result_T_24, 8) @[package.scala 117:29]
      node result_mac_1 = add(_result_mac_T_2, _result_mac_T_3) @[package.scala 117:23]
      node result_mask0_1 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_3 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_4 = sub(_result_mask1_T_3, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_5 = tail(_result_mask1_T_4, 1) @[package.scala 120:44]
      node result_mask1_1 = asSInt(_result_mask1_T_5) @[package.scala 120:44]
      node result_mask2_1 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_11 = and(result_mac_1, result_mask0_1) @[package.scala 125:16]
      node _result_adjustment_T_12 = asSInt(_result_adjustment_T_11) @[package.scala 125:16]
      node _result_adjustment_T_13 = neq(_result_adjustment_T_12, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_14 = and(result_mac_1, result_mask1_1) @[package.scala 125:44]
      node _result_adjustment_T_15 = asSInt(_result_adjustment_T_14) @[package.scala 125:44]
      node _result_adjustment_T_16 = neq(_result_adjustment_T_15, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_17 = and(result_mac_1, result_mask2_1) @[package.scala 125:71]
      node _result_adjustment_T_18 = asSInt(_result_adjustment_T_17) @[package.scala 125:71]
      node _result_adjustment_T_19 = neq(_result_adjustment_T_18, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_20 = or(_result_adjustment_T_16, _result_adjustment_T_19) @[package.scala 125:62]
      node _result_adjustment_T_21 = and(_result_adjustment_T_13, _result_adjustment_T_20) @[package.scala 125:34]
      node result_adjustment_1 = mux(_result_adjustment_T_21, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_3 = shr(result_mac_1, 8) @[package.scala 130:26]
      node _result_adjusted_T_4 = add(_result_adjusted_T_3, result_adjustment_1) @[package.scala 130:42]
      node _result_adjusted_T_5 = tail(_result_adjusted_T_4, 1) @[package.scala 130:42]
      node result_adjusted_1 = asSInt(_result_adjusted_T_5) @[package.scala 130:42]
      node _result_saturated_T_3 = gt(result_adjusted_1, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_4 = lt(result_adjusted_1, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_5 = mux(_result_saturated_T_4, asSInt(UInt<16>("h8000")), result_adjusted_1) @[package.scala 98:26]
      node result_saturated_1 = mux(_result_saturated_T_3, asSInt(UInt<16>("h7fff")), _result_saturated_T_5) @[package.scala 98:8]
      node _result_T_26 = asFixedPoint(result_saturated_1, 8) @[package.scala 133:27]
      result <= _result_T_26 @[ALU.scala 96:12]
    node _T_39 = eq(op, UInt<4>("h8")) @[ALU.scala 98:11]
    when _T_39 : @[ALU.scala 98:25]
      node _result_T_27 = asSInt(sourceLeft) @[package.scala 163:37]
      node _result_T_28 = asSInt(sourceRight) @[package.scala 163:49]
      node _result_T_29 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T_4 = mul(_result_T_27, _result_T_29) @[package.scala 117:18]
      node _result_mac_T_5 = shl(_result_T_28, 8) @[package.scala 117:29]
      node result_mac_2 = add(_result_mac_T_4, _result_mac_T_5) @[package.scala 117:23]
      node result_mask0_2 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_6 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_7 = sub(_result_mask1_T_6, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_8 = tail(_result_mask1_T_7, 1) @[package.scala 120:44]
      node result_mask1_2 = asSInt(_result_mask1_T_8) @[package.scala 120:44]
      node result_mask2_2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_22 = and(result_mac_2, result_mask0_2) @[package.scala 125:16]
      node _result_adjustment_T_23 = asSInt(_result_adjustment_T_22) @[package.scala 125:16]
      node _result_adjustment_T_24 = neq(_result_adjustment_T_23, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_25 = and(result_mac_2, result_mask1_2) @[package.scala 125:44]
      node _result_adjustment_T_26 = asSInt(_result_adjustment_T_25) @[package.scala 125:44]
      node _result_adjustment_T_27 = neq(_result_adjustment_T_26, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_28 = and(result_mac_2, result_mask2_2) @[package.scala 125:71]
      node _result_adjustment_T_29 = asSInt(_result_adjustment_T_28) @[package.scala 125:71]
      node _result_adjustment_T_30 = neq(_result_adjustment_T_29, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_31 = or(_result_adjustment_T_27, _result_adjustment_T_30) @[package.scala 125:62]
      node _result_adjustment_T_32 = and(_result_adjustment_T_24, _result_adjustment_T_31) @[package.scala 125:34]
      node result_adjustment_2 = mux(_result_adjustment_T_32, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_6 = shr(result_mac_2, 8) @[package.scala 130:26]
      node _result_adjusted_T_7 = add(_result_adjusted_T_6, result_adjustment_2) @[package.scala 130:42]
      node _result_adjusted_T_8 = tail(_result_adjusted_T_7, 1) @[package.scala 130:42]
      node result_adjusted_2 = asSInt(_result_adjusted_T_8) @[package.scala 130:42]
      node _result_saturated_T_6 = gt(result_adjusted_2, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_7 = lt(result_adjusted_2, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_8 = mux(_result_saturated_T_7, asSInt(UInt<16>("h8000")), result_adjusted_2) @[package.scala 98:26]
      node result_saturated_2 = mux(_result_saturated_T_6, asSInt(UInt<16>("h7fff")), _result_saturated_T_8) @[package.scala 98:8]
      node _result_T_30 = asFixedPoint(result_saturated_2, 8) @[package.scala 133:27]
      result <= _result_T_30 @[ALU.scala 99:12]
    node _T_40 = eq(op, UInt<4>("h9")) @[ALU.scala 101:11]
    when _T_40 : @[ALU.scala 101:30]
      node _result_T_31 = asSInt(sourceLeft) @[package.scala 171:37]
      node _result_T_32 = asSInt(sourceRight) @[package.scala 171:56]
      node _result_T_33 = sub(asSInt(UInt<1>("h0")), _result_T_32) @[package.scala 171:45]
      node _result_T_34 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T_6 = mul(_result_T_31, _result_T_34) @[package.scala 117:18]
      node _result_mac_T_7 = shl(_result_T_33, 8) @[package.scala 117:29]
      node result_mac_3 = add(_result_mac_T_6, _result_mac_T_7) @[package.scala 117:23]
      node result_mask0_3 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_9 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_10 = sub(_result_mask1_T_9, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_11 = tail(_result_mask1_T_10, 1) @[package.scala 120:44]
      node result_mask1_3 = asSInt(_result_mask1_T_11) @[package.scala 120:44]
      node result_mask2_3 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_33 = and(result_mac_3, result_mask0_3) @[package.scala 125:16]
      node _result_adjustment_T_34 = asSInt(_result_adjustment_T_33) @[package.scala 125:16]
      node _result_adjustment_T_35 = neq(_result_adjustment_T_34, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_36 = and(result_mac_3, result_mask1_3) @[package.scala 125:44]
      node _result_adjustment_T_37 = asSInt(_result_adjustment_T_36) @[package.scala 125:44]
      node _result_adjustment_T_38 = neq(_result_adjustment_T_37, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_39 = and(result_mac_3, result_mask2_3) @[package.scala 125:71]
      node _result_adjustment_T_40 = asSInt(_result_adjustment_T_39) @[package.scala 125:71]
      node _result_adjustment_T_41 = neq(_result_adjustment_T_40, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_42 = or(_result_adjustment_T_38, _result_adjustment_T_41) @[package.scala 125:62]
      node _result_adjustment_T_43 = and(_result_adjustment_T_35, _result_adjustment_T_42) @[package.scala 125:34]
      node result_adjustment_3 = mux(_result_adjustment_T_43, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_9 = shr(result_mac_3, 8) @[package.scala 130:26]
      node _result_adjusted_T_10 = add(_result_adjusted_T_9, result_adjustment_3) @[package.scala 130:42]
      node _result_adjusted_T_11 = tail(_result_adjusted_T_10, 1) @[package.scala 130:42]
      node result_adjusted_3 = asSInt(_result_adjusted_T_11) @[package.scala 130:42]
      node _result_saturated_T_9 = gt(result_adjusted_3, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_10 = lt(result_adjusted_3, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_11 = mux(_result_saturated_T_10, asSInt(UInt<16>("h8000")), result_adjusted_3) @[package.scala 98:26]
      node result_saturated_3 = mux(_result_saturated_T_9, asSInt(UInt<16>("h7fff")), _result_saturated_T_11) @[package.scala 98:8]
      node _result_T_35 = asFixedPoint(result_saturated_3, 8) @[package.scala 133:27]
      result <= _result_T_35 @[ALU.scala 102:12]
    node _T_41 = eq(op, UInt<4>("ha")) @[ALU.scala 104:11]
    when _T_41 : @[ALU.scala 104:30]
      node _result_T_36 = asSInt(sourceLeft) @[package.scala 155:38]
      node _result_T_37 = asSInt(sourceRight) @[package.scala 155:50]
      node _result_mac_T_8 = mul(_result_T_36, _result_T_37) @[package.scala 117:18]
      node _result_mac_T_9 = shl(asSInt(UInt<1>("h0")), 8) @[package.scala 117:29]
      node result_mac_4 = add(_result_mac_T_8, _result_mac_T_9) @[package.scala 117:23]
      node result_mask0_4 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_12 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_13 = sub(_result_mask1_T_12, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_14 = tail(_result_mask1_T_13, 1) @[package.scala 120:44]
      node result_mask1_4 = asSInt(_result_mask1_T_14) @[package.scala 120:44]
      node result_mask2_4 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_44 = and(result_mac_4, result_mask0_4) @[package.scala 125:16]
      node _result_adjustment_T_45 = asSInt(_result_adjustment_T_44) @[package.scala 125:16]
      node _result_adjustment_T_46 = neq(_result_adjustment_T_45, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_47 = and(result_mac_4, result_mask1_4) @[package.scala 125:44]
      node _result_adjustment_T_48 = asSInt(_result_adjustment_T_47) @[package.scala 125:44]
      node _result_adjustment_T_49 = neq(_result_adjustment_T_48, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_50 = and(result_mac_4, result_mask2_4) @[package.scala 125:71]
      node _result_adjustment_T_51 = asSInt(_result_adjustment_T_50) @[package.scala 125:71]
      node _result_adjustment_T_52 = neq(_result_adjustment_T_51, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_53 = or(_result_adjustment_T_49, _result_adjustment_T_52) @[package.scala 125:62]
      node _result_adjustment_T_54 = and(_result_adjustment_T_46, _result_adjustment_T_53) @[package.scala 125:34]
      node result_adjustment_4 = mux(_result_adjustment_T_54, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_12 = shr(result_mac_4, 8) @[package.scala 130:26]
      node _result_adjusted_T_13 = add(_result_adjusted_T_12, result_adjustment_4) @[package.scala 130:42]
      node _result_adjusted_T_14 = tail(_result_adjusted_T_13, 1) @[package.scala 130:42]
      node result_adjusted_4 = asSInt(_result_adjusted_T_14) @[package.scala 130:42]
      node _result_saturated_T_12 = gt(result_adjusted_4, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_13 = lt(result_adjusted_4, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_14 = mux(_result_saturated_T_13, asSInt(UInt<16>("h8000")), result_adjusted_4) @[package.scala 98:26]
      node result_saturated_4 = mux(_result_saturated_T_12, asSInt(UInt<16>("h7fff")), _result_saturated_T_14) @[package.scala 98:8]
      node _result_T_38 = asFixedPoint(result_saturated_4, 8) @[package.scala 133:27]
      result <= _result_T_38 @[ALU.scala 105:12]
    node _T_42 = eq(op, UInt<4>("hb")) @[ALU.scala 107:11]
    when _T_42 : @[ALU.scala 107:25]
      node _result_T_39 = lt(sourceLeft, asFixedPoint(UInt<1>("h0"), 0)) @[ALU.scala 108:26]
      node _result_T_40 = sub(asFixedPoint(UInt<1>("h0"), 0), sourceLeft) @[ALU.scala 108:26]
      node _result_T_41 = tail(_result_T_40, 1) @[ALU.scala 108:26]
      node _result_T_42 = asFixedPoint(_result_T_41, 8) @[ALU.scala 108:26]
      node _result_T_43 = mux(_result_T_39, _result_T_42, sourceLeft) @[ALU.scala 108:26]
      result <= _result_T_43 @[ALU.scala 108:12]
    node _T_43 = eq(op, UInt<4>("hc")) @[ALU.scala 112:11]
    when _T_43 : @[ALU.scala 112:33]
      wire _result_WIRE_9 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_44 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_45 = asFixedPoint(_result_T_44, 8) @[package.scala 74:56]
      _result_WIRE_9 <= _result_T_45 @[package.scala 74:56]
      result <= _result_WIRE_9 @[ALU.scala 113:12]
      node _T_44 = gt(sourceLeft, sourceRight) @[ALU.scala 114:21]
      when _T_44 : @[ALU.scala 114:36]
        wire _result_WIRE_10 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_46 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_47 = asFixedPoint(_result_T_46, 8) @[package.scala 82:56]
        _result_WIRE_10 <= _result_T_47 @[package.scala 82:56]
        result <= _result_WIRE_10 @[ALU.scala 115:14]
    node _T_45 = eq(op, UInt<4>("hd")) @[ALU.scala 118:11]
    when _T_45 : @[ALU.scala 118:38]
      wire _result_WIRE_11 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_48 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_49 = asFixedPoint(_result_T_48, 8) @[package.scala 74:56]
      _result_WIRE_11 <= _result_T_49 @[package.scala 74:56]
      result <= _result_WIRE_11 @[ALU.scala 119:12]
      node _T_46 = geq(sourceLeft, sourceRight) @[ALU.scala 120:21]
      when _T_46 : @[ALU.scala 120:37]
        wire _result_WIRE_12 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_50 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_51 = asFixedPoint(_result_T_50, 8) @[package.scala 82:56]
        _result_WIRE_12 <= _result_T_51 @[package.scala 82:56]
        result <= _result_WIRE_12 @[ALU.scala 121:14]
    node _T_47 = eq(op, UInt<4>("he")) @[ALU.scala 124:11]
    when _T_47 : @[ALU.scala 124:25]
      node _result_T_52 = lt(sourceLeft, sourceRight) @[ALU.scala 125:29]
      node _result_T_53 = mux(_result_T_52, sourceLeft, sourceRight) @[ALU.scala 125:29]
      result <= _result_T_53 @[ALU.scala 125:12]
    node _T_48 = eq(op, UInt<4>("hf")) @[ALU.scala 127:11]
    when _T_48 : @[ALU.scala 127:25]
      node _result_T_54 = lt(sourceLeft, sourceRight) @[ALU.scala 128:29]
      node _result_T_55 = mux(_result_T_54, sourceRight, sourceLeft) @[ALU.scala 128:29]
      result <= _result_T_55 @[ALU.scala 128:12]

  module ALU_4 :
    input clock : Clock
    input reset : Reset
    output io : { flip op : UInt<4>, flip input : Fixed<16><<8>>, flip sourceLeft : UInt<1>, flip sourceRight : UInt<1>, flip dest : UInt<1>, output : Fixed<16><<8>>}

    reg op : UInt, clock with :
      reset => (UInt<1>("h0"), op) @[ALU.scala 35:42]
    op <= io.op @[ALU.scala 35:42]
    reg input : Fixed<<8>>, clock with :
      reset => (UInt<1>("h0"), input) @[ALU.scala 36:42]
    input <= io.input @[ALU.scala 36:42]
    reg sourceLeftInput : UInt, clock with :
      reset => (UInt<1>("h0"), sourceLeftInput) @[ALU.scala 38:32]
    sourceLeftInput <= io.sourceLeft @[ALU.scala 38:32]
    reg sourceRightInput : UInt, clock with :
      reset => (UInt<1>("h0"), sourceRightInput) @[ALU.scala 40:32]
    sourceRightInput <= io.sourceRight @[ALU.scala 40:32]
    reg destInput : UInt, clock with :
      reset => (UInt<1>("h0"), destInput) @[ALU.scala 41:46]
    destInput <= io.dest @[ALU.scala 41:46]
    wire _reg_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _reg_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _reg_T_1 = asFixedPoint(_reg_T, 8) @[package.scala 74:56]
    _reg_WIRE <= _reg_T_1 @[package.scala 74:56]
    wire _reg_WIRE_1 : Fixed<16><<8>>[1] @[ALU.scala 43:28]
    _reg_WIRE_1[0] <= _reg_WIRE @[ALU.scala 43:28]
    reg reg : Fixed<16><<8>>[1], clock with :
      reset => (reset, _reg_WIRE_1) @[ALU.scala 43:20]
    node _sourceLeft_T = eq(sourceLeftInput, UInt<1>("h0")) @[ALU.scala 45:25]
    node _sourceLeft_T_1 = sub(sourceLeftInput, UInt<1>("h1")) @[ALU.scala 45:61]
    node _sourceLeft_T_2 = tail(_sourceLeft_T_1, 1) @[ALU.scala 45:61]
    node sourceLeft = mux(_sourceLeft_T, input, reg[UInt<1>("h0")]) @[ALU.scala 45:8]
    node _sourceRight_T = eq(sourceRightInput, UInt<1>("h0")) @[ALU.scala 47:26]
    node _sourceRight_T_1 = sub(sourceRightInput, UInt<1>("h1")) @[ALU.scala 47:63]
    node _sourceRight_T_2 = tail(_sourceRight_T_1, 1) @[ALU.scala 47:63]
    node sourceRight = mux(_sourceRight_T, input, reg[UInt<1>("h0")]) @[ALU.scala 47:8]
    node _dest_T = eq(destInput, UInt<1>("h0")) @[ALU.scala 51:17]
    node _dest_T_1 = eq(op, UInt<1>("h0")) @[ALU.scala 51:31]
    node _dest_T_2 = or(_dest_T, _dest_T_1) @[ALU.scala 51:25]
    node _dest_T_3 = sub(destInput, UInt<1>("h1")) @[ALU.scala 53:21]
    node _dest_T_4 = tail(_dest_T_3, 1) @[ALU.scala 53:21]
    wire dest : Fixed<16><<8>> @[Demux.scala 11:21]
    when _dest_T_2 : @[Demux.scala 12:16]
      io.output <= dest @[Demux.scala 13:11]
    else :
      reg[UInt<1>("h0")] <= dest @[Demux.scala 15:11]
    wire result : Fixed<16><<8>> @[ALU.scala 56:20]
    reg output : Fixed<<8>>, clock with :
      reset => (UInt<1>("h0"), output) @[ALU.scala 57:43]
    output <= result @[ALU.scala 57:43]
    io.output <= output @[ALU.scala 58:13]
    dest <= result @[ALU.scala 59:8]
    result <= input @[ALU.scala 62:10]
    node _T = eq(op, UInt<1>("h1")) @[ALU.scala 64:11]
    when _T : @[ALU.scala 64:26]
      wire _result_WIRE : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_1 = asFixedPoint(_result_T, 8) @[package.scala 74:56]
      _result_WIRE <= _result_T_1 @[package.scala 74:56]
      result <= _result_WIRE @[ALU.scala 65:12]
    node _T_1 = eq(op, UInt<2>("h2")) @[ALU.scala 67:11]
    when _T_1 : @[ALU.scala 67:26]
      result <= sourceLeft @[ALU.scala 68:12]
    node _T_2 = eq(op, UInt<2>("h3")) @[ALU.scala 72:11]
    when _T_2 : @[ALU.scala 72:25]
      wire _result_WIRE_1 : Fixed<16><<8>> @[package.scala 82:56]
      node _result_T_2 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
      node _result_T_3 = asFixedPoint(_result_T_2, 8) @[package.scala 82:56]
      _result_WIRE_1 <= _result_T_3 @[package.scala 82:56]
      result <= _result_WIRE_1 @[ALU.scala 73:12]
      wire _WIRE : Fixed<<8>> @[package.scala 74:56]
      node _T_3 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_4 = asFixedPoint(_T_3, 8) @[package.scala 74:56]
      _WIRE <= _T_4 @[package.scala 74:56]
      node _T_5 = geq(sourceLeft, _WIRE) @[ALU.scala 132:45]
      node _T_6 = geq(_WIRE, sourceLeft) @[ALU.scala 132:63]
      node _T_7 = and(_T_5, _T_6) @[ALU.scala 132:54]
      node _T_8 = eq(_T_7, UInt<1>("h0")) @[ALU.scala 131:40]
      when _T_8 : @[ALU.scala 74:30]
        wire _result_WIRE_2 : Fixed<16><<8>> @[package.scala 74:56]
        node _result_T_4 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
        node _result_T_5 = asFixedPoint(_result_T_4, 8) @[package.scala 74:56]
        _result_WIRE_2 <= _result_T_5 @[package.scala 74:56]
        result <= _result_WIRE_2 @[ALU.scala 75:14]
    node _T_9 = eq(op, UInt<3>("h4")) @[ALU.scala 78:11]
    when _T_9 : @[ALU.scala 78:25]
      wire _result_WIRE_3 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_6 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_7 = asFixedPoint(_result_T_6, 8) @[package.scala 74:56]
      _result_WIRE_3 <= _result_T_7 @[package.scala 74:56]
      result <= _result_WIRE_3 @[ALU.scala 79:12]
      wire _WIRE_1 : Fixed<<8>> @[package.scala 74:56]
      node _T_10 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_11 = asFixedPoint(_T_10, 8) @[package.scala 74:56]
      _WIRE_1 <= _T_11 @[package.scala 74:56]
      node _T_12 = geq(sourceLeft, _WIRE_1) @[ALU.scala 132:45]
      node _T_13 = geq(_WIRE_1, sourceLeft) @[ALU.scala 132:63]
      node _T_14 = and(_T_12, _T_13) @[ALU.scala 132:54]
      node _T_15 = eq(_T_14, UInt<1>("h0")) @[ALU.scala 131:40]
      wire _WIRE_2 : Fixed<<8>> @[package.scala 74:56]
      node _T_16 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_17 = asFixedPoint(_T_16, 8) @[package.scala 74:56]
      _WIRE_2 <= _T_17 @[package.scala 74:56]
      node _T_18 = geq(sourceRight, _WIRE_2) @[ALU.scala 132:45]
      node _T_19 = geq(_WIRE_2, sourceRight) @[ALU.scala 132:63]
      node _T_20 = and(_T_18, _T_19) @[ALU.scala 132:54]
      node _T_21 = eq(_T_20, UInt<1>("h0")) @[ALU.scala 131:40]
      node _T_22 = and(_T_15, _T_21) @[ALU.scala 80:29]
      when _T_22 : @[ALU.scala 80:53]
        wire _result_WIRE_4 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_8 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_9 = asFixedPoint(_result_T_8, 8) @[package.scala 82:56]
        _result_WIRE_4 <= _result_T_9 @[package.scala 82:56]
        result <= _result_WIRE_4 @[ALU.scala 81:14]
    node _T_23 = eq(op, UInt<3>("h5")) @[ALU.scala 84:11]
    when _T_23 : @[ALU.scala 84:24]
      wire _result_WIRE_5 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_10 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_11 = asFixedPoint(_result_T_10, 8) @[package.scala 74:56]
      _result_WIRE_5 <= _result_T_11 @[package.scala 74:56]
      result <= _result_WIRE_5 @[ALU.scala 85:12]
      wire _WIRE_3 : Fixed<<8>> @[package.scala 74:56]
      node _T_24 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_25 = asFixedPoint(_T_24, 8) @[package.scala 74:56]
      _WIRE_3 <= _T_25 @[package.scala 74:56]
      node _T_26 = geq(sourceLeft, _WIRE_3) @[ALU.scala 132:45]
      node _T_27 = geq(_WIRE_3, sourceLeft) @[ALU.scala 132:63]
      node _T_28 = and(_T_26, _T_27) @[ALU.scala 132:54]
      node _T_29 = eq(_T_28, UInt<1>("h0")) @[ALU.scala 131:40]
      wire _WIRE_4 : Fixed<<8>> @[package.scala 74:56]
      node _T_30 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_31 = asFixedPoint(_T_30, 8) @[package.scala 74:56]
      _WIRE_4 <= _T_31 @[package.scala 74:56]
      node _T_32 = geq(sourceRight, _WIRE_4) @[ALU.scala 132:45]
      node _T_33 = geq(_WIRE_4, sourceRight) @[ALU.scala 132:63]
      node _T_34 = and(_T_32, _T_33) @[ALU.scala 132:54]
      node _T_35 = eq(_T_34, UInt<1>("h0")) @[ALU.scala 131:40]
      node _T_36 = or(_T_29, _T_35) @[ALU.scala 86:29]
      when _T_36 : @[ALU.scala 86:53]
        wire _result_WIRE_6 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_12 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_13 = asFixedPoint(_result_T_12, 8) @[package.scala 82:56]
        _result_WIRE_6 <= _result_T_13 @[package.scala 82:56]
        result <= _result_WIRE_6 @[ALU.scala 87:14]
    node _T_37 = eq(op, UInt<3>("h6")) @[ALU.scala 92:11]
    when _T_37 : @[ALU.scala 92:31]
      wire _result_WIRE_7 : Fixed<16><<8>> @[package.scala 82:56]
      node _result_T_14 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
      node _result_T_15 = asFixedPoint(_result_T_14, 8) @[package.scala 82:56]
      _result_WIRE_7 <= _result_T_15 @[package.scala 82:56]
      node _result_T_16 = asSInt(sourceLeft) @[package.scala 163:37]
      node _result_T_17 = asSInt(_result_WIRE_7) @[package.scala 163:49]
      node _result_T_18 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T = mul(_result_T_16, _result_T_18) @[package.scala 117:18]
      node _result_mac_T_1 = shl(_result_T_17, 8) @[package.scala 117:29]
      node result_mac = add(_result_mac_T, _result_mac_T_1) @[package.scala 117:23]
      node result_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_1 = sub(_result_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_2 = tail(_result_mask1_T_1, 1) @[package.scala 120:44]
      node result_mask1 = asSInt(_result_mask1_T_2) @[package.scala 120:44]
      node result_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T = and(result_mac, result_mask0) @[package.scala 125:16]
      node _result_adjustment_T_1 = asSInt(_result_adjustment_T) @[package.scala 125:16]
      node _result_adjustment_T_2 = neq(_result_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_3 = and(result_mac, result_mask1) @[package.scala 125:44]
      node _result_adjustment_T_4 = asSInt(_result_adjustment_T_3) @[package.scala 125:44]
      node _result_adjustment_T_5 = neq(_result_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_6 = and(result_mac, result_mask2) @[package.scala 125:71]
      node _result_adjustment_T_7 = asSInt(_result_adjustment_T_6) @[package.scala 125:71]
      node _result_adjustment_T_8 = neq(_result_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_9 = or(_result_adjustment_T_5, _result_adjustment_T_8) @[package.scala 125:62]
      node _result_adjustment_T_10 = and(_result_adjustment_T_2, _result_adjustment_T_9) @[package.scala 125:34]
      node result_adjustment = mux(_result_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T = shr(result_mac, 8) @[package.scala 130:26]
      node _result_adjusted_T_1 = add(_result_adjusted_T, result_adjustment) @[package.scala 130:42]
      node _result_adjusted_T_2 = tail(_result_adjusted_T_1, 1) @[package.scala 130:42]
      node result_adjusted = asSInt(_result_adjusted_T_2) @[package.scala 130:42]
      node _result_saturated_T = gt(result_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_1 = lt(result_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_2 = mux(_result_saturated_T_1, asSInt(UInt<16>("h8000")), result_adjusted) @[package.scala 98:26]
      node result_saturated = mux(_result_saturated_T, asSInt(UInt<16>("h7fff")), _result_saturated_T_2) @[package.scala 98:8]
      node _result_T_19 = asFixedPoint(result_saturated, 8) @[package.scala 133:27]
      result <= _result_T_19 @[ALU.scala 93:12]
    node _T_38 = eq(op, UInt<3>("h7")) @[ALU.scala 95:11]
    when _T_38 : @[ALU.scala 95:31]
      wire _result_WIRE_8 : Fixed<16><<8>> @[package.scala 82:56]
      node _result_T_20 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
      node _result_T_21 = asFixedPoint(_result_T_20, 8) @[package.scala 82:56]
      _result_WIRE_8 <= _result_T_21 @[package.scala 82:56]
      node _result_T_22 = asSInt(sourceLeft) @[package.scala 171:37]
      node _result_T_23 = asSInt(_result_WIRE_8) @[package.scala 171:56]
      node _result_T_24 = sub(asSInt(UInt<1>("h0")), _result_T_23) @[package.scala 171:45]
      node _result_T_25 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T_2 = mul(_result_T_22, _result_T_25) @[package.scala 117:18]
      node _result_mac_T_3 = shl(_result_T_24, 8) @[package.scala 117:29]
      node result_mac_1 = add(_result_mac_T_2, _result_mac_T_3) @[package.scala 117:23]
      node result_mask0_1 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_3 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_4 = sub(_result_mask1_T_3, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_5 = tail(_result_mask1_T_4, 1) @[package.scala 120:44]
      node result_mask1_1 = asSInt(_result_mask1_T_5) @[package.scala 120:44]
      node result_mask2_1 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_11 = and(result_mac_1, result_mask0_1) @[package.scala 125:16]
      node _result_adjustment_T_12 = asSInt(_result_adjustment_T_11) @[package.scala 125:16]
      node _result_adjustment_T_13 = neq(_result_adjustment_T_12, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_14 = and(result_mac_1, result_mask1_1) @[package.scala 125:44]
      node _result_adjustment_T_15 = asSInt(_result_adjustment_T_14) @[package.scala 125:44]
      node _result_adjustment_T_16 = neq(_result_adjustment_T_15, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_17 = and(result_mac_1, result_mask2_1) @[package.scala 125:71]
      node _result_adjustment_T_18 = asSInt(_result_adjustment_T_17) @[package.scala 125:71]
      node _result_adjustment_T_19 = neq(_result_adjustment_T_18, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_20 = or(_result_adjustment_T_16, _result_adjustment_T_19) @[package.scala 125:62]
      node _result_adjustment_T_21 = and(_result_adjustment_T_13, _result_adjustment_T_20) @[package.scala 125:34]
      node result_adjustment_1 = mux(_result_adjustment_T_21, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_3 = shr(result_mac_1, 8) @[package.scala 130:26]
      node _result_adjusted_T_4 = add(_result_adjusted_T_3, result_adjustment_1) @[package.scala 130:42]
      node _result_adjusted_T_5 = tail(_result_adjusted_T_4, 1) @[package.scala 130:42]
      node result_adjusted_1 = asSInt(_result_adjusted_T_5) @[package.scala 130:42]
      node _result_saturated_T_3 = gt(result_adjusted_1, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_4 = lt(result_adjusted_1, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_5 = mux(_result_saturated_T_4, asSInt(UInt<16>("h8000")), result_adjusted_1) @[package.scala 98:26]
      node result_saturated_1 = mux(_result_saturated_T_3, asSInt(UInt<16>("h7fff")), _result_saturated_T_5) @[package.scala 98:8]
      node _result_T_26 = asFixedPoint(result_saturated_1, 8) @[package.scala 133:27]
      result <= _result_T_26 @[ALU.scala 96:12]
    node _T_39 = eq(op, UInt<4>("h8")) @[ALU.scala 98:11]
    when _T_39 : @[ALU.scala 98:25]
      node _result_T_27 = asSInt(sourceLeft) @[package.scala 163:37]
      node _result_T_28 = asSInt(sourceRight) @[package.scala 163:49]
      node _result_T_29 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T_4 = mul(_result_T_27, _result_T_29) @[package.scala 117:18]
      node _result_mac_T_5 = shl(_result_T_28, 8) @[package.scala 117:29]
      node result_mac_2 = add(_result_mac_T_4, _result_mac_T_5) @[package.scala 117:23]
      node result_mask0_2 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_6 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_7 = sub(_result_mask1_T_6, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_8 = tail(_result_mask1_T_7, 1) @[package.scala 120:44]
      node result_mask1_2 = asSInt(_result_mask1_T_8) @[package.scala 120:44]
      node result_mask2_2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_22 = and(result_mac_2, result_mask0_2) @[package.scala 125:16]
      node _result_adjustment_T_23 = asSInt(_result_adjustment_T_22) @[package.scala 125:16]
      node _result_adjustment_T_24 = neq(_result_adjustment_T_23, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_25 = and(result_mac_2, result_mask1_2) @[package.scala 125:44]
      node _result_adjustment_T_26 = asSInt(_result_adjustment_T_25) @[package.scala 125:44]
      node _result_adjustment_T_27 = neq(_result_adjustment_T_26, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_28 = and(result_mac_2, result_mask2_2) @[package.scala 125:71]
      node _result_adjustment_T_29 = asSInt(_result_adjustment_T_28) @[package.scala 125:71]
      node _result_adjustment_T_30 = neq(_result_adjustment_T_29, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_31 = or(_result_adjustment_T_27, _result_adjustment_T_30) @[package.scala 125:62]
      node _result_adjustment_T_32 = and(_result_adjustment_T_24, _result_adjustment_T_31) @[package.scala 125:34]
      node result_adjustment_2 = mux(_result_adjustment_T_32, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_6 = shr(result_mac_2, 8) @[package.scala 130:26]
      node _result_adjusted_T_7 = add(_result_adjusted_T_6, result_adjustment_2) @[package.scala 130:42]
      node _result_adjusted_T_8 = tail(_result_adjusted_T_7, 1) @[package.scala 130:42]
      node result_adjusted_2 = asSInt(_result_adjusted_T_8) @[package.scala 130:42]
      node _result_saturated_T_6 = gt(result_adjusted_2, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_7 = lt(result_adjusted_2, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_8 = mux(_result_saturated_T_7, asSInt(UInt<16>("h8000")), result_adjusted_2) @[package.scala 98:26]
      node result_saturated_2 = mux(_result_saturated_T_6, asSInt(UInt<16>("h7fff")), _result_saturated_T_8) @[package.scala 98:8]
      node _result_T_30 = asFixedPoint(result_saturated_2, 8) @[package.scala 133:27]
      result <= _result_T_30 @[ALU.scala 99:12]
    node _T_40 = eq(op, UInt<4>("h9")) @[ALU.scala 101:11]
    when _T_40 : @[ALU.scala 101:30]
      node _result_T_31 = asSInt(sourceLeft) @[package.scala 171:37]
      node _result_T_32 = asSInt(sourceRight) @[package.scala 171:56]
      node _result_T_33 = sub(asSInt(UInt<1>("h0")), _result_T_32) @[package.scala 171:45]
      node _result_T_34 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T_6 = mul(_result_T_31, _result_T_34) @[package.scala 117:18]
      node _result_mac_T_7 = shl(_result_T_33, 8) @[package.scala 117:29]
      node result_mac_3 = add(_result_mac_T_6, _result_mac_T_7) @[package.scala 117:23]
      node result_mask0_3 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_9 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_10 = sub(_result_mask1_T_9, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_11 = tail(_result_mask1_T_10, 1) @[package.scala 120:44]
      node result_mask1_3 = asSInt(_result_mask1_T_11) @[package.scala 120:44]
      node result_mask2_3 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_33 = and(result_mac_3, result_mask0_3) @[package.scala 125:16]
      node _result_adjustment_T_34 = asSInt(_result_adjustment_T_33) @[package.scala 125:16]
      node _result_adjustment_T_35 = neq(_result_adjustment_T_34, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_36 = and(result_mac_3, result_mask1_3) @[package.scala 125:44]
      node _result_adjustment_T_37 = asSInt(_result_adjustment_T_36) @[package.scala 125:44]
      node _result_adjustment_T_38 = neq(_result_adjustment_T_37, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_39 = and(result_mac_3, result_mask2_3) @[package.scala 125:71]
      node _result_adjustment_T_40 = asSInt(_result_adjustment_T_39) @[package.scala 125:71]
      node _result_adjustment_T_41 = neq(_result_adjustment_T_40, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_42 = or(_result_adjustment_T_38, _result_adjustment_T_41) @[package.scala 125:62]
      node _result_adjustment_T_43 = and(_result_adjustment_T_35, _result_adjustment_T_42) @[package.scala 125:34]
      node result_adjustment_3 = mux(_result_adjustment_T_43, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_9 = shr(result_mac_3, 8) @[package.scala 130:26]
      node _result_adjusted_T_10 = add(_result_adjusted_T_9, result_adjustment_3) @[package.scala 130:42]
      node _result_adjusted_T_11 = tail(_result_adjusted_T_10, 1) @[package.scala 130:42]
      node result_adjusted_3 = asSInt(_result_adjusted_T_11) @[package.scala 130:42]
      node _result_saturated_T_9 = gt(result_adjusted_3, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_10 = lt(result_adjusted_3, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_11 = mux(_result_saturated_T_10, asSInt(UInt<16>("h8000")), result_adjusted_3) @[package.scala 98:26]
      node result_saturated_3 = mux(_result_saturated_T_9, asSInt(UInt<16>("h7fff")), _result_saturated_T_11) @[package.scala 98:8]
      node _result_T_35 = asFixedPoint(result_saturated_3, 8) @[package.scala 133:27]
      result <= _result_T_35 @[ALU.scala 102:12]
    node _T_41 = eq(op, UInt<4>("ha")) @[ALU.scala 104:11]
    when _T_41 : @[ALU.scala 104:30]
      node _result_T_36 = asSInt(sourceLeft) @[package.scala 155:38]
      node _result_T_37 = asSInt(sourceRight) @[package.scala 155:50]
      node _result_mac_T_8 = mul(_result_T_36, _result_T_37) @[package.scala 117:18]
      node _result_mac_T_9 = shl(asSInt(UInt<1>("h0")), 8) @[package.scala 117:29]
      node result_mac_4 = add(_result_mac_T_8, _result_mac_T_9) @[package.scala 117:23]
      node result_mask0_4 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_12 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_13 = sub(_result_mask1_T_12, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_14 = tail(_result_mask1_T_13, 1) @[package.scala 120:44]
      node result_mask1_4 = asSInt(_result_mask1_T_14) @[package.scala 120:44]
      node result_mask2_4 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_44 = and(result_mac_4, result_mask0_4) @[package.scala 125:16]
      node _result_adjustment_T_45 = asSInt(_result_adjustment_T_44) @[package.scala 125:16]
      node _result_adjustment_T_46 = neq(_result_adjustment_T_45, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_47 = and(result_mac_4, result_mask1_4) @[package.scala 125:44]
      node _result_adjustment_T_48 = asSInt(_result_adjustment_T_47) @[package.scala 125:44]
      node _result_adjustment_T_49 = neq(_result_adjustment_T_48, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_50 = and(result_mac_4, result_mask2_4) @[package.scala 125:71]
      node _result_adjustment_T_51 = asSInt(_result_adjustment_T_50) @[package.scala 125:71]
      node _result_adjustment_T_52 = neq(_result_adjustment_T_51, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_53 = or(_result_adjustment_T_49, _result_adjustment_T_52) @[package.scala 125:62]
      node _result_adjustment_T_54 = and(_result_adjustment_T_46, _result_adjustment_T_53) @[package.scala 125:34]
      node result_adjustment_4 = mux(_result_adjustment_T_54, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_12 = shr(result_mac_4, 8) @[package.scala 130:26]
      node _result_adjusted_T_13 = add(_result_adjusted_T_12, result_adjustment_4) @[package.scala 130:42]
      node _result_adjusted_T_14 = tail(_result_adjusted_T_13, 1) @[package.scala 130:42]
      node result_adjusted_4 = asSInt(_result_adjusted_T_14) @[package.scala 130:42]
      node _result_saturated_T_12 = gt(result_adjusted_4, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_13 = lt(result_adjusted_4, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_14 = mux(_result_saturated_T_13, asSInt(UInt<16>("h8000")), result_adjusted_4) @[package.scala 98:26]
      node result_saturated_4 = mux(_result_saturated_T_12, asSInt(UInt<16>("h7fff")), _result_saturated_T_14) @[package.scala 98:8]
      node _result_T_38 = asFixedPoint(result_saturated_4, 8) @[package.scala 133:27]
      result <= _result_T_38 @[ALU.scala 105:12]
    node _T_42 = eq(op, UInt<4>("hb")) @[ALU.scala 107:11]
    when _T_42 : @[ALU.scala 107:25]
      node _result_T_39 = lt(sourceLeft, asFixedPoint(UInt<1>("h0"), 0)) @[ALU.scala 108:26]
      node _result_T_40 = sub(asFixedPoint(UInt<1>("h0"), 0), sourceLeft) @[ALU.scala 108:26]
      node _result_T_41 = tail(_result_T_40, 1) @[ALU.scala 108:26]
      node _result_T_42 = asFixedPoint(_result_T_41, 8) @[ALU.scala 108:26]
      node _result_T_43 = mux(_result_T_39, _result_T_42, sourceLeft) @[ALU.scala 108:26]
      result <= _result_T_43 @[ALU.scala 108:12]
    node _T_43 = eq(op, UInt<4>("hc")) @[ALU.scala 112:11]
    when _T_43 : @[ALU.scala 112:33]
      wire _result_WIRE_9 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_44 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_45 = asFixedPoint(_result_T_44, 8) @[package.scala 74:56]
      _result_WIRE_9 <= _result_T_45 @[package.scala 74:56]
      result <= _result_WIRE_9 @[ALU.scala 113:12]
      node _T_44 = gt(sourceLeft, sourceRight) @[ALU.scala 114:21]
      when _T_44 : @[ALU.scala 114:36]
        wire _result_WIRE_10 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_46 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_47 = asFixedPoint(_result_T_46, 8) @[package.scala 82:56]
        _result_WIRE_10 <= _result_T_47 @[package.scala 82:56]
        result <= _result_WIRE_10 @[ALU.scala 115:14]
    node _T_45 = eq(op, UInt<4>("hd")) @[ALU.scala 118:11]
    when _T_45 : @[ALU.scala 118:38]
      wire _result_WIRE_11 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_48 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_49 = asFixedPoint(_result_T_48, 8) @[package.scala 74:56]
      _result_WIRE_11 <= _result_T_49 @[package.scala 74:56]
      result <= _result_WIRE_11 @[ALU.scala 119:12]
      node _T_46 = geq(sourceLeft, sourceRight) @[ALU.scala 120:21]
      when _T_46 : @[ALU.scala 120:37]
        wire _result_WIRE_12 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_50 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_51 = asFixedPoint(_result_T_50, 8) @[package.scala 82:56]
        _result_WIRE_12 <= _result_T_51 @[package.scala 82:56]
        result <= _result_WIRE_12 @[ALU.scala 121:14]
    node _T_47 = eq(op, UInt<4>("he")) @[ALU.scala 124:11]
    when _T_47 : @[ALU.scala 124:25]
      node _result_T_52 = lt(sourceLeft, sourceRight) @[ALU.scala 125:29]
      node _result_T_53 = mux(_result_T_52, sourceLeft, sourceRight) @[ALU.scala 125:29]
      result <= _result_T_53 @[ALU.scala 125:12]
    node _T_48 = eq(op, UInt<4>("hf")) @[ALU.scala 127:11]
    when _T_48 : @[ALU.scala 127:25]
      node _result_T_54 = lt(sourceLeft, sourceRight) @[ALU.scala 128:29]
      node _result_T_55 = mux(_result_T_54, sourceRight, sourceLeft) @[ALU.scala 128:29]
      result <= _result_T_55 @[ALU.scala 128:12]

  module ALU_5 :
    input clock : Clock
    input reset : Reset
    output io : { flip op : UInt<4>, flip input : Fixed<16><<8>>, flip sourceLeft : UInt<1>, flip sourceRight : UInt<1>, flip dest : UInt<1>, output : Fixed<16><<8>>}

    reg op : UInt, clock with :
      reset => (UInt<1>("h0"), op) @[ALU.scala 35:42]
    op <= io.op @[ALU.scala 35:42]
    reg input : Fixed<<8>>, clock with :
      reset => (UInt<1>("h0"), input) @[ALU.scala 36:42]
    input <= io.input @[ALU.scala 36:42]
    reg sourceLeftInput : UInt, clock with :
      reset => (UInt<1>("h0"), sourceLeftInput) @[ALU.scala 38:32]
    sourceLeftInput <= io.sourceLeft @[ALU.scala 38:32]
    reg sourceRightInput : UInt, clock with :
      reset => (UInt<1>("h0"), sourceRightInput) @[ALU.scala 40:32]
    sourceRightInput <= io.sourceRight @[ALU.scala 40:32]
    reg destInput : UInt, clock with :
      reset => (UInt<1>("h0"), destInput) @[ALU.scala 41:46]
    destInput <= io.dest @[ALU.scala 41:46]
    wire _reg_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _reg_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _reg_T_1 = asFixedPoint(_reg_T, 8) @[package.scala 74:56]
    _reg_WIRE <= _reg_T_1 @[package.scala 74:56]
    wire _reg_WIRE_1 : Fixed<16><<8>>[1] @[ALU.scala 43:28]
    _reg_WIRE_1[0] <= _reg_WIRE @[ALU.scala 43:28]
    reg reg : Fixed<16><<8>>[1], clock with :
      reset => (reset, _reg_WIRE_1) @[ALU.scala 43:20]
    node _sourceLeft_T = eq(sourceLeftInput, UInt<1>("h0")) @[ALU.scala 45:25]
    node _sourceLeft_T_1 = sub(sourceLeftInput, UInt<1>("h1")) @[ALU.scala 45:61]
    node _sourceLeft_T_2 = tail(_sourceLeft_T_1, 1) @[ALU.scala 45:61]
    node sourceLeft = mux(_sourceLeft_T, input, reg[UInt<1>("h0")]) @[ALU.scala 45:8]
    node _sourceRight_T = eq(sourceRightInput, UInt<1>("h0")) @[ALU.scala 47:26]
    node _sourceRight_T_1 = sub(sourceRightInput, UInt<1>("h1")) @[ALU.scala 47:63]
    node _sourceRight_T_2 = tail(_sourceRight_T_1, 1) @[ALU.scala 47:63]
    node sourceRight = mux(_sourceRight_T, input, reg[UInt<1>("h0")]) @[ALU.scala 47:8]
    node _dest_T = eq(destInput, UInt<1>("h0")) @[ALU.scala 51:17]
    node _dest_T_1 = eq(op, UInt<1>("h0")) @[ALU.scala 51:31]
    node _dest_T_2 = or(_dest_T, _dest_T_1) @[ALU.scala 51:25]
    node _dest_T_3 = sub(destInput, UInt<1>("h1")) @[ALU.scala 53:21]
    node _dest_T_4 = tail(_dest_T_3, 1) @[ALU.scala 53:21]
    wire dest : Fixed<16><<8>> @[Demux.scala 11:21]
    when _dest_T_2 : @[Demux.scala 12:16]
      io.output <= dest @[Demux.scala 13:11]
    else :
      reg[UInt<1>("h0")] <= dest @[Demux.scala 15:11]
    wire result : Fixed<16><<8>> @[ALU.scala 56:20]
    reg output : Fixed<<8>>, clock with :
      reset => (UInt<1>("h0"), output) @[ALU.scala 57:43]
    output <= result @[ALU.scala 57:43]
    io.output <= output @[ALU.scala 58:13]
    dest <= result @[ALU.scala 59:8]
    result <= input @[ALU.scala 62:10]
    node _T = eq(op, UInt<1>("h1")) @[ALU.scala 64:11]
    when _T : @[ALU.scala 64:26]
      wire _result_WIRE : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_1 = asFixedPoint(_result_T, 8) @[package.scala 74:56]
      _result_WIRE <= _result_T_1 @[package.scala 74:56]
      result <= _result_WIRE @[ALU.scala 65:12]
    node _T_1 = eq(op, UInt<2>("h2")) @[ALU.scala 67:11]
    when _T_1 : @[ALU.scala 67:26]
      result <= sourceLeft @[ALU.scala 68:12]
    node _T_2 = eq(op, UInt<2>("h3")) @[ALU.scala 72:11]
    when _T_2 : @[ALU.scala 72:25]
      wire _result_WIRE_1 : Fixed<16><<8>> @[package.scala 82:56]
      node _result_T_2 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
      node _result_T_3 = asFixedPoint(_result_T_2, 8) @[package.scala 82:56]
      _result_WIRE_1 <= _result_T_3 @[package.scala 82:56]
      result <= _result_WIRE_1 @[ALU.scala 73:12]
      wire _WIRE : Fixed<<8>> @[package.scala 74:56]
      node _T_3 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_4 = asFixedPoint(_T_3, 8) @[package.scala 74:56]
      _WIRE <= _T_4 @[package.scala 74:56]
      node _T_5 = geq(sourceLeft, _WIRE) @[ALU.scala 132:45]
      node _T_6 = geq(_WIRE, sourceLeft) @[ALU.scala 132:63]
      node _T_7 = and(_T_5, _T_6) @[ALU.scala 132:54]
      node _T_8 = eq(_T_7, UInt<1>("h0")) @[ALU.scala 131:40]
      when _T_8 : @[ALU.scala 74:30]
        wire _result_WIRE_2 : Fixed<16><<8>> @[package.scala 74:56]
        node _result_T_4 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
        node _result_T_5 = asFixedPoint(_result_T_4, 8) @[package.scala 74:56]
        _result_WIRE_2 <= _result_T_5 @[package.scala 74:56]
        result <= _result_WIRE_2 @[ALU.scala 75:14]
    node _T_9 = eq(op, UInt<3>("h4")) @[ALU.scala 78:11]
    when _T_9 : @[ALU.scala 78:25]
      wire _result_WIRE_3 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_6 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_7 = asFixedPoint(_result_T_6, 8) @[package.scala 74:56]
      _result_WIRE_3 <= _result_T_7 @[package.scala 74:56]
      result <= _result_WIRE_3 @[ALU.scala 79:12]
      wire _WIRE_1 : Fixed<<8>> @[package.scala 74:56]
      node _T_10 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_11 = asFixedPoint(_T_10, 8) @[package.scala 74:56]
      _WIRE_1 <= _T_11 @[package.scala 74:56]
      node _T_12 = geq(sourceLeft, _WIRE_1) @[ALU.scala 132:45]
      node _T_13 = geq(_WIRE_1, sourceLeft) @[ALU.scala 132:63]
      node _T_14 = and(_T_12, _T_13) @[ALU.scala 132:54]
      node _T_15 = eq(_T_14, UInt<1>("h0")) @[ALU.scala 131:40]
      wire _WIRE_2 : Fixed<<8>> @[package.scala 74:56]
      node _T_16 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_17 = asFixedPoint(_T_16, 8) @[package.scala 74:56]
      _WIRE_2 <= _T_17 @[package.scala 74:56]
      node _T_18 = geq(sourceRight, _WIRE_2) @[ALU.scala 132:45]
      node _T_19 = geq(_WIRE_2, sourceRight) @[ALU.scala 132:63]
      node _T_20 = and(_T_18, _T_19) @[ALU.scala 132:54]
      node _T_21 = eq(_T_20, UInt<1>("h0")) @[ALU.scala 131:40]
      node _T_22 = and(_T_15, _T_21) @[ALU.scala 80:29]
      when _T_22 : @[ALU.scala 80:53]
        wire _result_WIRE_4 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_8 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_9 = asFixedPoint(_result_T_8, 8) @[package.scala 82:56]
        _result_WIRE_4 <= _result_T_9 @[package.scala 82:56]
        result <= _result_WIRE_4 @[ALU.scala 81:14]
    node _T_23 = eq(op, UInt<3>("h5")) @[ALU.scala 84:11]
    when _T_23 : @[ALU.scala 84:24]
      wire _result_WIRE_5 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_10 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_11 = asFixedPoint(_result_T_10, 8) @[package.scala 74:56]
      _result_WIRE_5 <= _result_T_11 @[package.scala 74:56]
      result <= _result_WIRE_5 @[ALU.scala 85:12]
      wire _WIRE_3 : Fixed<<8>> @[package.scala 74:56]
      node _T_24 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_25 = asFixedPoint(_T_24, 8) @[package.scala 74:56]
      _WIRE_3 <= _T_25 @[package.scala 74:56]
      node _T_26 = geq(sourceLeft, _WIRE_3) @[ALU.scala 132:45]
      node _T_27 = geq(_WIRE_3, sourceLeft) @[ALU.scala 132:63]
      node _T_28 = and(_T_26, _T_27) @[ALU.scala 132:54]
      node _T_29 = eq(_T_28, UInt<1>("h0")) @[ALU.scala 131:40]
      wire _WIRE_4 : Fixed<<8>> @[package.scala 74:56]
      node _T_30 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_31 = asFixedPoint(_T_30, 8) @[package.scala 74:56]
      _WIRE_4 <= _T_31 @[package.scala 74:56]
      node _T_32 = geq(sourceRight, _WIRE_4) @[ALU.scala 132:45]
      node _T_33 = geq(_WIRE_4, sourceRight) @[ALU.scala 132:63]
      node _T_34 = and(_T_32, _T_33) @[ALU.scala 132:54]
      node _T_35 = eq(_T_34, UInt<1>("h0")) @[ALU.scala 131:40]
      node _T_36 = or(_T_29, _T_35) @[ALU.scala 86:29]
      when _T_36 : @[ALU.scala 86:53]
        wire _result_WIRE_6 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_12 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_13 = asFixedPoint(_result_T_12, 8) @[package.scala 82:56]
        _result_WIRE_6 <= _result_T_13 @[package.scala 82:56]
        result <= _result_WIRE_6 @[ALU.scala 87:14]
    node _T_37 = eq(op, UInt<3>("h6")) @[ALU.scala 92:11]
    when _T_37 : @[ALU.scala 92:31]
      wire _result_WIRE_7 : Fixed<16><<8>> @[package.scala 82:56]
      node _result_T_14 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
      node _result_T_15 = asFixedPoint(_result_T_14, 8) @[package.scala 82:56]
      _result_WIRE_7 <= _result_T_15 @[package.scala 82:56]
      node _result_T_16 = asSInt(sourceLeft) @[package.scala 163:37]
      node _result_T_17 = asSInt(_result_WIRE_7) @[package.scala 163:49]
      node _result_T_18 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T = mul(_result_T_16, _result_T_18) @[package.scala 117:18]
      node _result_mac_T_1 = shl(_result_T_17, 8) @[package.scala 117:29]
      node result_mac = add(_result_mac_T, _result_mac_T_1) @[package.scala 117:23]
      node result_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_1 = sub(_result_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_2 = tail(_result_mask1_T_1, 1) @[package.scala 120:44]
      node result_mask1 = asSInt(_result_mask1_T_2) @[package.scala 120:44]
      node result_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T = and(result_mac, result_mask0) @[package.scala 125:16]
      node _result_adjustment_T_1 = asSInt(_result_adjustment_T) @[package.scala 125:16]
      node _result_adjustment_T_2 = neq(_result_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_3 = and(result_mac, result_mask1) @[package.scala 125:44]
      node _result_adjustment_T_4 = asSInt(_result_adjustment_T_3) @[package.scala 125:44]
      node _result_adjustment_T_5 = neq(_result_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_6 = and(result_mac, result_mask2) @[package.scala 125:71]
      node _result_adjustment_T_7 = asSInt(_result_adjustment_T_6) @[package.scala 125:71]
      node _result_adjustment_T_8 = neq(_result_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_9 = or(_result_adjustment_T_5, _result_adjustment_T_8) @[package.scala 125:62]
      node _result_adjustment_T_10 = and(_result_adjustment_T_2, _result_adjustment_T_9) @[package.scala 125:34]
      node result_adjustment = mux(_result_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T = shr(result_mac, 8) @[package.scala 130:26]
      node _result_adjusted_T_1 = add(_result_adjusted_T, result_adjustment) @[package.scala 130:42]
      node _result_adjusted_T_2 = tail(_result_adjusted_T_1, 1) @[package.scala 130:42]
      node result_adjusted = asSInt(_result_adjusted_T_2) @[package.scala 130:42]
      node _result_saturated_T = gt(result_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_1 = lt(result_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_2 = mux(_result_saturated_T_1, asSInt(UInt<16>("h8000")), result_adjusted) @[package.scala 98:26]
      node result_saturated = mux(_result_saturated_T, asSInt(UInt<16>("h7fff")), _result_saturated_T_2) @[package.scala 98:8]
      node _result_T_19 = asFixedPoint(result_saturated, 8) @[package.scala 133:27]
      result <= _result_T_19 @[ALU.scala 93:12]
    node _T_38 = eq(op, UInt<3>("h7")) @[ALU.scala 95:11]
    when _T_38 : @[ALU.scala 95:31]
      wire _result_WIRE_8 : Fixed<16><<8>> @[package.scala 82:56]
      node _result_T_20 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
      node _result_T_21 = asFixedPoint(_result_T_20, 8) @[package.scala 82:56]
      _result_WIRE_8 <= _result_T_21 @[package.scala 82:56]
      node _result_T_22 = asSInt(sourceLeft) @[package.scala 171:37]
      node _result_T_23 = asSInt(_result_WIRE_8) @[package.scala 171:56]
      node _result_T_24 = sub(asSInt(UInt<1>("h0")), _result_T_23) @[package.scala 171:45]
      node _result_T_25 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T_2 = mul(_result_T_22, _result_T_25) @[package.scala 117:18]
      node _result_mac_T_3 = shl(_result_T_24, 8) @[package.scala 117:29]
      node result_mac_1 = add(_result_mac_T_2, _result_mac_T_3) @[package.scala 117:23]
      node result_mask0_1 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_3 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_4 = sub(_result_mask1_T_3, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_5 = tail(_result_mask1_T_4, 1) @[package.scala 120:44]
      node result_mask1_1 = asSInt(_result_mask1_T_5) @[package.scala 120:44]
      node result_mask2_1 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_11 = and(result_mac_1, result_mask0_1) @[package.scala 125:16]
      node _result_adjustment_T_12 = asSInt(_result_adjustment_T_11) @[package.scala 125:16]
      node _result_adjustment_T_13 = neq(_result_adjustment_T_12, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_14 = and(result_mac_1, result_mask1_1) @[package.scala 125:44]
      node _result_adjustment_T_15 = asSInt(_result_adjustment_T_14) @[package.scala 125:44]
      node _result_adjustment_T_16 = neq(_result_adjustment_T_15, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_17 = and(result_mac_1, result_mask2_1) @[package.scala 125:71]
      node _result_adjustment_T_18 = asSInt(_result_adjustment_T_17) @[package.scala 125:71]
      node _result_adjustment_T_19 = neq(_result_adjustment_T_18, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_20 = or(_result_adjustment_T_16, _result_adjustment_T_19) @[package.scala 125:62]
      node _result_adjustment_T_21 = and(_result_adjustment_T_13, _result_adjustment_T_20) @[package.scala 125:34]
      node result_adjustment_1 = mux(_result_adjustment_T_21, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_3 = shr(result_mac_1, 8) @[package.scala 130:26]
      node _result_adjusted_T_4 = add(_result_adjusted_T_3, result_adjustment_1) @[package.scala 130:42]
      node _result_adjusted_T_5 = tail(_result_adjusted_T_4, 1) @[package.scala 130:42]
      node result_adjusted_1 = asSInt(_result_adjusted_T_5) @[package.scala 130:42]
      node _result_saturated_T_3 = gt(result_adjusted_1, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_4 = lt(result_adjusted_1, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_5 = mux(_result_saturated_T_4, asSInt(UInt<16>("h8000")), result_adjusted_1) @[package.scala 98:26]
      node result_saturated_1 = mux(_result_saturated_T_3, asSInt(UInt<16>("h7fff")), _result_saturated_T_5) @[package.scala 98:8]
      node _result_T_26 = asFixedPoint(result_saturated_1, 8) @[package.scala 133:27]
      result <= _result_T_26 @[ALU.scala 96:12]
    node _T_39 = eq(op, UInt<4>("h8")) @[ALU.scala 98:11]
    when _T_39 : @[ALU.scala 98:25]
      node _result_T_27 = asSInt(sourceLeft) @[package.scala 163:37]
      node _result_T_28 = asSInt(sourceRight) @[package.scala 163:49]
      node _result_T_29 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T_4 = mul(_result_T_27, _result_T_29) @[package.scala 117:18]
      node _result_mac_T_5 = shl(_result_T_28, 8) @[package.scala 117:29]
      node result_mac_2 = add(_result_mac_T_4, _result_mac_T_5) @[package.scala 117:23]
      node result_mask0_2 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_6 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_7 = sub(_result_mask1_T_6, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_8 = tail(_result_mask1_T_7, 1) @[package.scala 120:44]
      node result_mask1_2 = asSInt(_result_mask1_T_8) @[package.scala 120:44]
      node result_mask2_2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_22 = and(result_mac_2, result_mask0_2) @[package.scala 125:16]
      node _result_adjustment_T_23 = asSInt(_result_adjustment_T_22) @[package.scala 125:16]
      node _result_adjustment_T_24 = neq(_result_adjustment_T_23, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_25 = and(result_mac_2, result_mask1_2) @[package.scala 125:44]
      node _result_adjustment_T_26 = asSInt(_result_adjustment_T_25) @[package.scala 125:44]
      node _result_adjustment_T_27 = neq(_result_adjustment_T_26, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_28 = and(result_mac_2, result_mask2_2) @[package.scala 125:71]
      node _result_adjustment_T_29 = asSInt(_result_adjustment_T_28) @[package.scala 125:71]
      node _result_adjustment_T_30 = neq(_result_adjustment_T_29, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_31 = or(_result_adjustment_T_27, _result_adjustment_T_30) @[package.scala 125:62]
      node _result_adjustment_T_32 = and(_result_adjustment_T_24, _result_adjustment_T_31) @[package.scala 125:34]
      node result_adjustment_2 = mux(_result_adjustment_T_32, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_6 = shr(result_mac_2, 8) @[package.scala 130:26]
      node _result_adjusted_T_7 = add(_result_adjusted_T_6, result_adjustment_2) @[package.scala 130:42]
      node _result_adjusted_T_8 = tail(_result_adjusted_T_7, 1) @[package.scala 130:42]
      node result_adjusted_2 = asSInt(_result_adjusted_T_8) @[package.scala 130:42]
      node _result_saturated_T_6 = gt(result_adjusted_2, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_7 = lt(result_adjusted_2, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_8 = mux(_result_saturated_T_7, asSInt(UInt<16>("h8000")), result_adjusted_2) @[package.scala 98:26]
      node result_saturated_2 = mux(_result_saturated_T_6, asSInt(UInt<16>("h7fff")), _result_saturated_T_8) @[package.scala 98:8]
      node _result_T_30 = asFixedPoint(result_saturated_2, 8) @[package.scala 133:27]
      result <= _result_T_30 @[ALU.scala 99:12]
    node _T_40 = eq(op, UInt<4>("h9")) @[ALU.scala 101:11]
    when _T_40 : @[ALU.scala 101:30]
      node _result_T_31 = asSInt(sourceLeft) @[package.scala 171:37]
      node _result_T_32 = asSInt(sourceRight) @[package.scala 171:56]
      node _result_T_33 = sub(asSInt(UInt<1>("h0")), _result_T_32) @[package.scala 171:45]
      node _result_T_34 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T_6 = mul(_result_T_31, _result_T_34) @[package.scala 117:18]
      node _result_mac_T_7 = shl(_result_T_33, 8) @[package.scala 117:29]
      node result_mac_3 = add(_result_mac_T_6, _result_mac_T_7) @[package.scala 117:23]
      node result_mask0_3 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_9 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_10 = sub(_result_mask1_T_9, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_11 = tail(_result_mask1_T_10, 1) @[package.scala 120:44]
      node result_mask1_3 = asSInt(_result_mask1_T_11) @[package.scala 120:44]
      node result_mask2_3 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_33 = and(result_mac_3, result_mask0_3) @[package.scala 125:16]
      node _result_adjustment_T_34 = asSInt(_result_adjustment_T_33) @[package.scala 125:16]
      node _result_adjustment_T_35 = neq(_result_adjustment_T_34, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_36 = and(result_mac_3, result_mask1_3) @[package.scala 125:44]
      node _result_adjustment_T_37 = asSInt(_result_adjustment_T_36) @[package.scala 125:44]
      node _result_adjustment_T_38 = neq(_result_adjustment_T_37, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_39 = and(result_mac_3, result_mask2_3) @[package.scala 125:71]
      node _result_adjustment_T_40 = asSInt(_result_adjustment_T_39) @[package.scala 125:71]
      node _result_adjustment_T_41 = neq(_result_adjustment_T_40, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_42 = or(_result_adjustment_T_38, _result_adjustment_T_41) @[package.scala 125:62]
      node _result_adjustment_T_43 = and(_result_adjustment_T_35, _result_adjustment_T_42) @[package.scala 125:34]
      node result_adjustment_3 = mux(_result_adjustment_T_43, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_9 = shr(result_mac_3, 8) @[package.scala 130:26]
      node _result_adjusted_T_10 = add(_result_adjusted_T_9, result_adjustment_3) @[package.scala 130:42]
      node _result_adjusted_T_11 = tail(_result_adjusted_T_10, 1) @[package.scala 130:42]
      node result_adjusted_3 = asSInt(_result_adjusted_T_11) @[package.scala 130:42]
      node _result_saturated_T_9 = gt(result_adjusted_3, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_10 = lt(result_adjusted_3, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_11 = mux(_result_saturated_T_10, asSInt(UInt<16>("h8000")), result_adjusted_3) @[package.scala 98:26]
      node result_saturated_3 = mux(_result_saturated_T_9, asSInt(UInt<16>("h7fff")), _result_saturated_T_11) @[package.scala 98:8]
      node _result_T_35 = asFixedPoint(result_saturated_3, 8) @[package.scala 133:27]
      result <= _result_T_35 @[ALU.scala 102:12]
    node _T_41 = eq(op, UInt<4>("ha")) @[ALU.scala 104:11]
    when _T_41 : @[ALU.scala 104:30]
      node _result_T_36 = asSInt(sourceLeft) @[package.scala 155:38]
      node _result_T_37 = asSInt(sourceRight) @[package.scala 155:50]
      node _result_mac_T_8 = mul(_result_T_36, _result_T_37) @[package.scala 117:18]
      node _result_mac_T_9 = shl(asSInt(UInt<1>("h0")), 8) @[package.scala 117:29]
      node result_mac_4 = add(_result_mac_T_8, _result_mac_T_9) @[package.scala 117:23]
      node result_mask0_4 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_12 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_13 = sub(_result_mask1_T_12, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_14 = tail(_result_mask1_T_13, 1) @[package.scala 120:44]
      node result_mask1_4 = asSInt(_result_mask1_T_14) @[package.scala 120:44]
      node result_mask2_4 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_44 = and(result_mac_4, result_mask0_4) @[package.scala 125:16]
      node _result_adjustment_T_45 = asSInt(_result_adjustment_T_44) @[package.scala 125:16]
      node _result_adjustment_T_46 = neq(_result_adjustment_T_45, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_47 = and(result_mac_4, result_mask1_4) @[package.scala 125:44]
      node _result_adjustment_T_48 = asSInt(_result_adjustment_T_47) @[package.scala 125:44]
      node _result_adjustment_T_49 = neq(_result_adjustment_T_48, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_50 = and(result_mac_4, result_mask2_4) @[package.scala 125:71]
      node _result_adjustment_T_51 = asSInt(_result_adjustment_T_50) @[package.scala 125:71]
      node _result_adjustment_T_52 = neq(_result_adjustment_T_51, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_53 = or(_result_adjustment_T_49, _result_adjustment_T_52) @[package.scala 125:62]
      node _result_adjustment_T_54 = and(_result_adjustment_T_46, _result_adjustment_T_53) @[package.scala 125:34]
      node result_adjustment_4 = mux(_result_adjustment_T_54, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_12 = shr(result_mac_4, 8) @[package.scala 130:26]
      node _result_adjusted_T_13 = add(_result_adjusted_T_12, result_adjustment_4) @[package.scala 130:42]
      node _result_adjusted_T_14 = tail(_result_adjusted_T_13, 1) @[package.scala 130:42]
      node result_adjusted_4 = asSInt(_result_adjusted_T_14) @[package.scala 130:42]
      node _result_saturated_T_12 = gt(result_adjusted_4, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_13 = lt(result_adjusted_4, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_14 = mux(_result_saturated_T_13, asSInt(UInt<16>("h8000")), result_adjusted_4) @[package.scala 98:26]
      node result_saturated_4 = mux(_result_saturated_T_12, asSInt(UInt<16>("h7fff")), _result_saturated_T_14) @[package.scala 98:8]
      node _result_T_38 = asFixedPoint(result_saturated_4, 8) @[package.scala 133:27]
      result <= _result_T_38 @[ALU.scala 105:12]
    node _T_42 = eq(op, UInt<4>("hb")) @[ALU.scala 107:11]
    when _T_42 : @[ALU.scala 107:25]
      node _result_T_39 = lt(sourceLeft, asFixedPoint(UInt<1>("h0"), 0)) @[ALU.scala 108:26]
      node _result_T_40 = sub(asFixedPoint(UInt<1>("h0"), 0), sourceLeft) @[ALU.scala 108:26]
      node _result_T_41 = tail(_result_T_40, 1) @[ALU.scala 108:26]
      node _result_T_42 = asFixedPoint(_result_T_41, 8) @[ALU.scala 108:26]
      node _result_T_43 = mux(_result_T_39, _result_T_42, sourceLeft) @[ALU.scala 108:26]
      result <= _result_T_43 @[ALU.scala 108:12]
    node _T_43 = eq(op, UInt<4>("hc")) @[ALU.scala 112:11]
    when _T_43 : @[ALU.scala 112:33]
      wire _result_WIRE_9 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_44 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_45 = asFixedPoint(_result_T_44, 8) @[package.scala 74:56]
      _result_WIRE_9 <= _result_T_45 @[package.scala 74:56]
      result <= _result_WIRE_9 @[ALU.scala 113:12]
      node _T_44 = gt(sourceLeft, sourceRight) @[ALU.scala 114:21]
      when _T_44 : @[ALU.scala 114:36]
        wire _result_WIRE_10 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_46 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_47 = asFixedPoint(_result_T_46, 8) @[package.scala 82:56]
        _result_WIRE_10 <= _result_T_47 @[package.scala 82:56]
        result <= _result_WIRE_10 @[ALU.scala 115:14]
    node _T_45 = eq(op, UInt<4>("hd")) @[ALU.scala 118:11]
    when _T_45 : @[ALU.scala 118:38]
      wire _result_WIRE_11 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_48 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_49 = asFixedPoint(_result_T_48, 8) @[package.scala 74:56]
      _result_WIRE_11 <= _result_T_49 @[package.scala 74:56]
      result <= _result_WIRE_11 @[ALU.scala 119:12]
      node _T_46 = geq(sourceLeft, sourceRight) @[ALU.scala 120:21]
      when _T_46 : @[ALU.scala 120:37]
        wire _result_WIRE_12 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_50 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_51 = asFixedPoint(_result_T_50, 8) @[package.scala 82:56]
        _result_WIRE_12 <= _result_T_51 @[package.scala 82:56]
        result <= _result_WIRE_12 @[ALU.scala 121:14]
    node _T_47 = eq(op, UInt<4>("he")) @[ALU.scala 124:11]
    when _T_47 : @[ALU.scala 124:25]
      node _result_T_52 = lt(sourceLeft, sourceRight) @[ALU.scala 125:29]
      node _result_T_53 = mux(_result_T_52, sourceLeft, sourceRight) @[ALU.scala 125:29]
      result <= _result_T_53 @[ALU.scala 125:12]
    node _T_48 = eq(op, UInt<4>("hf")) @[ALU.scala 127:11]
    when _T_48 : @[ALU.scala 127:25]
      node _result_T_54 = lt(sourceLeft, sourceRight) @[ALU.scala 128:29]
      node _result_T_55 = mux(_result_T_54, sourceRight, sourceLeft) @[ALU.scala 128:29]
      result <= _result_T_55 @[ALU.scala 128:12]

  module ALU_6 :
    input clock : Clock
    input reset : Reset
    output io : { flip op : UInt<4>, flip input : Fixed<16><<8>>, flip sourceLeft : UInt<1>, flip sourceRight : UInt<1>, flip dest : UInt<1>, output : Fixed<16><<8>>}

    reg op : UInt, clock with :
      reset => (UInt<1>("h0"), op) @[ALU.scala 35:42]
    op <= io.op @[ALU.scala 35:42]
    reg input : Fixed<<8>>, clock with :
      reset => (UInt<1>("h0"), input) @[ALU.scala 36:42]
    input <= io.input @[ALU.scala 36:42]
    reg sourceLeftInput : UInt, clock with :
      reset => (UInt<1>("h0"), sourceLeftInput) @[ALU.scala 38:32]
    sourceLeftInput <= io.sourceLeft @[ALU.scala 38:32]
    reg sourceRightInput : UInt, clock with :
      reset => (UInt<1>("h0"), sourceRightInput) @[ALU.scala 40:32]
    sourceRightInput <= io.sourceRight @[ALU.scala 40:32]
    reg destInput : UInt, clock with :
      reset => (UInt<1>("h0"), destInput) @[ALU.scala 41:46]
    destInput <= io.dest @[ALU.scala 41:46]
    wire _reg_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _reg_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _reg_T_1 = asFixedPoint(_reg_T, 8) @[package.scala 74:56]
    _reg_WIRE <= _reg_T_1 @[package.scala 74:56]
    wire _reg_WIRE_1 : Fixed<16><<8>>[1] @[ALU.scala 43:28]
    _reg_WIRE_1[0] <= _reg_WIRE @[ALU.scala 43:28]
    reg reg : Fixed<16><<8>>[1], clock with :
      reset => (reset, _reg_WIRE_1) @[ALU.scala 43:20]
    node _sourceLeft_T = eq(sourceLeftInput, UInt<1>("h0")) @[ALU.scala 45:25]
    node _sourceLeft_T_1 = sub(sourceLeftInput, UInt<1>("h1")) @[ALU.scala 45:61]
    node _sourceLeft_T_2 = tail(_sourceLeft_T_1, 1) @[ALU.scala 45:61]
    node sourceLeft = mux(_sourceLeft_T, input, reg[UInt<1>("h0")]) @[ALU.scala 45:8]
    node _sourceRight_T = eq(sourceRightInput, UInt<1>("h0")) @[ALU.scala 47:26]
    node _sourceRight_T_1 = sub(sourceRightInput, UInt<1>("h1")) @[ALU.scala 47:63]
    node _sourceRight_T_2 = tail(_sourceRight_T_1, 1) @[ALU.scala 47:63]
    node sourceRight = mux(_sourceRight_T, input, reg[UInt<1>("h0")]) @[ALU.scala 47:8]
    node _dest_T = eq(destInput, UInt<1>("h0")) @[ALU.scala 51:17]
    node _dest_T_1 = eq(op, UInt<1>("h0")) @[ALU.scala 51:31]
    node _dest_T_2 = or(_dest_T, _dest_T_1) @[ALU.scala 51:25]
    node _dest_T_3 = sub(destInput, UInt<1>("h1")) @[ALU.scala 53:21]
    node _dest_T_4 = tail(_dest_T_3, 1) @[ALU.scala 53:21]
    wire dest : Fixed<16><<8>> @[Demux.scala 11:21]
    when _dest_T_2 : @[Demux.scala 12:16]
      io.output <= dest @[Demux.scala 13:11]
    else :
      reg[UInt<1>("h0")] <= dest @[Demux.scala 15:11]
    wire result : Fixed<16><<8>> @[ALU.scala 56:20]
    reg output : Fixed<<8>>, clock with :
      reset => (UInt<1>("h0"), output) @[ALU.scala 57:43]
    output <= result @[ALU.scala 57:43]
    io.output <= output @[ALU.scala 58:13]
    dest <= result @[ALU.scala 59:8]
    result <= input @[ALU.scala 62:10]
    node _T = eq(op, UInt<1>("h1")) @[ALU.scala 64:11]
    when _T : @[ALU.scala 64:26]
      wire _result_WIRE : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_1 = asFixedPoint(_result_T, 8) @[package.scala 74:56]
      _result_WIRE <= _result_T_1 @[package.scala 74:56]
      result <= _result_WIRE @[ALU.scala 65:12]
    node _T_1 = eq(op, UInt<2>("h2")) @[ALU.scala 67:11]
    when _T_1 : @[ALU.scala 67:26]
      result <= sourceLeft @[ALU.scala 68:12]
    node _T_2 = eq(op, UInt<2>("h3")) @[ALU.scala 72:11]
    when _T_2 : @[ALU.scala 72:25]
      wire _result_WIRE_1 : Fixed<16><<8>> @[package.scala 82:56]
      node _result_T_2 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
      node _result_T_3 = asFixedPoint(_result_T_2, 8) @[package.scala 82:56]
      _result_WIRE_1 <= _result_T_3 @[package.scala 82:56]
      result <= _result_WIRE_1 @[ALU.scala 73:12]
      wire _WIRE : Fixed<<8>> @[package.scala 74:56]
      node _T_3 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_4 = asFixedPoint(_T_3, 8) @[package.scala 74:56]
      _WIRE <= _T_4 @[package.scala 74:56]
      node _T_5 = geq(sourceLeft, _WIRE) @[ALU.scala 132:45]
      node _T_6 = geq(_WIRE, sourceLeft) @[ALU.scala 132:63]
      node _T_7 = and(_T_5, _T_6) @[ALU.scala 132:54]
      node _T_8 = eq(_T_7, UInt<1>("h0")) @[ALU.scala 131:40]
      when _T_8 : @[ALU.scala 74:30]
        wire _result_WIRE_2 : Fixed<16><<8>> @[package.scala 74:56]
        node _result_T_4 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
        node _result_T_5 = asFixedPoint(_result_T_4, 8) @[package.scala 74:56]
        _result_WIRE_2 <= _result_T_5 @[package.scala 74:56]
        result <= _result_WIRE_2 @[ALU.scala 75:14]
    node _T_9 = eq(op, UInt<3>("h4")) @[ALU.scala 78:11]
    when _T_9 : @[ALU.scala 78:25]
      wire _result_WIRE_3 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_6 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_7 = asFixedPoint(_result_T_6, 8) @[package.scala 74:56]
      _result_WIRE_3 <= _result_T_7 @[package.scala 74:56]
      result <= _result_WIRE_3 @[ALU.scala 79:12]
      wire _WIRE_1 : Fixed<<8>> @[package.scala 74:56]
      node _T_10 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_11 = asFixedPoint(_T_10, 8) @[package.scala 74:56]
      _WIRE_1 <= _T_11 @[package.scala 74:56]
      node _T_12 = geq(sourceLeft, _WIRE_1) @[ALU.scala 132:45]
      node _T_13 = geq(_WIRE_1, sourceLeft) @[ALU.scala 132:63]
      node _T_14 = and(_T_12, _T_13) @[ALU.scala 132:54]
      node _T_15 = eq(_T_14, UInt<1>("h0")) @[ALU.scala 131:40]
      wire _WIRE_2 : Fixed<<8>> @[package.scala 74:56]
      node _T_16 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_17 = asFixedPoint(_T_16, 8) @[package.scala 74:56]
      _WIRE_2 <= _T_17 @[package.scala 74:56]
      node _T_18 = geq(sourceRight, _WIRE_2) @[ALU.scala 132:45]
      node _T_19 = geq(_WIRE_2, sourceRight) @[ALU.scala 132:63]
      node _T_20 = and(_T_18, _T_19) @[ALU.scala 132:54]
      node _T_21 = eq(_T_20, UInt<1>("h0")) @[ALU.scala 131:40]
      node _T_22 = and(_T_15, _T_21) @[ALU.scala 80:29]
      when _T_22 : @[ALU.scala 80:53]
        wire _result_WIRE_4 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_8 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_9 = asFixedPoint(_result_T_8, 8) @[package.scala 82:56]
        _result_WIRE_4 <= _result_T_9 @[package.scala 82:56]
        result <= _result_WIRE_4 @[ALU.scala 81:14]
    node _T_23 = eq(op, UInt<3>("h5")) @[ALU.scala 84:11]
    when _T_23 : @[ALU.scala 84:24]
      wire _result_WIRE_5 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_10 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_11 = asFixedPoint(_result_T_10, 8) @[package.scala 74:56]
      _result_WIRE_5 <= _result_T_11 @[package.scala 74:56]
      result <= _result_WIRE_5 @[ALU.scala 85:12]
      wire _WIRE_3 : Fixed<<8>> @[package.scala 74:56]
      node _T_24 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_25 = asFixedPoint(_T_24, 8) @[package.scala 74:56]
      _WIRE_3 <= _T_25 @[package.scala 74:56]
      node _T_26 = geq(sourceLeft, _WIRE_3) @[ALU.scala 132:45]
      node _T_27 = geq(_WIRE_3, sourceLeft) @[ALU.scala 132:63]
      node _T_28 = and(_T_26, _T_27) @[ALU.scala 132:54]
      node _T_29 = eq(_T_28, UInt<1>("h0")) @[ALU.scala 131:40]
      wire _WIRE_4 : Fixed<<8>> @[package.scala 74:56]
      node _T_30 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_31 = asFixedPoint(_T_30, 8) @[package.scala 74:56]
      _WIRE_4 <= _T_31 @[package.scala 74:56]
      node _T_32 = geq(sourceRight, _WIRE_4) @[ALU.scala 132:45]
      node _T_33 = geq(_WIRE_4, sourceRight) @[ALU.scala 132:63]
      node _T_34 = and(_T_32, _T_33) @[ALU.scala 132:54]
      node _T_35 = eq(_T_34, UInt<1>("h0")) @[ALU.scala 131:40]
      node _T_36 = or(_T_29, _T_35) @[ALU.scala 86:29]
      when _T_36 : @[ALU.scala 86:53]
        wire _result_WIRE_6 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_12 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_13 = asFixedPoint(_result_T_12, 8) @[package.scala 82:56]
        _result_WIRE_6 <= _result_T_13 @[package.scala 82:56]
        result <= _result_WIRE_6 @[ALU.scala 87:14]
    node _T_37 = eq(op, UInt<3>("h6")) @[ALU.scala 92:11]
    when _T_37 : @[ALU.scala 92:31]
      wire _result_WIRE_7 : Fixed<16><<8>> @[package.scala 82:56]
      node _result_T_14 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
      node _result_T_15 = asFixedPoint(_result_T_14, 8) @[package.scala 82:56]
      _result_WIRE_7 <= _result_T_15 @[package.scala 82:56]
      node _result_T_16 = asSInt(sourceLeft) @[package.scala 163:37]
      node _result_T_17 = asSInt(_result_WIRE_7) @[package.scala 163:49]
      node _result_T_18 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T = mul(_result_T_16, _result_T_18) @[package.scala 117:18]
      node _result_mac_T_1 = shl(_result_T_17, 8) @[package.scala 117:29]
      node result_mac = add(_result_mac_T, _result_mac_T_1) @[package.scala 117:23]
      node result_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_1 = sub(_result_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_2 = tail(_result_mask1_T_1, 1) @[package.scala 120:44]
      node result_mask1 = asSInt(_result_mask1_T_2) @[package.scala 120:44]
      node result_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T = and(result_mac, result_mask0) @[package.scala 125:16]
      node _result_adjustment_T_1 = asSInt(_result_adjustment_T) @[package.scala 125:16]
      node _result_adjustment_T_2 = neq(_result_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_3 = and(result_mac, result_mask1) @[package.scala 125:44]
      node _result_adjustment_T_4 = asSInt(_result_adjustment_T_3) @[package.scala 125:44]
      node _result_adjustment_T_5 = neq(_result_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_6 = and(result_mac, result_mask2) @[package.scala 125:71]
      node _result_adjustment_T_7 = asSInt(_result_adjustment_T_6) @[package.scala 125:71]
      node _result_adjustment_T_8 = neq(_result_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_9 = or(_result_adjustment_T_5, _result_adjustment_T_8) @[package.scala 125:62]
      node _result_adjustment_T_10 = and(_result_adjustment_T_2, _result_adjustment_T_9) @[package.scala 125:34]
      node result_adjustment = mux(_result_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T = shr(result_mac, 8) @[package.scala 130:26]
      node _result_adjusted_T_1 = add(_result_adjusted_T, result_adjustment) @[package.scala 130:42]
      node _result_adjusted_T_2 = tail(_result_adjusted_T_1, 1) @[package.scala 130:42]
      node result_adjusted = asSInt(_result_adjusted_T_2) @[package.scala 130:42]
      node _result_saturated_T = gt(result_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_1 = lt(result_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_2 = mux(_result_saturated_T_1, asSInt(UInt<16>("h8000")), result_adjusted) @[package.scala 98:26]
      node result_saturated = mux(_result_saturated_T, asSInt(UInt<16>("h7fff")), _result_saturated_T_2) @[package.scala 98:8]
      node _result_T_19 = asFixedPoint(result_saturated, 8) @[package.scala 133:27]
      result <= _result_T_19 @[ALU.scala 93:12]
    node _T_38 = eq(op, UInt<3>("h7")) @[ALU.scala 95:11]
    when _T_38 : @[ALU.scala 95:31]
      wire _result_WIRE_8 : Fixed<16><<8>> @[package.scala 82:56]
      node _result_T_20 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
      node _result_T_21 = asFixedPoint(_result_T_20, 8) @[package.scala 82:56]
      _result_WIRE_8 <= _result_T_21 @[package.scala 82:56]
      node _result_T_22 = asSInt(sourceLeft) @[package.scala 171:37]
      node _result_T_23 = asSInt(_result_WIRE_8) @[package.scala 171:56]
      node _result_T_24 = sub(asSInt(UInt<1>("h0")), _result_T_23) @[package.scala 171:45]
      node _result_T_25 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T_2 = mul(_result_T_22, _result_T_25) @[package.scala 117:18]
      node _result_mac_T_3 = shl(_result_T_24, 8) @[package.scala 117:29]
      node result_mac_1 = add(_result_mac_T_2, _result_mac_T_3) @[package.scala 117:23]
      node result_mask0_1 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_3 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_4 = sub(_result_mask1_T_3, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_5 = tail(_result_mask1_T_4, 1) @[package.scala 120:44]
      node result_mask1_1 = asSInt(_result_mask1_T_5) @[package.scala 120:44]
      node result_mask2_1 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_11 = and(result_mac_1, result_mask0_1) @[package.scala 125:16]
      node _result_adjustment_T_12 = asSInt(_result_adjustment_T_11) @[package.scala 125:16]
      node _result_adjustment_T_13 = neq(_result_adjustment_T_12, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_14 = and(result_mac_1, result_mask1_1) @[package.scala 125:44]
      node _result_adjustment_T_15 = asSInt(_result_adjustment_T_14) @[package.scala 125:44]
      node _result_adjustment_T_16 = neq(_result_adjustment_T_15, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_17 = and(result_mac_1, result_mask2_1) @[package.scala 125:71]
      node _result_adjustment_T_18 = asSInt(_result_adjustment_T_17) @[package.scala 125:71]
      node _result_adjustment_T_19 = neq(_result_adjustment_T_18, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_20 = or(_result_adjustment_T_16, _result_adjustment_T_19) @[package.scala 125:62]
      node _result_adjustment_T_21 = and(_result_adjustment_T_13, _result_adjustment_T_20) @[package.scala 125:34]
      node result_adjustment_1 = mux(_result_adjustment_T_21, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_3 = shr(result_mac_1, 8) @[package.scala 130:26]
      node _result_adjusted_T_4 = add(_result_adjusted_T_3, result_adjustment_1) @[package.scala 130:42]
      node _result_adjusted_T_5 = tail(_result_adjusted_T_4, 1) @[package.scala 130:42]
      node result_adjusted_1 = asSInt(_result_adjusted_T_5) @[package.scala 130:42]
      node _result_saturated_T_3 = gt(result_adjusted_1, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_4 = lt(result_adjusted_1, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_5 = mux(_result_saturated_T_4, asSInt(UInt<16>("h8000")), result_adjusted_1) @[package.scala 98:26]
      node result_saturated_1 = mux(_result_saturated_T_3, asSInt(UInt<16>("h7fff")), _result_saturated_T_5) @[package.scala 98:8]
      node _result_T_26 = asFixedPoint(result_saturated_1, 8) @[package.scala 133:27]
      result <= _result_T_26 @[ALU.scala 96:12]
    node _T_39 = eq(op, UInt<4>("h8")) @[ALU.scala 98:11]
    when _T_39 : @[ALU.scala 98:25]
      node _result_T_27 = asSInt(sourceLeft) @[package.scala 163:37]
      node _result_T_28 = asSInt(sourceRight) @[package.scala 163:49]
      node _result_T_29 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T_4 = mul(_result_T_27, _result_T_29) @[package.scala 117:18]
      node _result_mac_T_5 = shl(_result_T_28, 8) @[package.scala 117:29]
      node result_mac_2 = add(_result_mac_T_4, _result_mac_T_5) @[package.scala 117:23]
      node result_mask0_2 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_6 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_7 = sub(_result_mask1_T_6, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_8 = tail(_result_mask1_T_7, 1) @[package.scala 120:44]
      node result_mask1_2 = asSInt(_result_mask1_T_8) @[package.scala 120:44]
      node result_mask2_2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_22 = and(result_mac_2, result_mask0_2) @[package.scala 125:16]
      node _result_adjustment_T_23 = asSInt(_result_adjustment_T_22) @[package.scala 125:16]
      node _result_adjustment_T_24 = neq(_result_adjustment_T_23, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_25 = and(result_mac_2, result_mask1_2) @[package.scala 125:44]
      node _result_adjustment_T_26 = asSInt(_result_adjustment_T_25) @[package.scala 125:44]
      node _result_adjustment_T_27 = neq(_result_adjustment_T_26, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_28 = and(result_mac_2, result_mask2_2) @[package.scala 125:71]
      node _result_adjustment_T_29 = asSInt(_result_adjustment_T_28) @[package.scala 125:71]
      node _result_adjustment_T_30 = neq(_result_adjustment_T_29, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_31 = or(_result_adjustment_T_27, _result_adjustment_T_30) @[package.scala 125:62]
      node _result_adjustment_T_32 = and(_result_adjustment_T_24, _result_adjustment_T_31) @[package.scala 125:34]
      node result_adjustment_2 = mux(_result_adjustment_T_32, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_6 = shr(result_mac_2, 8) @[package.scala 130:26]
      node _result_adjusted_T_7 = add(_result_adjusted_T_6, result_adjustment_2) @[package.scala 130:42]
      node _result_adjusted_T_8 = tail(_result_adjusted_T_7, 1) @[package.scala 130:42]
      node result_adjusted_2 = asSInt(_result_adjusted_T_8) @[package.scala 130:42]
      node _result_saturated_T_6 = gt(result_adjusted_2, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_7 = lt(result_adjusted_2, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_8 = mux(_result_saturated_T_7, asSInt(UInt<16>("h8000")), result_adjusted_2) @[package.scala 98:26]
      node result_saturated_2 = mux(_result_saturated_T_6, asSInt(UInt<16>("h7fff")), _result_saturated_T_8) @[package.scala 98:8]
      node _result_T_30 = asFixedPoint(result_saturated_2, 8) @[package.scala 133:27]
      result <= _result_T_30 @[ALU.scala 99:12]
    node _T_40 = eq(op, UInt<4>("h9")) @[ALU.scala 101:11]
    when _T_40 : @[ALU.scala 101:30]
      node _result_T_31 = asSInt(sourceLeft) @[package.scala 171:37]
      node _result_T_32 = asSInt(sourceRight) @[package.scala 171:56]
      node _result_T_33 = sub(asSInt(UInt<1>("h0")), _result_T_32) @[package.scala 171:45]
      node _result_T_34 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T_6 = mul(_result_T_31, _result_T_34) @[package.scala 117:18]
      node _result_mac_T_7 = shl(_result_T_33, 8) @[package.scala 117:29]
      node result_mac_3 = add(_result_mac_T_6, _result_mac_T_7) @[package.scala 117:23]
      node result_mask0_3 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_9 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_10 = sub(_result_mask1_T_9, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_11 = tail(_result_mask1_T_10, 1) @[package.scala 120:44]
      node result_mask1_3 = asSInt(_result_mask1_T_11) @[package.scala 120:44]
      node result_mask2_3 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_33 = and(result_mac_3, result_mask0_3) @[package.scala 125:16]
      node _result_adjustment_T_34 = asSInt(_result_adjustment_T_33) @[package.scala 125:16]
      node _result_adjustment_T_35 = neq(_result_adjustment_T_34, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_36 = and(result_mac_3, result_mask1_3) @[package.scala 125:44]
      node _result_adjustment_T_37 = asSInt(_result_adjustment_T_36) @[package.scala 125:44]
      node _result_adjustment_T_38 = neq(_result_adjustment_T_37, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_39 = and(result_mac_3, result_mask2_3) @[package.scala 125:71]
      node _result_adjustment_T_40 = asSInt(_result_adjustment_T_39) @[package.scala 125:71]
      node _result_adjustment_T_41 = neq(_result_adjustment_T_40, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_42 = or(_result_adjustment_T_38, _result_adjustment_T_41) @[package.scala 125:62]
      node _result_adjustment_T_43 = and(_result_adjustment_T_35, _result_adjustment_T_42) @[package.scala 125:34]
      node result_adjustment_3 = mux(_result_adjustment_T_43, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_9 = shr(result_mac_3, 8) @[package.scala 130:26]
      node _result_adjusted_T_10 = add(_result_adjusted_T_9, result_adjustment_3) @[package.scala 130:42]
      node _result_adjusted_T_11 = tail(_result_adjusted_T_10, 1) @[package.scala 130:42]
      node result_adjusted_3 = asSInt(_result_adjusted_T_11) @[package.scala 130:42]
      node _result_saturated_T_9 = gt(result_adjusted_3, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_10 = lt(result_adjusted_3, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_11 = mux(_result_saturated_T_10, asSInt(UInt<16>("h8000")), result_adjusted_3) @[package.scala 98:26]
      node result_saturated_3 = mux(_result_saturated_T_9, asSInt(UInt<16>("h7fff")), _result_saturated_T_11) @[package.scala 98:8]
      node _result_T_35 = asFixedPoint(result_saturated_3, 8) @[package.scala 133:27]
      result <= _result_T_35 @[ALU.scala 102:12]
    node _T_41 = eq(op, UInt<4>("ha")) @[ALU.scala 104:11]
    when _T_41 : @[ALU.scala 104:30]
      node _result_T_36 = asSInt(sourceLeft) @[package.scala 155:38]
      node _result_T_37 = asSInt(sourceRight) @[package.scala 155:50]
      node _result_mac_T_8 = mul(_result_T_36, _result_T_37) @[package.scala 117:18]
      node _result_mac_T_9 = shl(asSInt(UInt<1>("h0")), 8) @[package.scala 117:29]
      node result_mac_4 = add(_result_mac_T_8, _result_mac_T_9) @[package.scala 117:23]
      node result_mask0_4 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_12 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_13 = sub(_result_mask1_T_12, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_14 = tail(_result_mask1_T_13, 1) @[package.scala 120:44]
      node result_mask1_4 = asSInt(_result_mask1_T_14) @[package.scala 120:44]
      node result_mask2_4 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_44 = and(result_mac_4, result_mask0_4) @[package.scala 125:16]
      node _result_adjustment_T_45 = asSInt(_result_adjustment_T_44) @[package.scala 125:16]
      node _result_adjustment_T_46 = neq(_result_adjustment_T_45, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_47 = and(result_mac_4, result_mask1_4) @[package.scala 125:44]
      node _result_adjustment_T_48 = asSInt(_result_adjustment_T_47) @[package.scala 125:44]
      node _result_adjustment_T_49 = neq(_result_adjustment_T_48, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_50 = and(result_mac_4, result_mask2_4) @[package.scala 125:71]
      node _result_adjustment_T_51 = asSInt(_result_adjustment_T_50) @[package.scala 125:71]
      node _result_adjustment_T_52 = neq(_result_adjustment_T_51, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_53 = or(_result_adjustment_T_49, _result_adjustment_T_52) @[package.scala 125:62]
      node _result_adjustment_T_54 = and(_result_adjustment_T_46, _result_adjustment_T_53) @[package.scala 125:34]
      node result_adjustment_4 = mux(_result_adjustment_T_54, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_12 = shr(result_mac_4, 8) @[package.scala 130:26]
      node _result_adjusted_T_13 = add(_result_adjusted_T_12, result_adjustment_4) @[package.scala 130:42]
      node _result_adjusted_T_14 = tail(_result_adjusted_T_13, 1) @[package.scala 130:42]
      node result_adjusted_4 = asSInt(_result_adjusted_T_14) @[package.scala 130:42]
      node _result_saturated_T_12 = gt(result_adjusted_4, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_13 = lt(result_adjusted_4, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_14 = mux(_result_saturated_T_13, asSInt(UInt<16>("h8000")), result_adjusted_4) @[package.scala 98:26]
      node result_saturated_4 = mux(_result_saturated_T_12, asSInt(UInt<16>("h7fff")), _result_saturated_T_14) @[package.scala 98:8]
      node _result_T_38 = asFixedPoint(result_saturated_4, 8) @[package.scala 133:27]
      result <= _result_T_38 @[ALU.scala 105:12]
    node _T_42 = eq(op, UInt<4>("hb")) @[ALU.scala 107:11]
    when _T_42 : @[ALU.scala 107:25]
      node _result_T_39 = lt(sourceLeft, asFixedPoint(UInt<1>("h0"), 0)) @[ALU.scala 108:26]
      node _result_T_40 = sub(asFixedPoint(UInt<1>("h0"), 0), sourceLeft) @[ALU.scala 108:26]
      node _result_T_41 = tail(_result_T_40, 1) @[ALU.scala 108:26]
      node _result_T_42 = asFixedPoint(_result_T_41, 8) @[ALU.scala 108:26]
      node _result_T_43 = mux(_result_T_39, _result_T_42, sourceLeft) @[ALU.scala 108:26]
      result <= _result_T_43 @[ALU.scala 108:12]
    node _T_43 = eq(op, UInt<4>("hc")) @[ALU.scala 112:11]
    when _T_43 : @[ALU.scala 112:33]
      wire _result_WIRE_9 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_44 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_45 = asFixedPoint(_result_T_44, 8) @[package.scala 74:56]
      _result_WIRE_9 <= _result_T_45 @[package.scala 74:56]
      result <= _result_WIRE_9 @[ALU.scala 113:12]
      node _T_44 = gt(sourceLeft, sourceRight) @[ALU.scala 114:21]
      when _T_44 : @[ALU.scala 114:36]
        wire _result_WIRE_10 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_46 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_47 = asFixedPoint(_result_T_46, 8) @[package.scala 82:56]
        _result_WIRE_10 <= _result_T_47 @[package.scala 82:56]
        result <= _result_WIRE_10 @[ALU.scala 115:14]
    node _T_45 = eq(op, UInt<4>("hd")) @[ALU.scala 118:11]
    when _T_45 : @[ALU.scala 118:38]
      wire _result_WIRE_11 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_48 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_49 = asFixedPoint(_result_T_48, 8) @[package.scala 74:56]
      _result_WIRE_11 <= _result_T_49 @[package.scala 74:56]
      result <= _result_WIRE_11 @[ALU.scala 119:12]
      node _T_46 = geq(sourceLeft, sourceRight) @[ALU.scala 120:21]
      when _T_46 : @[ALU.scala 120:37]
        wire _result_WIRE_12 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_50 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_51 = asFixedPoint(_result_T_50, 8) @[package.scala 82:56]
        _result_WIRE_12 <= _result_T_51 @[package.scala 82:56]
        result <= _result_WIRE_12 @[ALU.scala 121:14]
    node _T_47 = eq(op, UInt<4>("he")) @[ALU.scala 124:11]
    when _T_47 : @[ALU.scala 124:25]
      node _result_T_52 = lt(sourceLeft, sourceRight) @[ALU.scala 125:29]
      node _result_T_53 = mux(_result_T_52, sourceLeft, sourceRight) @[ALU.scala 125:29]
      result <= _result_T_53 @[ALU.scala 125:12]
    node _T_48 = eq(op, UInt<4>("hf")) @[ALU.scala 127:11]
    when _T_48 : @[ALU.scala 127:25]
      node _result_T_54 = lt(sourceLeft, sourceRight) @[ALU.scala 128:29]
      node _result_T_55 = mux(_result_T_54, sourceRight, sourceLeft) @[ALU.scala 128:29]
      result <= _result_T_55 @[ALU.scala 128:12]

  module ALU_7 :
    input clock : Clock
    input reset : Reset
    output io : { flip op : UInt<4>, flip input : Fixed<16><<8>>, flip sourceLeft : UInt<1>, flip sourceRight : UInt<1>, flip dest : UInt<1>, output : Fixed<16><<8>>}

    reg op : UInt, clock with :
      reset => (UInt<1>("h0"), op) @[ALU.scala 35:42]
    op <= io.op @[ALU.scala 35:42]
    reg input : Fixed<<8>>, clock with :
      reset => (UInt<1>("h0"), input) @[ALU.scala 36:42]
    input <= io.input @[ALU.scala 36:42]
    reg sourceLeftInput : UInt, clock with :
      reset => (UInt<1>("h0"), sourceLeftInput) @[ALU.scala 38:32]
    sourceLeftInput <= io.sourceLeft @[ALU.scala 38:32]
    reg sourceRightInput : UInt, clock with :
      reset => (UInt<1>("h0"), sourceRightInput) @[ALU.scala 40:32]
    sourceRightInput <= io.sourceRight @[ALU.scala 40:32]
    reg destInput : UInt, clock with :
      reset => (UInt<1>("h0"), destInput) @[ALU.scala 41:46]
    destInput <= io.dest @[ALU.scala 41:46]
    wire _reg_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _reg_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _reg_T_1 = asFixedPoint(_reg_T, 8) @[package.scala 74:56]
    _reg_WIRE <= _reg_T_1 @[package.scala 74:56]
    wire _reg_WIRE_1 : Fixed<16><<8>>[1] @[ALU.scala 43:28]
    _reg_WIRE_1[0] <= _reg_WIRE @[ALU.scala 43:28]
    reg reg : Fixed<16><<8>>[1], clock with :
      reset => (reset, _reg_WIRE_1) @[ALU.scala 43:20]
    node _sourceLeft_T = eq(sourceLeftInput, UInt<1>("h0")) @[ALU.scala 45:25]
    node _sourceLeft_T_1 = sub(sourceLeftInput, UInt<1>("h1")) @[ALU.scala 45:61]
    node _sourceLeft_T_2 = tail(_sourceLeft_T_1, 1) @[ALU.scala 45:61]
    node sourceLeft = mux(_sourceLeft_T, input, reg[UInt<1>("h0")]) @[ALU.scala 45:8]
    node _sourceRight_T = eq(sourceRightInput, UInt<1>("h0")) @[ALU.scala 47:26]
    node _sourceRight_T_1 = sub(sourceRightInput, UInt<1>("h1")) @[ALU.scala 47:63]
    node _sourceRight_T_2 = tail(_sourceRight_T_1, 1) @[ALU.scala 47:63]
    node sourceRight = mux(_sourceRight_T, input, reg[UInt<1>("h0")]) @[ALU.scala 47:8]
    node _dest_T = eq(destInput, UInt<1>("h0")) @[ALU.scala 51:17]
    node _dest_T_1 = eq(op, UInt<1>("h0")) @[ALU.scala 51:31]
    node _dest_T_2 = or(_dest_T, _dest_T_1) @[ALU.scala 51:25]
    node _dest_T_3 = sub(destInput, UInt<1>("h1")) @[ALU.scala 53:21]
    node _dest_T_4 = tail(_dest_T_3, 1) @[ALU.scala 53:21]
    wire dest : Fixed<16><<8>> @[Demux.scala 11:21]
    when _dest_T_2 : @[Demux.scala 12:16]
      io.output <= dest @[Demux.scala 13:11]
    else :
      reg[UInt<1>("h0")] <= dest @[Demux.scala 15:11]
    wire result : Fixed<16><<8>> @[ALU.scala 56:20]
    reg output : Fixed<<8>>, clock with :
      reset => (UInt<1>("h0"), output) @[ALU.scala 57:43]
    output <= result @[ALU.scala 57:43]
    io.output <= output @[ALU.scala 58:13]
    dest <= result @[ALU.scala 59:8]
    result <= input @[ALU.scala 62:10]
    node _T = eq(op, UInt<1>("h1")) @[ALU.scala 64:11]
    when _T : @[ALU.scala 64:26]
      wire _result_WIRE : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_1 = asFixedPoint(_result_T, 8) @[package.scala 74:56]
      _result_WIRE <= _result_T_1 @[package.scala 74:56]
      result <= _result_WIRE @[ALU.scala 65:12]
    node _T_1 = eq(op, UInt<2>("h2")) @[ALU.scala 67:11]
    when _T_1 : @[ALU.scala 67:26]
      result <= sourceLeft @[ALU.scala 68:12]
    node _T_2 = eq(op, UInt<2>("h3")) @[ALU.scala 72:11]
    when _T_2 : @[ALU.scala 72:25]
      wire _result_WIRE_1 : Fixed<16><<8>> @[package.scala 82:56]
      node _result_T_2 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
      node _result_T_3 = asFixedPoint(_result_T_2, 8) @[package.scala 82:56]
      _result_WIRE_1 <= _result_T_3 @[package.scala 82:56]
      result <= _result_WIRE_1 @[ALU.scala 73:12]
      wire _WIRE : Fixed<<8>> @[package.scala 74:56]
      node _T_3 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_4 = asFixedPoint(_T_3, 8) @[package.scala 74:56]
      _WIRE <= _T_4 @[package.scala 74:56]
      node _T_5 = geq(sourceLeft, _WIRE) @[ALU.scala 132:45]
      node _T_6 = geq(_WIRE, sourceLeft) @[ALU.scala 132:63]
      node _T_7 = and(_T_5, _T_6) @[ALU.scala 132:54]
      node _T_8 = eq(_T_7, UInt<1>("h0")) @[ALU.scala 131:40]
      when _T_8 : @[ALU.scala 74:30]
        wire _result_WIRE_2 : Fixed<16><<8>> @[package.scala 74:56]
        node _result_T_4 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
        node _result_T_5 = asFixedPoint(_result_T_4, 8) @[package.scala 74:56]
        _result_WIRE_2 <= _result_T_5 @[package.scala 74:56]
        result <= _result_WIRE_2 @[ALU.scala 75:14]
    node _T_9 = eq(op, UInt<3>("h4")) @[ALU.scala 78:11]
    when _T_9 : @[ALU.scala 78:25]
      wire _result_WIRE_3 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_6 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_7 = asFixedPoint(_result_T_6, 8) @[package.scala 74:56]
      _result_WIRE_3 <= _result_T_7 @[package.scala 74:56]
      result <= _result_WIRE_3 @[ALU.scala 79:12]
      wire _WIRE_1 : Fixed<<8>> @[package.scala 74:56]
      node _T_10 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_11 = asFixedPoint(_T_10, 8) @[package.scala 74:56]
      _WIRE_1 <= _T_11 @[package.scala 74:56]
      node _T_12 = geq(sourceLeft, _WIRE_1) @[ALU.scala 132:45]
      node _T_13 = geq(_WIRE_1, sourceLeft) @[ALU.scala 132:63]
      node _T_14 = and(_T_12, _T_13) @[ALU.scala 132:54]
      node _T_15 = eq(_T_14, UInt<1>("h0")) @[ALU.scala 131:40]
      wire _WIRE_2 : Fixed<<8>> @[package.scala 74:56]
      node _T_16 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_17 = asFixedPoint(_T_16, 8) @[package.scala 74:56]
      _WIRE_2 <= _T_17 @[package.scala 74:56]
      node _T_18 = geq(sourceRight, _WIRE_2) @[ALU.scala 132:45]
      node _T_19 = geq(_WIRE_2, sourceRight) @[ALU.scala 132:63]
      node _T_20 = and(_T_18, _T_19) @[ALU.scala 132:54]
      node _T_21 = eq(_T_20, UInt<1>("h0")) @[ALU.scala 131:40]
      node _T_22 = and(_T_15, _T_21) @[ALU.scala 80:29]
      when _T_22 : @[ALU.scala 80:53]
        wire _result_WIRE_4 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_8 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_9 = asFixedPoint(_result_T_8, 8) @[package.scala 82:56]
        _result_WIRE_4 <= _result_T_9 @[package.scala 82:56]
        result <= _result_WIRE_4 @[ALU.scala 81:14]
    node _T_23 = eq(op, UInt<3>("h5")) @[ALU.scala 84:11]
    when _T_23 : @[ALU.scala 84:24]
      wire _result_WIRE_5 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_10 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_11 = asFixedPoint(_result_T_10, 8) @[package.scala 74:56]
      _result_WIRE_5 <= _result_T_11 @[package.scala 74:56]
      result <= _result_WIRE_5 @[ALU.scala 85:12]
      wire _WIRE_3 : Fixed<<8>> @[package.scala 74:56]
      node _T_24 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_25 = asFixedPoint(_T_24, 8) @[package.scala 74:56]
      _WIRE_3 <= _T_25 @[package.scala 74:56]
      node _T_26 = geq(sourceLeft, _WIRE_3) @[ALU.scala 132:45]
      node _T_27 = geq(_WIRE_3, sourceLeft) @[ALU.scala 132:63]
      node _T_28 = and(_T_26, _T_27) @[ALU.scala 132:54]
      node _T_29 = eq(_T_28, UInt<1>("h0")) @[ALU.scala 131:40]
      wire _WIRE_4 : Fixed<<8>> @[package.scala 74:56]
      node _T_30 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _T_31 = asFixedPoint(_T_30, 8) @[package.scala 74:56]
      _WIRE_4 <= _T_31 @[package.scala 74:56]
      node _T_32 = geq(sourceRight, _WIRE_4) @[ALU.scala 132:45]
      node _T_33 = geq(_WIRE_4, sourceRight) @[ALU.scala 132:63]
      node _T_34 = and(_T_32, _T_33) @[ALU.scala 132:54]
      node _T_35 = eq(_T_34, UInt<1>("h0")) @[ALU.scala 131:40]
      node _T_36 = or(_T_29, _T_35) @[ALU.scala 86:29]
      when _T_36 : @[ALU.scala 86:53]
        wire _result_WIRE_6 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_12 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_13 = asFixedPoint(_result_T_12, 8) @[package.scala 82:56]
        _result_WIRE_6 <= _result_T_13 @[package.scala 82:56]
        result <= _result_WIRE_6 @[ALU.scala 87:14]
    node _T_37 = eq(op, UInt<3>("h6")) @[ALU.scala 92:11]
    when _T_37 : @[ALU.scala 92:31]
      wire _result_WIRE_7 : Fixed<16><<8>> @[package.scala 82:56]
      node _result_T_14 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
      node _result_T_15 = asFixedPoint(_result_T_14, 8) @[package.scala 82:56]
      _result_WIRE_7 <= _result_T_15 @[package.scala 82:56]
      node _result_T_16 = asSInt(sourceLeft) @[package.scala 163:37]
      node _result_T_17 = asSInt(_result_WIRE_7) @[package.scala 163:49]
      node _result_T_18 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T = mul(_result_T_16, _result_T_18) @[package.scala 117:18]
      node _result_mac_T_1 = shl(_result_T_17, 8) @[package.scala 117:29]
      node result_mac = add(_result_mac_T, _result_mac_T_1) @[package.scala 117:23]
      node result_mask0 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_1 = sub(_result_mask1_T, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_2 = tail(_result_mask1_T_1, 1) @[package.scala 120:44]
      node result_mask1 = asSInt(_result_mask1_T_2) @[package.scala 120:44]
      node result_mask2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T = and(result_mac, result_mask0) @[package.scala 125:16]
      node _result_adjustment_T_1 = asSInt(_result_adjustment_T) @[package.scala 125:16]
      node _result_adjustment_T_2 = neq(_result_adjustment_T_1, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_3 = and(result_mac, result_mask1) @[package.scala 125:44]
      node _result_adjustment_T_4 = asSInt(_result_adjustment_T_3) @[package.scala 125:44]
      node _result_adjustment_T_5 = neq(_result_adjustment_T_4, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_6 = and(result_mac, result_mask2) @[package.scala 125:71]
      node _result_adjustment_T_7 = asSInt(_result_adjustment_T_6) @[package.scala 125:71]
      node _result_adjustment_T_8 = neq(_result_adjustment_T_7, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_9 = or(_result_adjustment_T_5, _result_adjustment_T_8) @[package.scala 125:62]
      node _result_adjustment_T_10 = and(_result_adjustment_T_2, _result_adjustment_T_9) @[package.scala 125:34]
      node result_adjustment = mux(_result_adjustment_T_10, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T = shr(result_mac, 8) @[package.scala 130:26]
      node _result_adjusted_T_1 = add(_result_adjusted_T, result_adjustment) @[package.scala 130:42]
      node _result_adjusted_T_2 = tail(_result_adjusted_T_1, 1) @[package.scala 130:42]
      node result_adjusted = asSInt(_result_adjusted_T_2) @[package.scala 130:42]
      node _result_saturated_T = gt(result_adjusted, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_1 = lt(result_adjusted, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_2 = mux(_result_saturated_T_1, asSInt(UInt<16>("h8000")), result_adjusted) @[package.scala 98:26]
      node result_saturated = mux(_result_saturated_T, asSInt(UInt<16>("h7fff")), _result_saturated_T_2) @[package.scala 98:8]
      node _result_T_19 = asFixedPoint(result_saturated, 8) @[package.scala 133:27]
      result <= _result_T_19 @[ALU.scala 93:12]
    node _T_38 = eq(op, UInt<3>("h7")) @[ALU.scala 95:11]
    when _T_38 : @[ALU.scala 95:31]
      wire _result_WIRE_8 : Fixed<16><<8>> @[package.scala 82:56]
      node _result_T_20 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
      node _result_T_21 = asFixedPoint(_result_T_20, 8) @[package.scala 82:56]
      _result_WIRE_8 <= _result_T_21 @[package.scala 82:56]
      node _result_T_22 = asSInt(sourceLeft) @[package.scala 171:37]
      node _result_T_23 = asSInt(_result_WIRE_8) @[package.scala 171:56]
      node _result_T_24 = sub(asSInt(UInt<1>("h0")), _result_T_23) @[package.scala 171:45]
      node _result_T_25 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T_2 = mul(_result_T_22, _result_T_25) @[package.scala 117:18]
      node _result_mac_T_3 = shl(_result_T_24, 8) @[package.scala 117:29]
      node result_mac_1 = add(_result_mac_T_2, _result_mac_T_3) @[package.scala 117:23]
      node result_mask0_1 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_3 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_4 = sub(_result_mask1_T_3, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_5 = tail(_result_mask1_T_4, 1) @[package.scala 120:44]
      node result_mask1_1 = asSInt(_result_mask1_T_5) @[package.scala 120:44]
      node result_mask2_1 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_11 = and(result_mac_1, result_mask0_1) @[package.scala 125:16]
      node _result_adjustment_T_12 = asSInt(_result_adjustment_T_11) @[package.scala 125:16]
      node _result_adjustment_T_13 = neq(_result_adjustment_T_12, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_14 = and(result_mac_1, result_mask1_1) @[package.scala 125:44]
      node _result_adjustment_T_15 = asSInt(_result_adjustment_T_14) @[package.scala 125:44]
      node _result_adjustment_T_16 = neq(_result_adjustment_T_15, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_17 = and(result_mac_1, result_mask2_1) @[package.scala 125:71]
      node _result_adjustment_T_18 = asSInt(_result_adjustment_T_17) @[package.scala 125:71]
      node _result_adjustment_T_19 = neq(_result_adjustment_T_18, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_20 = or(_result_adjustment_T_16, _result_adjustment_T_19) @[package.scala 125:62]
      node _result_adjustment_T_21 = and(_result_adjustment_T_13, _result_adjustment_T_20) @[package.scala 125:34]
      node result_adjustment_1 = mux(_result_adjustment_T_21, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_3 = shr(result_mac_1, 8) @[package.scala 130:26]
      node _result_adjusted_T_4 = add(_result_adjusted_T_3, result_adjustment_1) @[package.scala 130:42]
      node _result_adjusted_T_5 = tail(_result_adjusted_T_4, 1) @[package.scala 130:42]
      node result_adjusted_1 = asSInt(_result_adjusted_T_5) @[package.scala 130:42]
      node _result_saturated_T_3 = gt(result_adjusted_1, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_4 = lt(result_adjusted_1, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_5 = mux(_result_saturated_T_4, asSInt(UInt<16>("h8000")), result_adjusted_1) @[package.scala 98:26]
      node result_saturated_1 = mux(_result_saturated_T_3, asSInt(UInt<16>("h7fff")), _result_saturated_T_5) @[package.scala 98:8]
      node _result_T_26 = asFixedPoint(result_saturated_1, 8) @[package.scala 133:27]
      result <= _result_T_26 @[ALU.scala 96:12]
    node _T_39 = eq(op, UInt<4>("h8")) @[ALU.scala 98:11]
    when _T_39 : @[ALU.scala 98:25]
      node _result_T_27 = asSInt(sourceLeft) @[package.scala 163:37]
      node _result_T_28 = asSInt(sourceRight) @[package.scala 163:49]
      node _result_T_29 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T_4 = mul(_result_T_27, _result_T_29) @[package.scala 117:18]
      node _result_mac_T_5 = shl(_result_T_28, 8) @[package.scala 117:29]
      node result_mac_2 = add(_result_mac_T_4, _result_mac_T_5) @[package.scala 117:23]
      node result_mask0_2 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_6 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_7 = sub(_result_mask1_T_6, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_8 = tail(_result_mask1_T_7, 1) @[package.scala 120:44]
      node result_mask1_2 = asSInt(_result_mask1_T_8) @[package.scala 120:44]
      node result_mask2_2 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_22 = and(result_mac_2, result_mask0_2) @[package.scala 125:16]
      node _result_adjustment_T_23 = asSInt(_result_adjustment_T_22) @[package.scala 125:16]
      node _result_adjustment_T_24 = neq(_result_adjustment_T_23, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_25 = and(result_mac_2, result_mask1_2) @[package.scala 125:44]
      node _result_adjustment_T_26 = asSInt(_result_adjustment_T_25) @[package.scala 125:44]
      node _result_adjustment_T_27 = neq(_result_adjustment_T_26, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_28 = and(result_mac_2, result_mask2_2) @[package.scala 125:71]
      node _result_adjustment_T_29 = asSInt(_result_adjustment_T_28) @[package.scala 125:71]
      node _result_adjustment_T_30 = neq(_result_adjustment_T_29, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_31 = or(_result_adjustment_T_27, _result_adjustment_T_30) @[package.scala 125:62]
      node _result_adjustment_T_32 = and(_result_adjustment_T_24, _result_adjustment_T_31) @[package.scala 125:34]
      node result_adjustment_2 = mux(_result_adjustment_T_32, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_6 = shr(result_mac_2, 8) @[package.scala 130:26]
      node _result_adjusted_T_7 = add(_result_adjusted_T_6, result_adjustment_2) @[package.scala 130:42]
      node _result_adjusted_T_8 = tail(_result_adjusted_T_7, 1) @[package.scala 130:42]
      node result_adjusted_2 = asSInt(_result_adjusted_T_8) @[package.scala 130:42]
      node _result_saturated_T_6 = gt(result_adjusted_2, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_7 = lt(result_adjusted_2, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_8 = mux(_result_saturated_T_7, asSInt(UInt<16>("h8000")), result_adjusted_2) @[package.scala 98:26]
      node result_saturated_2 = mux(_result_saturated_T_6, asSInt(UInt<16>("h7fff")), _result_saturated_T_8) @[package.scala 98:8]
      node _result_T_30 = asFixedPoint(result_saturated_2, 8) @[package.scala 133:27]
      result <= _result_T_30 @[ALU.scala 99:12]
    node _T_40 = eq(op, UInt<4>("h9")) @[ALU.scala 101:11]
    when _T_40 : @[ALU.scala 101:30]
      node _result_T_31 = asSInt(sourceLeft) @[package.scala 171:37]
      node _result_T_32 = asSInt(sourceRight) @[package.scala 171:56]
      node _result_T_33 = sub(asSInt(UInt<1>("h0")), _result_T_32) @[package.scala 171:45]
      node _result_T_34 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 141:31]
      node _result_mac_T_6 = mul(_result_T_31, _result_T_34) @[package.scala 117:18]
      node _result_mac_T_7 = shl(_result_T_33, 8) @[package.scala 117:29]
      node result_mac_3 = add(_result_mac_T_6, _result_mac_T_7) @[package.scala 117:23]
      node result_mask0_3 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_9 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_10 = sub(_result_mask1_T_9, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_11 = tail(_result_mask1_T_10, 1) @[package.scala 120:44]
      node result_mask1_3 = asSInt(_result_mask1_T_11) @[package.scala 120:44]
      node result_mask2_3 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_33 = and(result_mac_3, result_mask0_3) @[package.scala 125:16]
      node _result_adjustment_T_34 = asSInt(_result_adjustment_T_33) @[package.scala 125:16]
      node _result_adjustment_T_35 = neq(_result_adjustment_T_34, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_36 = and(result_mac_3, result_mask1_3) @[package.scala 125:44]
      node _result_adjustment_T_37 = asSInt(_result_adjustment_T_36) @[package.scala 125:44]
      node _result_adjustment_T_38 = neq(_result_adjustment_T_37, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_39 = and(result_mac_3, result_mask2_3) @[package.scala 125:71]
      node _result_adjustment_T_40 = asSInt(_result_adjustment_T_39) @[package.scala 125:71]
      node _result_adjustment_T_41 = neq(_result_adjustment_T_40, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_42 = or(_result_adjustment_T_38, _result_adjustment_T_41) @[package.scala 125:62]
      node _result_adjustment_T_43 = and(_result_adjustment_T_35, _result_adjustment_T_42) @[package.scala 125:34]
      node result_adjustment_3 = mux(_result_adjustment_T_43, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_9 = shr(result_mac_3, 8) @[package.scala 130:26]
      node _result_adjusted_T_10 = add(_result_adjusted_T_9, result_adjustment_3) @[package.scala 130:42]
      node _result_adjusted_T_11 = tail(_result_adjusted_T_10, 1) @[package.scala 130:42]
      node result_adjusted_3 = asSInt(_result_adjusted_T_11) @[package.scala 130:42]
      node _result_saturated_T_9 = gt(result_adjusted_3, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_10 = lt(result_adjusted_3, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_11 = mux(_result_saturated_T_10, asSInt(UInt<16>("h8000")), result_adjusted_3) @[package.scala 98:26]
      node result_saturated_3 = mux(_result_saturated_T_9, asSInt(UInt<16>("h7fff")), _result_saturated_T_11) @[package.scala 98:8]
      node _result_T_35 = asFixedPoint(result_saturated_3, 8) @[package.scala 133:27]
      result <= _result_T_35 @[ALU.scala 102:12]
    node _T_41 = eq(op, UInt<4>("ha")) @[ALU.scala 104:11]
    when _T_41 : @[ALU.scala 104:30]
      node _result_T_36 = asSInt(sourceLeft) @[package.scala 155:38]
      node _result_T_37 = asSInt(sourceRight) @[package.scala 155:50]
      node _result_mac_T_8 = mul(_result_T_36, _result_T_37) @[package.scala 117:18]
      node _result_mac_T_9 = shl(asSInt(UInt<1>("h0")), 8) @[package.scala 117:29]
      node result_mac_4 = add(_result_mac_T_8, _result_mac_T_9) @[package.scala 117:23]
      node result_mask0_4 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 119:21]
      node _result_mask1_T_12 = shl(asSInt(UInt<2>("h1")), 7) @[package.scala 120:22]
      node _result_mask1_T_13 = sub(_result_mask1_T_12, asSInt(UInt<2>("h1"))) @[package.scala 120:44]
      node _result_mask1_T_14 = tail(_result_mask1_T_13, 1) @[package.scala 120:44]
      node result_mask1_4 = asSInt(_result_mask1_T_14) @[package.scala 120:44]
      node result_mask2_4 = shl(asSInt(UInt<2>("h1")), 8) @[package.scala 121:21]
      node _result_adjustment_T_44 = and(result_mac_4, result_mask0_4) @[package.scala 125:16]
      node _result_adjustment_T_45 = asSInt(_result_adjustment_T_44) @[package.scala 125:16]
      node _result_adjustment_T_46 = neq(_result_adjustment_T_45, asSInt(UInt<1>("h0"))) @[package.scala 125:25]
      node _result_adjustment_T_47 = and(result_mac_4, result_mask1_4) @[package.scala 125:44]
      node _result_adjustment_T_48 = asSInt(_result_adjustment_T_47) @[package.scala 125:44]
      node _result_adjustment_T_49 = neq(_result_adjustment_T_48, asSInt(UInt<1>("h0"))) @[package.scala 125:53]
      node _result_adjustment_T_50 = and(result_mac_4, result_mask2_4) @[package.scala 125:71]
      node _result_adjustment_T_51 = asSInt(_result_adjustment_T_50) @[package.scala 125:71]
      node _result_adjustment_T_52 = neq(_result_adjustment_T_51, asSInt(UInt<1>("h0"))) @[package.scala 125:80]
      node _result_adjustment_T_53 = or(_result_adjustment_T_49, _result_adjustment_T_52) @[package.scala 125:62]
      node _result_adjustment_T_54 = and(_result_adjustment_T_46, _result_adjustment_T_53) @[package.scala 125:34]
      node result_adjustment_4 = mux(_result_adjustment_T_54, asSInt(UInt<2>("h1")), asSInt(UInt<1>("h0"))) @[package.scala 124:10]
      node _result_adjusted_T_12 = shr(result_mac_4, 8) @[package.scala 130:26]
      node _result_adjusted_T_13 = add(_result_adjusted_T_12, result_adjustment_4) @[package.scala 130:42]
      node _result_adjusted_T_14 = tail(_result_adjusted_T_13, 1) @[package.scala 130:42]
      node result_adjusted_4 = asSInt(_result_adjusted_T_14) @[package.scala 130:42]
      node _result_saturated_T_12 = gt(result_adjusted_4, asSInt(UInt<16>("h7fff"))) @[package.scala 98:11]
      node _result_saturated_T_13 = lt(result_adjusted_4, asSInt(UInt<16>("h8000"))) @[package.scala 98:29]
      node _result_saturated_T_14 = mux(_result_saturated_T_13, asSInt(UInt<16>("h8000")), result_adjusted_4) @[package.scala 98:26]
      node result_saturated_4 = mux(_result_saturated_T_12, asSInt(UInt<16>("h7fff")), _result_saturated_T_14) @[package.scala 98:8]
      node _result_T_38 = asFixedPoint(result_saturated_4, 8) @[package.scala 133:27]
      result <= _result_T_38 @[ALU.scala 105:12]
    node _T_42 = eq(op, UInt<4>("hb")) @[ALU.scala 107:11]
    when _T_42 : @[ALU.scala 107:25]
      node _result_T_39 = lt(sourceLeft, asFixedPoint(UInt<1>("h0"), 0)) @[ALU.scala 108:26]
      node _result_T_40 = sub(asFixedPoint(UInt<1>("h0"), 0), sourceLeft) @[ALU.scala 108:26]
      node _result_T_41 = tail(_result_T_40, 1) @[ALU.scala 108:26]
      node _result_T_42 = asFixedPoint(_result_T_41, 8) @[ALU.scala 108:26]
      node _result_T_43 = mux(_result_T_39, _result_T_42, sourceLeft) @[ALU.scala 108:26]
      result <= _result_T_43 @[ALU.scala 108:12]
    node _T_43 = eq(op, UInt<4>("hc")) @[ALU.scala 112:11]
    when _T_43 : @[ALU.scala 112:33]
      wire _result_WIRE_9 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_44 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_45 = asFixedPoint(_result_T_44, 8) @[package.scala 74:56]
      _result_WIRE_9 <= _result_T_45 @[package.scala 74:56]
      result <= _result_WIRE_9 @[ALU.scala 113:12]
      node _T_44 = gt(sourceLeft, sourceRight) @[ALU.scala 114:21]
      when _T_44 : @[ALU.scala 114:36]
        wire _result_WIRE_10 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_46 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_47 = asFixedPoint(_result_T_46, 8) @[package.scala 82:56]
        _result_WIRE_10 <= _result_T_47 @[package.scala 82:56]
        result <= _result_WIRE_10 @[ALU.scala 115:14]
    node _T_45 = eq(op, UInt<4>("hd")) @[ALU.scala 118:11]
    when _T_45 : @[ALU.scala 118:38]
      wire _result_WIRE_11 : Fixed<16><<8>> @[package.scala 74:56]
      node _result_T_48 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
      node _result_T_49 = asFixedPoint(_result_T_48, 8) @[package.scala 74:56]
      _result_WIRE_11 <= _result_T_49 @[package.scala 74:56]
      result <= _result_WIRE_11 @[ALU.scala 119:12]
      node _T_46 = geq(sourceLeft, sourceRight) @[ALU.scala 120:21]
      when _T_46 : @[ALU.scala 120:37]
        wire _result_WIRE_12 : Fixed<16><<8>> @[package.scala 82:56]
        node _result_T_50 = asUInt(asFixedPoint(UInt<10>("h100"), 8)) @[package.scala 82:56]
        node _result_T_51 = asFixedPoint(_result_T_50, 8) @[package.scala 82:56]
        _result_WIRE_12 <= _result_T_51 @[package.scala 82:56]
        result <= _result_WIRE_12 @[ALU.scala 121:14]
    node _T_47 = eq(op, UInt<4>("he")) @[ALU.scala 124:11]
    when _T_47 : @[ALU.scala 124:25]
      node _result_T_52 = lt(sourceLeft, sourceRight) @[ALU.scala 125:29]
      node _result_T_53 = mux(_result_T_52, sourceLeft, sourceRight) @[ALU.scala 125:29]
      result <= _result_T_53 @[ALU.scala 125:12]
    node _T_48 = eq(op, UInt<4>("hf")) @[ALU.scala 127:11]
    when _T_48 : @[ALU.scala 127:25]
      node _result_T_54 = lt(sourceLeft, sourceRight) @[ALU.scala 128:29]
      node _result_T_55 = mux(_result_T_54, sourceRight, sourceLeft) @[ALU.scala 128:29]
      result <= _result_T_55 @[ALU.scala 128:12]

  module ALUArray :
    input clock : Clock
    input reset : Reset
    output io : { flip input : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, output : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip instruction : { flip ready : UInt<1>, valid : UInt<1>, bits : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}}}

    inst output of Queue_17 @[ALUArray.scala 34:22]
    output.clock <= clock
    output.reset <= reset
    io.output.bits <= output.io.deq.bits @[ALUArray.scala 35:13]
    io.output.valid <= output.io.deq.valid @[ALUArray.scala 35:13]
    output.io.deq.ready <= io.output.ready @[ALUArray.scala 35:13]
    node _inputNotNeeded_T = eq(io.instruction.bits.op, UInt<1>("h0")) @[ALUArray.scala 38:25]
    node _inputNotNeeded_T_1 = eq(io.instruction.bits.op, UInt<1>("h1")) @[ALUArray.scala 38:62]
    node _inputNotNeeded_T_2 = or(_inputNotNeeded_T, _inputNotNeeded_T_1) @[ALUArray.scala 38:39]
    node _inputNotNeeded_T_3 = eq(io.instruction.bits.op, UInt<2>("h2")) @[Op.scala 40:21]
    node _inputNotNeeded_T_4 = eq(io.instruction.bits.op, UInt<2>("h3")) @[Op.scala 40:21]
    node _inputNotNeeded_T_5 = eq(io.instruction.bits.op, UInt<3>("h6")) @[Op.scala 40:21]
    node _inputNotNeeded_T_6 = eq(io.instruction.bits.op, UInt<3>("h7")) @[Op.scala 40:21]
    node _inputNotNeeded_T_7 = eq(io.instruction.bits.op, UInt<4>("hb")) @[Op.scala 40:21]
    node _inputNotNeeded_T_8 = and(_inputNotNeeded_T_3, _inputNotNeeded_T_4) @[Op.scala 40:39]
    node _inputNotNeeded_T_9 = and(_inputNotNeeded_T_8, _inputNotNeeded_T_5) @[Op.scala 40:39]
    node _inputNotNeeded_T_10 = and(_inputNotNeeded_T_9, _inputNotNeeded_T_6) @[Op.scala 40:39]
    node _inputNotNeeded_T_11 = and(_inputNotNeeded_T_10, _inputNotNeeded_T_7) @[Op.scala 40:39]
    node _inputNotNeeded_T_12 = neq(io.instruction.bits.sourceLeft, UInt<1>("h0")) @[ALUArray.scala 41:40]
    node _inputNotNeeded_T_13 = and(_inputNotNeeded_T_11, _inputNotNeeded_T_12) @[ALUArray.scala 41:9]
    node _inputNotNeeded_T_14 = or(_inputNotNeeded_T_2, _inputNotNeeded_T_13) @[ALUArray.scala 38:76]
    node _inputNotNeeded_T_15 = neq(io.instruction.bits.sourceLeft, UInt<1>("h0")) @[ALUArray.scala 42:36]
    node _inputNotNeeded_T_16 = neq(io.instruction.bits.sourceRight, UInt<1>("h0")) @[ALUArray.scala 42:76]
    node _inputNotNeeded_T_17 = and(_inputNotNeeded_T_15, _inputNotNeeded_T_16) @[ALUArray.scala 42:44]
    node inputNotNeeded = or(_inputNotNeeded_T_14, _inputNotNeeded_T_17) @[ALUArray.scala 41:49]
    node inputNeeded = eq(inputNotNeeded, UInt<1>("h0")) @[ALUArray.scala 43:21]
    node _io_input_ready_T = and(output.io.enq.ready, io.instruction.valid) @[ALUArray.scala 45:38]
    node _io_input_ready_T_1 = and(_io_input_ready_T, inputNeeded) @[ALUArray.scala 45:59]
    io.input.ready <= _io_input_ready_T_1 @[ALUArray.scala 45:15]
    node _io_instruction_ready_T = eq(inputNeeded, UInt<1>("h0")) @[ALUArray.scala 46:41]
    node _io_instruction_ready_T_1 = or(io.input.valid, _io_instruction_ready_T) @[ALUArray.scala 46:38]
    node _io_instruction_ready_T_2 = and(_io_instruction_ready_T_1, output.io.enq.ready) @[ALUArray.scala 46:55]
    io.instruction.ready <= _io_instruction_ready_T_2 @[ALUArray.scala 46:21]
    node _output_io_enq_valid_T = eq(inputNeeded, UInt<1>("h0")) @[ALUArray.scala 48:21]
    node _output_io_enq_valid_T_1 = or(io.input.valid, _output_io_enq_valid_T) @[ALUArray.scala 48:18]
    node _output_io_enq_valid_T_2 = and(_output_io_enq_valid_T_1, io.instruction.valid) @[ALUArray.scala 48:35]
    wire _output_io_enq_valid_sr_WIRE : UInt<1>[2] @[package.scala 75:57]
    _output_io_enq_valid_sr_WIRE[0] <= UInt<1>("h0") @[package.scala 75:57]
    _output_io_enq_valid_sr_WIRE[1] <= UInt<1>("h0") @[package.scala 75:57]
    reg output_io_enq_valid_sr : UInt<1>[2], clock with :
      reset => (reset, _output_io_enq_valid_sr_WIRE) @[ShiftRegister.scala 10:22]
    output_io_enq_valid_sr[1] <= output_io_enq_valid_sr[0] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[0] <= _output_io_enq_valid_T_2 @[ShiftRegister.scala 25:12]
    output.io.enq.valid <= output_io_enq_valid_sr[1] @[ALUArray.scala 47:23]
    inst m of ALU @[ALUArray.scala 53:19]
    m.clock <= clock
    m.reset <= reset
    node _m_io_op_T = and(io.instruction.ready, io.instruction.valid) @[ALUArray.scala 63:25]
    node _m_io_op_T_1 = mux(_m_io_op_T, io.instruction.bits.op, UInt<1>("h0")) @[ALUArray.scala 62:19]
    m.io.op <= _m_io_op_T_1 @[ALUArray.scala 62:13]
    m.io.sourceLeft <= io.instruction.bits.sourceLeft @[ALUArray.scala 67:21]
    m.io.sourceRight <= io.instruction.bits.sourceRight @[ALUArray.scala 68:22]
    m.io.dest <= io.instruction.bits.dest @[ALUArray.scala 69:15]
    m.io.input <= io.input.bits[0] @[ALUArray.scala 70:16]
    output.io.enq.bits[0] <= m.io.output @[ALUArray.scala 71:27]
    inst m_1 of ALU_1 @[ALUArray.scala 53:19]
    m_1.clock <= clock
    m_1.reset <= reset
    node _m_io_op_T_2 = and(io.instruction.ready, io.instruction.valid) @[ALUArray.scala 63:25]
    node _m_io_op_T_3 = mux(_m_io_op_T_2, io.instruction.bits.op, UInt<1>("h0")) @[ALUArray.scala 62:19]
    m_1.io.op <= _m_io_op_T_3 @[ALUArray.scala 62:13]
    m_1.io.sourceLeft <= io.instruction.bits.sourceLeft @[ALUArray.scala 67:21]
    m_1.io.sourceRight <= io.instruction.bits.sourceRight @[ALUArray.scala 68:22]
    m_1.io.dest <= io.instruction.bits.dest @[ALUArray.scala 69:15]
    m_1.io.input <= io.input.bits[1] @[ALUArray.scala 70:16]
    output.io.enq.bits[1] <= m_1.io.output @[ALUArray.scala 71:27]
    inst m_2 of ALU_2 @[ALUArray.scala 53:19]
    m_2.clock <= clock
    m_2.reset <= reset
    node _m_io_op_T_4 = and(io.instruction.ready, io.instruction.valid) @[ALUArray.scala 63:25]
    node _m_io_op_T_5 = mux(_m_io_op_T_4, io.instruction.bits.op, UInt<1>("h0")) @[ALUArray.scala 62:19]
    m_2.io.op <= _m_io_op_T_5 @[ALUArray.scala 62:13]
    m_2.io.sourceLeft <= io.instruction.bits.sourceLeft @[ALUArray.scala 67:21]
    m_2.io.sourceRight <= io.instruction.bits.sourceRight @[ALUArray.scala 68:22]
    m_2.io.dest <= io.instruction.bits.dest @[ALUArray.scala 69:15]
    m_2.io.input <= io.input.bits[2] @[ALUArray.scala 70:16]
    output.io.enq.bits[2] <= m_2.io.output @[ALUArray.scala 71:27]
    inst m_3 of ALU_3 @[ALUArray.scala 53:19]
    m_3.clock <= clock
    m_3.reset <= reset
    node _m_io_op_T_6 = and(io.instruction.ready, io.instruction.valid) @[ALUArray.scala 63:25]
    node _m_io_op_T_7 = mux(_m_io_op_T_6, io.instruction.bits.op, UInt<1>("h0")) @[ALUArray.scala 62:19]
    m_3.io.op <= _m_io_op_T_7 @[ALUArray.scala 62:13]
    m_3.io.sourceLeft <= io.instruction.bits.sourceLeft @[ALUArray.scala 67:21]
    m_3.io.sourceRight <= io.instruction.bits.sourceRight @[ALUArray.scala 68:22]
    m_3.io.dest <= io.instruction.bits.dest @[ALUArray.scala 69:15]
    m_3.io.input <= io.input.bits[3] @[ALUArray.scala 70:16]
    output.io.enq.bits[3] <= m_3.io.output @[ALUArray.scala 71:27]
    inst m_4 of ALU_4 @[ALUArray.scala 53:19]
    m_4.clock <= clock
    m_4.reset <= reset
    node _m_io_op_T_8 = and(io.instruction.ready, io.instruction.valid) @[ALUArray.scala 63:25]
    node _m_io_op_T_9 = mux(_m_io_op_T_8, io.instruction.bits.op, UInt<1>("h0")) @[ALUArray.scala 62:19]
    m_4.io.op <= _m_io_op_T_9 @[ALUArray.scala 62:13]
    m_4.io.sourceLeft <= io.instruction.bits.sourceLeft @[ALUArray.scala 67:21]
    m_4.io.sourceRight <= io.instruction.bits.sourceRight @[ALUArray.scala 68:22]
    m_4.io.dest <= io.instruction.bits.dest @[ALUArray.scala 69:15]
    m_4.io.input <= io.input.bits[4] @[ALUArray.scala 70:16]
    output.io.enq.bits[4] <= m_4.io.output @[ALUArray.scala 71:27]
    inst m_5 of ALU_5 @[ALUArray.scala 53:19]
    m_5.clock <= clock
    m_5.reset <= reset
    node _m_io_op_T_10 = and(io.instruction.ready, io.instruction.valid) @[ALUArray.scala 63:25]
    node _m_io_op_T_11 = mux(_m_io_op_T_10, io.instruction.bits.op, UInt<1>("h0")) @[ALUArray.scala 62:19]
    m_5.io.op <= _m_io_op_T_11 @[ALUArray.scala 62:13]
    m_5.io.sourceLeft <= io.instruction.bits.sourceLeft @[ALUArray.scala 67:21]
    m_5.io.sourceRight <= io.instruction.bits.sourceRight @[ALUArray.scala 68:22]
    m_5.io.dest <= io.instruction.bits.dest @[ALUArray.scala 69:15]
    m_5.io.input <= io.input.bits[5] @[ALUArray.scala 70:16]
    output.io.enq.bits[5] <= m_5.io.output @[ALUArray.scala 71:27]
    inst m_6 of ALU_6 @[ALUArray.scala 53:19]
    m_6.clock <= clock
    m_6.reset <= reset
    node _m_io_op_T_12 = and(io.instruction.ready, io.instruction.valid) @[ALUArray.scala 63:25]
    node _m_io_op_T_13 = mux(_m_io_op_T_12, io.instruction.bits.op, UInt<1>("h0")) @[ALUArray.scala 62:19]
    m_6.io.op <= _m_io_op_T_13 @[ALUArray.scala 62:13]
    m_6.io.sourceLeft <= io.instruction.bits.sourceLeft @[ALUArray.scala 67:21]
    m_6.io.sourceRight <= io.instruction.bits.sourceRight @[ALUArray.scala 68:22]
    m_6.io.dest <= io.instruction.bits.dest @[ALUArray.scala 69:15]
    m_6.io.input <= io.input.bits[6] @[ALUArray.scala 70:16]
    output.io.enq.bits[6] <= m_6.io.output @[ALUArray.scala 71:27]
    inst m_7 of ALU_7 @[ALUArray.scala 53:19]
    m_7.clock <= clock
    m_7.reset <= reset
    node _m_io_op_T_14 = and(io.instruction.ready, io.instruction.valid) @[ALUArray.scala 63:25]
    node _m_io_op_T_15 = mux(_m_io_op_T_14, io.instruction.bits.op, UInt<1>("h0")) @[ALUArray.scala 62:19]
    m_7.io.op <= _m_io_op_T_15 @[ALUArray.scala 62:13]
    m_7.io.sourceLeft <= io.instruction.bits.sourceLeft @[ALUArray.scala 67:21]
    m_7.io.sourceRight <= io.instruction.bits.sourceRight @[ALUArray.scala 68:22]
    m_7.io.dest <= io.instruction.bits.dest @[ALUArray.scala 69:15]
    m_7.io.input <= io.input.bits[7] @[ALUArray.scala 70:16]
    output.io.enq.bits[7] <= m_7.io.output @[ALUArray.scala 71:27]

  module Sink :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}

    io.in.ready <= UInt<1>("h1") @[Sink.scala 14:15]

  module Demux_1 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip sel : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2]}

    wire _io_out_0_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 75:57]
    node _io_out_0_bits_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[0] <= _io_out_0_bits_T @[package.scala 75:57]
    node _io_out_0_bits_T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[1] <= _io_out_0_bits_T_1 @[package.scala 75:57]
    node _io_out_0_bits_T_2 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[2] <= _io_out_0_bits_T_2 @[package.scala 75:57]
    node _io_out_0_bits_T_3 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[3] <= _io_out_0_bits_T_3 @[package.scala 75:57]
    node _io_out_0_bits_T_4 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[4] <= _io_out_0_bits_T_4 @[package.scala 75:57]
    node _io_out_0_bits_T_5 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[5] <= _io_out_0_bits_T_5 @[package.scala 75:57]
    node _io_out_0_bits_T_6 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[6] <= _io_out_0_bits_T_6 @[package.scala 75:57]
    node _io_out_0_bits_T_7 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[7] <= _io_out_0_bits_T_7 @[package.scala 75:57]
    io.out[0].bits <= _io_out_0_bits_WIRE @[Demux.scala 27:14]
    io.out[0].valid <= UInt<1>("h0") @[Demux.scala 28:15]
    wire _io_out_1_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 75:57]
    node _io_out_1_bits_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[0] <= _io_out_1_bits_T @[package.scala 75:57]
    node _io_out_1_bits_T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[1] <= _io_out_1_bits_T_1 @[package.scala 75:57]
    node _io_out_1_bits_T_2 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[2] <= _io_out_1_bits_T_2 @[package.scala 75:57]
    node _io_out_1_bits_T_3 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[3] <= _io_out_1_bits_T_3 @[package.scala 75:57]
    node _io_out_1_bits_T_4 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[4] <= _io_out_1_bits_T_4 @[package.scala 75:57]
    node _io_out_1_bits_T_5 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[5] <= _io_out_1_bits_T_5 @[package.scala 75:57]
    node _io_out_1_bits_T_6 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[6] <= _io_out_1_bits_T_6 @[package.scala 75:57]
    node _io_out_1_bits_T_7 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[7] <= _io_out_1_bits_T_7 @[package.scala 75:57]
    io.out[1].bits <= _io_out_1_bits_WIRE @[Demux.scala 27:14]
    io.out[1].valid <= UInt<1>("h0") @[Demux.scala 28:15]
    io.out[io.sel.bits].bits <= io.in.bits @[Demux.scala 32:12]
    node _io_out_valid_T = and(io.sel.valid, io.in.valid) @[Demux.scala 33:26]
    io.out[io.sel.bits].valid <= _io_out_valid_T @[Demux.scala 33:13]
    node _io_sel_ready_T = and(io.in.valid, io.out[io.sel.bits].ready) @[Demux.scala 34:25]
    io.sel.ready <= _io_sel_ready_T @[Demux.scala 34:13]
    node _io_in_ready_T = and(io.sel.valid, io.out[io.sel.bits].ready) @[Demux.scala 35:25]
    io.in.ready <= _io_in_ready_T @[Demux.scala 35:12]

  module Queue_18 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<1>}

    cmem ram : UInt<1> [1] @[Decoupled.scala 259:95]
    wire enq_ptr_value : UInt
    enq_ptr_value <= UInt<1>("h0")
    wire deq_ptr_value : UInt
    deq_ptr_value <= UInt<1>("h0")
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[UInt<1>("h0")], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
    when do_deq : @[Decoupled.scala 276:16]
      skip
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[UInt<1>("h0")], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    when io.deq.ready : @[Decoupled.scala 309:24]
      io.enq.ready <= UInt<1>("h1") @[Decoupled.scala 309:39]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<1>("h1"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Mux_1 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2], flip sel : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}

    wire in : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2] @[Mux.scala 47:19]
    in[0] <= io.in[0] @[Mux.scala 47:19]
    in[1] <= io.in[1] @[Mux.scala 47:19]
    in[UInt<1>("h0")].ready <= UInt<1>("h0") @[Mux.scala 52:19]
    in[UInt<1>("h1")].ready <= UInt<1>("h0") @[Mux.scala 52:19]
    io.out.bits <= in[io.sel.bits].bits @[Mux.scala 57:15]
    node _io_out_valid_T = and(io.sel.valid, in[io.sel.bits].valid) @[Mux.scala 58:29]
    io.out.valid <= _io_out_valid_T @[Mux.scala 58:16]
    node _io_sel_ready_T = and(in[io.sel.bits].valid, io.out.ready) @[Mux.scala 59:26]
    io.sel.ready <= _io_sel_ready_T @[Mux.scala 59:13]
    node _in_ready_T = and(io.sel.valid, io.out.ready) @[Mux.scala 60:26]
    in[io.sel.bits].ready <= _in_ready_T @[Mux.scala 60:13]

  module Queue_19 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<1>}

    cmem ram : UInt<1> [1] @[Decoupled.scala 259:95]
    wire enq_ptr_value : UInt
    enq_ptr_value <= UInt<1>("h0")
    wire deq_ptr_value : UInt
    deq_ptr_value <= UInt<1>("h0")
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[UInt<1>("h0")], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
    when do_deq : @[Decoupled.scala 276:16]
      skip
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[UInt<1>("h0")], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    when io.deq.ready : @[Decoupled.scala 309:24]
      io.enq.ready <= UInt<1>("h1") @[Decoupled.scala 309:39]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<1>("h1"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Demux_2 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip sel : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2]}

    wire _io_out_0_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 75:57]
    node _io_out_0_bits_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[0] <= _io_out_0_bits_T @[package.scala 75:57]
    node _io_out_0_bits_T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[1] <= _io_out_0_bits_T_1 @[package.scala 75:57]
    node _io_out_0_bits_T_2 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[2] <= _io_out_0_bits_T_2 @[package.scala 75:57]
    node _io_out_0_bits_T_3 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[3] <= _io_out_0_bits_T_3 @[package.scala 75:57]
    node _io_out_0_bits_T_4 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[4] <= _io_out_0_bits_T_4 @[package.scala 75:57]
    node _io_out_0_bits_T_5 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[5] <= _io_out_0_bits_T_5 @[package.scala 75:57]
    node _io_out_0_bits_T_6 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[6] <= _io_out_0_bits_T_6 @[package.scala 75:57]
    node _io_out_0_bits_T_7 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[7] <= _io_out_0_bits_T_7 @[package.scala 75:57]
    io.out[0].bits <= _io_out_0_bits_WIRE @[Demux.scala 27:14]
    io.out[0].valid <= UInt<1>("h0") @[Demux.scala 28:15]
    wire _io_out_1_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 75:57]
    node _io_out_1_bits_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[0] <= _io_out_1_bits_T @[package.scala 75:57]
    node _io_out_1_bits_T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[1] <= _io_out_1_bits_T_1 @[package.scala 75:57]
    node _io_out_1_bits_T_2 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[2] <= _io_out_1_bits_T_2 @[package.scala 75:57]
    node _io_out_1_bits_T_3 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[3] <= _io_out_1_bits_T_3 @[package.scala 75:57]
    node _io_out_1_bits_T_4 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[4] <= _io_out_1_bits_T_4 @[package.scala 75:57]
    node _io_out_1_bits_T_5 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[5] <= _io_out_1_bits_T_5 @[package.scala 75:57]
    node _io_out_1_bits_T_6 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[6] <= _io_out_1_bits_T_6 @[package.scala 75:57]
    node _io_out_1_bits_T_7 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[7] <= _io_out_1_bits_T_7 @[package.scala 75:57]
    io.out[1].bits <= _io_out_1_bits_WIRE @[Demux.scala 27:14]
    io.out[1].valid <= UInt<1>("h0") @[Demux.scala 28:15]
    io.out[io.sel.bits].bits <= io.in.bits @[Demux.scala 32:12]
    node _io_out_valid_T = and(io.sel.valid, io.in.valid) @[Demux.scala 33:26]
    io.out[io.sel.bits].valid <= _io_out_valid_T @[Demux.scala 33:13]
    node _io_sel_ready_T = and(io.in.valid, io.out[io.sel.bits].ready) @[Demux.scala 34:25]
    io.sel.ready <= _io_sel_ready_T @[Demux.scala 34:13]
    node _io_in_ready_T = and(io.sel.valid, io.out[io.sel.bits].ready) @[Demux.scala 35:25]
    io.in.ready <= _io_in_ready_T @[Demux.scala 35:12]

  module Queue_20 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<1>}

    cmem ram : UInt<1> [1] @[Decoupled.scala 259:95]
    wire enq_ptr_value : UInt
    enq_ptr_value <= UInt<1>("h0")
    wire deq_ptr_value : UInt
    deq_ptr_value <= UInt<1>("h0")
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[UInt<1>("h0")], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
    when do_deq : @[Decoupled.scala 276:16]
      skip
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[UInt<1>("h0")], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    when io.deq.ready : @[Decoupled.scala 309:24]
      io.enq.ready <= UInt<1>("h1") @[Decoupled.scala 309:39]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<1>("h1"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module MultiEnqueue_8 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>}[2]}

    reg enq_0 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node allEnqueued = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_1 = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]

  module MultiEnqueue_9 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>}[2]}

    reg enq_0 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node allEnqueued = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_1 = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]

  module MultiEnqueue_10 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>}[3]}

    reg enq_0 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_2 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_2 = or(io.out[2].ready, enq_2) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_3 = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node allEnqueued = and(_allEnqueued_T_3, _allEnqueued_T_2) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_1 = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
    node _io_out_2_valid_T = eq(enq_2, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_2_valid_T_1 = and(io.in.valid, _io_out_2_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[2].valid <= _io_out_2_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_2 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_2 = eq(enq_2, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_2 : @[MultiEnqueue.scala 31:21]
        node _enq_2_T = and(io.out[2].valid, io.out[2].ready) @[MultiEnqueue.scala 32:35]
        enq_2 <= _enq_2_T @[MultiEnqueue.scala 32:16]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]

  module MultiEnqueue_11 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>}[3]}

    reg enq_0 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_2 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_2 = or(io.out[2].ready, enq_2) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_3 = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node allEnqueued = and(_allEnqueued_T_3, _allEnqueued_T_2) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_1 = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
    node _io_out_2_valid_T = eq(enq_2, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_2_valid_T_1 = and(io.in.valid, _io_out_2_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[2].valid <= _io_out_2_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_2 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_2 = eq(enq_2, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_2 : @[MultiEnqueue.scala 31:21]
        node _enq_2_T = and(io.out[2].valid, io.out[2].ready) @[MultiEnqueue.scala 32:35]
        enq_2 <= _enq_2_T @[MultiEnqueue.scala 32:16]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]

  module MultiEnqueue_12 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>}[4]}

    reg enq_0 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_2 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_3 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_2 = or(io.out[2].ready, enq_2) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_3 = or(io.out[3].ready, enq_3) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_4 = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _allEnqueued_T_5 = and(_allEnqueued_T_4, _allEnqueued_T_2) @[MultiEnqueue.scala 24:15]
    node allEnqueued = and(_allEnqueued_T_5, _allEnqueued_T_3) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_1 = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
    node _io_out_2_valid_T = eq(enq_2, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_2_valid_T_1 = and(io.in.valid, _io_out_2_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[2].valid <= _io_out_2_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_2 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_2 = eq(enq_2, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_2 : @[MultiEnqueue.scala 31:21]
        node _enq_2_T = and(io.out[2].valid, io.out[2].ready) @[MultiEnqueue.scala 32:35]
        enq_2 <= _enq_2_T @[MultiEnqueue.scala 32:16]
    node _io_out_3_valid_T = eq(enq_3, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_3_valid_T_1 = and(io.in.valid, _io_out_3_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[3].valid <= _io_out_3_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_3 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_3 = eq(enq_3, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_3 : @[MultiEnqueue.scala 31:21]
        node _enq_3_T = and(io.out[3].valid, io.out[3].ready) @[MultiEnqueue.scala 32:35]
        enq_3 <= _enq_3_T @[MultiEnqueue.scala 32:16]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]

  module MultiEnqueue_13 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>}[4]}

    reg enq_0 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_2 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_3 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_2 = or(io.out[2].ready, enq_2) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_3 = or(io.out[3].ready, enq_3) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_4 = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _allEnqueued_T_5 = and(_allEnqueued_T_4, _allEnqueued_T_2) @[MultiEnqueue.scala 24:15]
    node allEnqueued = and(_allEnqueued_T_5, _allEnqueued_T_3) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_1 = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
    node _io_out_2_valid_T = eq(enq_2, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_2_valid_T_1 = and(io.in.valid, _io_out_2_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[2].valid <= _io_out_2_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_2 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_2 = eq(enq_2, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_2 : @[MultiEnqueue.scala 31:21]
        node _enq_2_T = and(io.out[2].valid, io.out[2].ready) @[MultiEnqueue.scala 32:35]
        enq_2 <= _enq_2_T @[MultiEnqueue.scala 32:16]
    node _io_out_3_valid_T = eq(enq_3, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_3_valid_T_1 = and(io.in.valid, _io_out_3_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[3].valid <= _io_out_3_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_3 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_3 = eq(enq_3, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_3 : @[MultiEnqueue.scala 31:21]
        node _enq_3_T = and(io.out[3].valid, io.out[3].ready) @[MultiEnqueue.scala 32:35]
        enq_3 <= _enq_3_T @[MultiEnqueue.scala 32:16]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]

  module MultiEnqueue_14 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>}[2]}

    reg enq_0 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node allEnqueued = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_1 = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]

  module AccumulatorWithALUArray :
    input clock : Clock
    input reset : Reset
    output io : { flip input : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, output : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip control : { flip ready : UInt<1>, valid : UInt<1>, bits : { instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, readAddress : UInt<11>, writeAddress : UInt<11>, accumulate : UInt<1>, write : UInt<1>, read : UInt<1>}}, wrote : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, computed : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, nooped : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, flip tracepoint : UInt<1>, flip programCounter : UInt<32>}

    inst acc of Accumulator @[AccumulatorWithALUArray.scala 44:19]
    acc.clock <= clock
    acc.reset <= reset
    inst alu of ALUArray @[AccumulatorWithALUArray.scala 45:19]
    alu.clock <= clock
    alu.reset <= reset
    inst aluOutputSink of Sink @[AccumulatorWithALUArray.scala 46:29]
    aluOutputSink.clock <= clock
    aluOutputSink.reset <= reset
    wire aluOutputForAccInput : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]} @[AccumulatorWithALUArray.scala 50:34]
    io.wrote.bits <= UInt<1>("h1") @[AccumulatorWithALUArray.scala 56:17]
    node _io_wrote_valid_T = eq(io.control.bits.instruction.op, UInt<1>("h0")) @[AccumulatorWithALUArray.scala 58:33]
    node _io_wrote_valid_T_1 = mux(_io_wrote_valid_T, acc.io.wrote.valid, UInt<1>("h0")) @[AccumulatorWithALUArray.scala 57:24]
    io.wrote.valid <= _io_wrote_valid_T_1 @[AccumulatorWithALUArray.scala 57:18]
    acc.io.wrote.ready <= io.wrote.ready @[AccumulatorWithALUArray.scala 62:22]
    io.computed.bits <= UInt<1>("h1") @[AccumulatorWithALUArray.scala 63:20]
    io.computed.valid <= alu.io.output.valid @[AccumulatorWithALUArray.scala 64:21]
    io.nooped.bits <= UInt<1>("h1") @[AccumulatorWithALUArray.scala 65:18]
    node _io_nooped_valid_T = eq(io.control.bits.instruction.op, UInt<1>("h0")) @[AccumulatorWithALUArray.scala 66:50]
    node _io_nooped_valid_T_1 = eq(io.control.bits.read, UInt<1>("h0")) @[AccumulatorWithALUArray.scala 66:61]
    node _io_nooped_valid_T_2 = and(_io_nooped_valid_T, _io_nooped_valid_T_1) @[AccumulatorWithALUArray.scala 66:58]
    node _io_nooped_valid_T_3 = eq(io.control.bits.write, UInt<1>("h0")) @[AccumulatorWithALUArray.scala 66:83]
    node _io_nooped_valid_T_4 = and(_io_nooped_valid_T_2, _io_nooped_valid_T_3) @[AccumulatorWithALUArray.scala 66:80]
    node _io_nooped_valid_T_5 = and(_io_nooped_valid_T_4, io.control.ready) @[AccumulatorWithALUArray.scala 66:103]
    io.nooped.valid <= _io_nooped_valid_T_5 @[AccumulatorWithALUArray.scala 66:19]
    acc.io.tracepoint <= io.tracepoint @[AccumulatorWithALUArray.scala 68:21]
    acc.io.programCounter <= io.programCounter @[AccumulatorWithALUArray.scala 69:25]
    inst aluOutputDemux_x6_demux of Demux_1 @[Demux.scala 46:23]
    aluOutputDemux_x6_demux.clock <= clock
    aluOutputDemux_x6_demux.reset <= reset
    aluOutputDemux_x6_demux.io.in <= alu.io.output @[Demux.scala 54:17]
    aluOutputSink.io.in <= aluOutputDemux_x6_demux.io.out[0] @[Demux.scala 55:10]
    aluOutputForAccInput.bits <= aluOutputDemux_x6_demux.io.out[1].bits @[Demux.scala 56:10]
    aluOutputForAccInput.valid <= aluOutputDemux_x6_demux.io.out[1].valid @[Demux.scala 56:10]
    aluOutputDemux_x6_demux.io.out[1].ready <= aluOutputForAccInput.ready @[Demux.scala 56:10]
    inst aluOutputDemux of Queue_18 @[Mem.scala 22:19]
    aluOutputDemux.clock <= clock
    aluOutputDemux.reset <= reset
    aluOutputDemux_x6_demux.io.sel <= aluOutputDemux.io.deq @[Mem.scala 23:7]
    inst accInputMux_x15_mux of Mux_1 @[Mux.scala 71:21]
    accInputMux_x15_mux.clock <= clock
    accInputMux_x15_mux.reset <= reset
    accInputMux_x15_mux.io.in[0] <= io.input @[Mux.scala 79:18]
    accInputMux_x15_mux.io.in[1] <= aluOutputForAccInput @[Mux.scala 80:18]
    acc.io.input <= accInputMux_x15_mux.io.out @[Mux.scala 81:9]
    inst accInputMux of Queue_19 @[Mem.scala 22:19]
    accInputMux.clock <= clock
    accInputMux.reset <= reset
    accInputMux_x15_mux.io.sel <= accInputMux.io.deq @[Mem.scala 23:7]
    inst accOutputDemux_x24_demux of Demux_2 @[Demux.scala 46:23]
    accOutputDemux_x24_demux.clock <= clock
    accOutputDemux_x24_demux.reset <= reset
    accOutputDemux_x24_demux.io.in <= acc.io.output @[Demux.scala 54:17]
    io.output.bits <= accOutputDemux_x24_demux.io.out[0].bits @[Demux.scala 55:10]
    io.output.valid <= accOutputDemux_x24_demux.io.out[0].valid @[Demux.scala 55:10]
    accOutputDemux_x24_demux.io.out[0].ready <= io.output.ready @[Demux.scala 55:10]
    alu.io.input <= accOutputDemux_x24_demux.io.out[1] @[Demux.scala 56:10]
    inst accOutputDemux of Queue_20 @[Mem.scala 22:19]
    accOutputDemux.clock <= clock
    accOutputDemux.reset <= reset
    accOutputDemux_x24_demux.io.sel <= accOutputDemux.io.deq @[Mem.scala 23:7]
    wire _aluOutputDemux_io_enq_bits_WIRE : UInt<1> @[package.scala 72:41]
    _aluOutputDemux_io_enq_bits_WIRE <= UInt<1>("h0") @[package.scala 72:41]
    aluOutputDemux.io.enq.bits <= _aluOutputDemux_io_enq_bits_WIRE @[package.scala 404:14]
    aluOutputDemux.io.enq.valid <= UInt<1>("h0") @[package.scala 405:15]
    wire _accInputMux_io_enq_bits_WIRE : UInt<1> @[package.scala 72:41]
    _accInputMux_io_enq_bits_WIRE <= UInt<1>("h0") @[package.scala 72:41]
    accInputMux.io.enq.bits <= _accInputMux_io_enq_bits_WIRE @[package.scala 404:14]
    accInputMux.io.enq.valid <= UInt<1>("h0") @[package.scala 405:15]
    wire _accOutputDemux_io_enq_bits_WIRE : UInt<1> @[package.scala 72:41]
    _accOutputDemux_io_enq_bits_WIRE <= UInt<1>("h0") @[package.scala 72:41]
    accOutputDemux.io.enq.bits <= _accOutputDemux_io_enq_bits_WIRE @[package.scala 404:14]
    accOutputDemux.io.enq.valid <= UInt<1>("h0") @[package.scala 405:15]
    wire _acc_io_control_bits_WIRE : { address : UInt<11>, accumulate : UInt<1>, write : UInt<1>} @[package.scala 75:57]
    _acc_io_control_bits_WIRE.write <= UInt<1>("h0") @[package.scala 75:57]
    _acc_io_control_bits_WIRE.accumulate <= UInt<1>("h0") @[package.scala 75:57]
    _acc_io_control_bits_WIRE.address <= UInt<11>("h0") @[package.scala 75:57]
    acc.io.control.bits.write <= _acc_io_control_bits_WIRE.write @[package.scala 404:14]
    acc.io.control.bits.accumulate <= _acc_io_control_bits_WIRE.accumulate @[package.scala 404:14]
    acc.io.control.bits.address <= _acc_io_control_bits_WIRE.address @[package.scala 404:14]
    acc.io.control.valid <= UInt<1>("h0") @[package.scala 405:15]
    wire _alu_io_instruction_bits_WIRE : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>} @[package.scala 75:57]
    _alu_io_instruction_bits_WIRE.dest <= UInt<1>("h0") @[package.scala 75:57]
    _alu_io_instruction_bits_WIRE.sourceRight <= UInt<1>("h0") @[package.scala 75:57]
    _alu_io_instruction_bits_WIRE.sourceLeft <= UInt<1>("h0") @[package.scala 75:57]
    _alu_io_instruction_bits_WIRE.op <= UInt<4>("h0") @[package.scala 75:57]
    alu.io.instruction.bits.dest <= _alu_io_instruction_bits_WIRE.dest @[package.scala 404:14]
    alu.io.instruction.bits.sourceRight <= _alu_io_instruction_bits_WIRE.sourceRight @[package.scala 404:14]
    alu.io.instruction.bits.sourceLeft <= _alu_io_instruction_bits_WIRE.sourceLeft @[package.scala 404:14]
    alu.io.instruction.bits.op <= _alu_io_instruction_bits_WIRE.op @[package.scala 404:14]
    alu.io.instruction.valid <= UInt<1>("h0") @[package.scala 405:15]
    reg readEnqueued : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[AccumulatorWithALUArray.scala 110:29]
    readEnqueued <= UInt<1>("h0") @[AccumulatorWithALUArray.scala 111:16]
    inst accWriteEnqueuer of MultiEnqueue_8 @[MultiEnqueue.scala 182:43]
    accWriteEnqueuer.clock <= clock
    accWriteEnqueuer.reset <= reset
    inst accReadEnqueuer of MultiEnqueue_9 @[MultiEnqueue.scala 182:43]
    accReadEnqueuer.clock <= clock
    accReadEnqueuer.reset <= reset
    inst simdRWWriteEnqueuer of MultiEnqueue_10 @[MultiEnqueue.scala 182:43]
    simdRWWriteEnqueuer.clock <= clock
    simdRWWriteEnqueuer.reset <= reset
    inst simdRWReadEnqueuer of MultiEnqueue_11 @[MultiEnqueue.scala 182:43]
    simdRWReadEnqueuer.clock <= clock
    simdRWReadEnqueuer.reset <= reset
    inst simdWriteEnqueuer of MultiEnqueue_12 @[MultiEnqueue.scala 182:43]
    simdWriteEnqueuer.clock <= clock
    simdWriteEnqueuer.reset <= reset
    inst simdReadEnqueuer of MultiEnqueue_13 @[MultiEnqueue.scala 182:43]
    simdReadEnqueuer.clock <= clock
    simdReadEnqueuer.reset <= reset
    inst simdEnqueuer of MultiEnqueue_14 @[MultiEnqueue.scala 182:43]
    simdEnqueuer.clock <= clock
    simdEnqueuer.reset <= reset
    accWriteEnqueuer.io.in.valid <= UInt<1>("h0") @[MultiEnqueue.scala 40:17]
    accWriteEnqueuer.io.out[0].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    accWriteEnqueuer.io.out[1].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    accReadEnqueuer.io.in.valid <= UInt<1>("h0") @[MultiEnqueue.scala 40:17]
    accReadEnqueuer.io.out[0].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    accReadEnqueuer.io.out[1].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    simdRWWriteEnqueuer.io.in.valid <= UInt<1>("h0") @[MultiEnqueue.scala 40:17]
    simdRWWriteEnqueuer.io.out[0].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    simdRWWriteEnqueuer.io.out[1].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    simdRWWriteEnqueuer.io.out[2].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    simdRWReadEnqueuer.io.in.valid <= UInt<1>("h0") @[MultiEnqueue.scala 40:17]
    simdRWReadEnqueuer.io.out[0].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    simdRWReadEnqueuer.io.out[1].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    simdRWReadEnqueuer.io.out[2].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    simdWriteEnqueuer.io.in.valid <= UInt<1>("h0") @[MultiEnqueue.scala 40:17]
    simdWriteEnqueuer.io.out[0].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    simdWriteEnqueuer.io.out[1].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    simdWriteEnqueuer.io.out[2].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    simdWriteEnqueuer.io.out[3].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    simdReadEnqueuer.io.in.valid <= UInt<1>("h0") @[MultiEnqueue.scala 40:17]
    simdReadEnqueuer.io.out[0].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    simdReadEnqueuer.io.out[1].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    simdReadEnqueuer.io.out[2].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    simdReadEnqueuer.io.out[3].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    simdEnqueuer.io.in.valid <= UInt<1>("h0") @[MultiEnqueue.scala 40:17]
    simdEnqueuer.io.out[0].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    simdEnqueuer.io.out[1].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    node isNoOp = eq(io.control.bits.instruction.op, UInt<1>("h0")) @[AccumulatorWithALUArray.scala 130:44]
    when isNoOp : @[AccumulatorWithALUArray.scala 133:16]
      wire dataPathReady : UInt<1>
      dataPathReady <= UInt<1>("h0")
      when io.control.bits.read : @[AccumulatorWithALUArray.scala 135:29]
        when io.control.bits.write : @[AccumulatorWithALUArray.scala 136:32]
          when readEnqueued : @[AccumulatorWithALUArray.scala 137:28]
            wire dataPathReady_w : { address : UInt<11>, accumulate : UInt<1>, write : UInt<1>} @[AccumulatorWithALUArray.scala 261:17]
            dataPathReady_w.address <= io.control.bits.writeAddress @[AccumulatorWithALUArray.scala 262:15]
            dataPathReady_w.write <= UInt<1>("h1") @[AccumulatorWithALUArray.scala 263:13]
            dataPathReady_w.accumulate <= io.control.bits.accumulate @[AccumulatorWithALUArray.scala 264:18]
            accWriteEnqueuer.io.in.valid <= io.control.valid @[MultiEnqueue.scala 84:17]
            wire dataPathReady_acc_io_control_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { address : UInt<11>, accumulate : UInt<1>, write : UInt<1>}} @[ReadyValid.scala 16:17]
            dataPathReady_acc_io_control_w.bits <= dataPathReady_w @[ReadyValid.scala 17:12]
            dataPathReady_acc_io_control_w.valid <= accWriteEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
            accWriteEnqueuer.io.out[0].ready <= dataPathReady_acc_io_control_w.ready @[ReadyValid.scala 19:11]
            acc.io.control <= dataPathReady_acc_io_control_w @[MultiEnqueue.scala 85:10]
            wire dataPathReady_accInputMux_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
            dataPathReady_accInputMux_io_enq_w.bits <= UInt<1>("h0") @[ReadyValid.scala 17:12]
            dataPathReady_accInputMux_io_enq_w.valid <= accWriteEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
            accWriteEnqueuer.io.out[1].ready <= dataPathReady_accInputMux_io_enq_w.ready @[ReadyValid.scala 19:11]
            accInputMux.io.enq <= dataPathReady_accInputMux_io_enq_w @[MultiEnqueue.scala 86:10]
            dataPathReady <= accWriteEnqueuer.io.in.ready @[AccumulatorWithALUArray.scala 138:25]
            when dataPathReady : @[AccumulatorWithALUArray.scala 145:31]
              readEnqueued <= UInt<1>("h0") @[AccumulatorWithALUArray.scala 146:26]
            else :
              readEnqueued <= readEnqueued @[AccumulatorWithALUArray.scala 148:26]
          else :
            dataPathReady <= UInt<1>("h0") @[AccumulatorWithALUArray.scala 151:25]
            wire readEnqueued_w : { address : UInt<11>, accumulate : UInt<1>, write : UInt<1>} @[AccumulatorWithALUArray.scala 269:17]
            readEnqueued_w.address <= io.control.bits.readAddress @[AccumulatorWithALUArray.scala 270:15]
            readEnqueued_w.write <= UInt<1>("h0") @[AccumulatorWithALUArray.scala 271:13]
            readEnqueued_w.accumulate <= UInt<1>("h0") @[AccumulatorWithALUArray.scala 272:18]
            accReadEnqueuer.io.in.valid <= io.control.valid @[MultiEnqueue.scala 84:17]
            wire readEnqueued_acc_io_control_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { address : UInt<11>, accumulate : UInt<1>, write : UInt<1>}} @[ReadyValid.scala 16:17]
            readEnqueued_acc_io_control_w.bits <= readEnqueued_w @[ReadyValid.scala 17:12]
            readEnqueued_acc_io_control_w.valid <= accReadEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
            accReadEnqueuer.io.out[0].ready <= readEnqueued_acc_io_control_w.ready @[ReadyValid.scala 19:11]
            acc.io.control <= readEnqueued_acc_io_control_w @[MultiEnqueue.scala 85:10]
            wire readEnqueued_accOutputDemux_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
            readEnqueued_accOutputDemux_io_enq_w.bits <= UInt<1>("h0") @[ReadyValid.scala 17:12]
            readEnqueued_accOutputDemux_io_enq_w.valid <= accReadEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
            accReadEnqueuer.io.out[1].ready <= readEnqueued_accOutputDemux_io_enq_w.ready @[ReadyValid.scala 19:11]
            accOutputDemux.io.enq <= readEnqueued_accOutputDemux_io_enq_w @[MultiEnqueue.scala 86:10]
            readEnqueued <= accReadEnqueuer.io.in.ready @[AccumulatorWithALUArray.scala 152:24]
        else :
          wire dataPathReady_w_1 : { address : UInt<11>, accumulate : UInt<1>, write : UInt<1>} @[AccumulatorWithALUArray.scala 269:17]
          dataPathReady_w_1.address <= io.control.bits.readAddress @[AccumulatorWithALUArray.scala 270:15]
          dataPathReady_w_1.write <= UInt<1>("h0") @[AccumulatorWithALUArray.scala 271:13]
          dataPathReady_w_1.accumulate <= UInt<1>("h0") @[AccumulatorWithALUArray.scala 272:18]
          accReadEnqueuer.io.in.valid <= io.control.valid @[MultiEnqueue.scala 84:17]
          wire dataPathReady_acc_io_control_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : { address : UInt<11>, accumulate : UInt<1>, write : UInt<1>}} @[ReadyValid.scala 16:17]
          dataPathReady_acc_io_control_w_1.bits <= dataPathReady_w_1 @[ReadyValid.scala 17:12]
          dataPathReady_acc_io_control_w_1.valid <= accReadEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
          accReadEnqueuer.io.out[0].ready <= dataPathReady_acc_io_control_w_1.ready @[ReadyValid.scala 19:11]
          acc.io.control <= dataPathReady_acc_io_control_w_1 @[MultiEnqueue.scala 85:10]
          wire dataPathReady_accOutputDemux_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
          dataPathReady_accOutputDemux_io_enq_w.bits <= UInt<1>("h0") @[ReadyValid.scala 17:12]
          dataPathReady_accOutputDemux_io_enq_w.valid <= accReadEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
          accReadEnqueuer.io.out[1].ready <= dataPathReady_accOutputDemux_io_enq_w.ready @[ReadyValid.scala 19:11]
          accOutputDemux.io.enq <= dataPathReady_accOutputDemux_io_enq_w @[MultiEnqueue.scala 86:10]
          dataPathReady <= accReadEnqueuer.io.in.ready @[AccumulatorWithALUArray.scala 161:23]
      else :
        when io.control.bits.write : @[AccumulatorWithALUArray.scala 170:32]
          wire dataPathReady_w_2 : { address : UInt<11>, accumulate : UInt<1>, write : UInt<1>} @[AccumulatorWithALUArray.scala 261:17]
          dataPathReady_w_2.address <= io.control.bits.writeAddress @[AccumulatorWithALUArray.scala 262:15]
          dataPathReady_w_2.write <= UInt<1>("h1") @[AccumulatorWithALUArray.scala 263:13]
          dataPathReady_w_2.accumulate <= io.control.bits.accumulate @[AccumulatorWithALUArray.scala 264:18]
          accWriteEnqueuer.io.in.valid <= io.control.valid @[MultiEnqueue.scala 84:17]
          wire dataPathReady_acc_io_control_w_2 : { flip ready : UInt<1>, valid : UInt<1>, bits : { address : UInt<11>, accumulate : UInt<1>, write : UInt<1>}} @[ReadyValid.scala 16:17]
          dataPathReady_acc_io_control_w_2.bits <= dataPathReady_w_2 @[ReadyValid.scala 17:12]
          dataPathReady_acc_io_control_w_2.valid <= accWriteEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
          accWriteEnqueuer.io.out[0].ready <= dataPathReady_acc_io_control_w_2.ready @[ReadyValid.scala 19:11]
          acc.io.control <= dataPathReady_acc_io_control_w_2 @[MultiEnqueue.scala 85:10]
          wire dataPathReady_accInputMux_io_enq_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
          dataPathReady_accInputMux_io_enq_w_1.bits <= UInt<1>("h0") @[ReadyValid.scala 17:12]
          dataPathReady_accInputMux_io_enq_w_1.valid <= accWriteEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
          accWriteEnqueuer.io.out[1].ready <= dataPathReady_accInputMux_io_enq_w_1.ready @[ReadyValid.scala 19:11]
          accInputMux.io.enq <= dataPathReady_accInputMux_io_enq_w_1 @[MultiEnqueue.scala 86:10]
          dataPathReady <= accWriteEnqueuer.io.in.ready @[AccumulatorWithALUArray.scala 171:23]
        else :
          dataPathReady <= UInt<1>("h1") @[AccumulatorWithALUArray.scala 179:23]
      io.control.ready <= dataPathReady @[AccumulatorWithALUArray.scala 182:19]
    else :
      wire dataPathReady_1 : UInt<1>
      dataPathReady_1 <= UInt<1>("h0")
      when io.control.bits.read : @[AccumulatorWithALUArray.scala 185:29]
        when io.control.bits.write : @[AccumulatorWithALUArray.scala 186:32]
          when readEnqueued : @[AccumulatorWithALUArray.scala 188:28]
            wire dataPathReady_w_3 : { address : UInt<11>, accumulate : UInt<1>, write : UInt<1>} @[AccumulatorWithALUArray.scala 261:17]
            dataPathReady_w_3.address <= io.control.bits.writeAddress @[AccumulatorWithALUArray.scala 262:15]
            dataPathReady_w_3.write <= UInt<1>("h1") @[AccumulatorWithALUArray.scala 263:13]
            dataPathReady_w_3.accumulate <= io.control.bits.accumulate @[AccumulatorWithALUArray.scala 264:18]
            simdRWWriteEnqueuer.io.in.valid <= io.control.valid @[MultiEnqueue.scala 114:17]
            wire dataPathReady_acc_io_control_w_3 : { flip ready : UInt<1>, valid : UInt<1>, bits : { address : UInt<11>, accumulate : UInt<1>, write : UInt<1>}} @[ReadyValid.scala 16:17]
            dataPathReady_acc_io_control_w_3.bits <= dataPathReady_w_3 @[ReadyValid.scala 17:12]
            dataPathReady_acc_io_control_w_3.valid <= simdRWWriteEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
            simdRWWriteEnqueuer.io.out[0].ready <= dataPathReady_acc_io_control_w_3.ready @[ReadyValid.scala 19:11]
            acc.io.control <= dataPathReady_acc_io_control_w_3 @[MultiEnqueue.scala 115:10]
            wire dataPathReady_aluOutputDemux_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
            dataPathReady_aluOutputDemux_io_enq_w.bits <= UInt<1>("h1") @[ReadyValid.scala 17:12]
            dataPathReady_aluOutputDemux_io_enq_w.valid <= simdRWWriteEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
            simdRWWriteEnqueuer.io.out[1].ready <= dataPathReady_aluOutputDemux_io_enq_w.ready @[ReadyValid.scala 19:11]
            aluOutputDemux.io.enq <= dataPathReady_aluOutputDemux_io_enq_w @[MultiEnqueue.scala 116:10]
            wire dataPathReady_accInputMux_io_enq_w_2 : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
            dataPathReady_accInputMux_io_enq_w_2.bits <= UInt<1>("h1") @[ReadyValid.scala 17:12]
            dataPathReady_accInputMux_io_enq_w_2.valid <= simdRWWriteEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
            simdRWWriteEnqueuer.io.out[2].ready <= dataPathReady_accInputMux_io_enq_w_2.ready @[ReadyValid.scala 19:11]
            accInputMux.io.enq <= dataPathReady_accInputMux_io_enq_w_2 @[MultiEnqueue.scala 117:10]
            dataPathReady_1 <= simdRWWriteEnqueuer.io.in.ready @[AccumulatorWithALUArray.scala 189:25]
            when dataPathReady_1 : @[AccumulatorWithALUArray.scala 198:31]
              readEnqueued <= UInt<1>("h0") @[AccumulatorWithALUArray.scala 199:26]
            else :
              readEnqueued <= readEnqueued @[AccumulatorWithALUArray.scala 201:26]
          else :
            dataPathReady_1 <= UInt<1>("h0") @[AccumulatorWithALUArray.scala 204:25]
            node _T = eq(io.control.bits.instruction.sourceLeft, UInt<1>("h0")) @[AccumulatorWithALUArray.scala 206:49]
            node _T_1 = eq(io.control.bits.instruction.sourceRight, UInt<1>("h0")) @[AccumulatorWithALUArray.scala 206:97]
            node _T_2 = or(_T, _T_1) @[AccumulatorWithALUArray.scala 206:57]
            when _T_2 : @[AccumulatorWithALUArray.scala 207:13]
              wire readEnqueued_w_1 : { address : UInt<11>, accumulate : UInt<1>, write : UInt<1>} @[AccumulatorWithALUArray.scala 269:17]
              readEnqueued_w_1.address <= io.control.bits.readAddress @[AccumulatorWithALUArray.scala 270:15]
              readEnqueued_w_1.write <= UInt<1>("h0") @[AccumulatorWithALUArray.scala 271:13]
              readEnqueued_w_1.accumulate <= UInt<1>("h0") @[AccumulatorWithALUArray.scala 272:18]
              simdRWReadEnqueuer.io.in.valid <= io.control.valid @[MultiEnqueue.scala 114:17]
              wire readEnqueued_acc_io_control_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : { address : UInt<11>, accumulate : UInt<1>, write : UInt<1>}} @[ReadyValid.scala 16:17]
              readEnqueued_acc_io_control_w_1.bits <= readEnqueued_w_1 @[ReadyValid.scala 17:12]
              readEnqueued_acc_io_control_w_1.valid <= simdRWReadEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
              simdRWReadEnqueuer.io.out[0].ready <= readEnqueued_acc_io_control_w_1.ready @[ReadyValid.scala 19:11]
              acc.io.control <= readEnqueued_acc_io_control_w_1 @[MultiEnqueue.scala 115:10]
              wire readEnqueued_accOutputDemux_io_enq_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
              readEnqueued_accOutputDemux_io_enq_w_1.bits <= UInt<1>("h1") @[ReadyValid.scala 17:12]
              readEnqueued_accOutputDemux_io_enq_w_1.valid <= simdRWReadEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
              simdRWReadEnqueuer.io.out[1].ready <= readEnqueued_accOutputDemux_io_enq_w_1.ready @[ReadyValid.scala 19:11]
              accOutputDemux.io.enq <= readEnqueued_accOutputDemux_io_enq_w_1 @[MultiEnqueue.scala 116:10]
              wire readEnqueued_alu_io_instruction_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}} @[ReadyValid.scala 16:17]
              readEnqueued_alu_io_instruction_w.bits <= io.control.bits.instruction @[ReadyValid.scala 17:12]
              readEnqueued_alu_io_instruction_w.valid <= simdRWReadEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
              simdRWReadEnqueuer.io.out[2].ready <= readEnqueued_alu_io_instruction_w.ready @[ReadyValid.scala 19:11]
              alu.io.instruction <= readEnqueued_alu_io_instruction_w @[MultiEnqueue.scala 117:10]
              readEnqueued <= simdRWReadEnqueuer.io.in.ready @[AccumulatorWithALUArray.scala 208:26]
            else :
              readEnqueued <= UInt<1>("h1") @[AccumulatorWithALUArray.scala 218:26]
        else :
          wire dataPathReady_w_4 : { address : UInt<11>, accumulate : UInt<1>, write : UInt<1>} @[AccumulatorWithALUArray.scala 269:17]
          dataPathReady_w_4.address <= io.control.bits.readAddress @[AccumulatorWithALUArray.scala 270:15]
          dataPathReady_w_4.write <= UInt<1>("h0") @[AccumulatorWithALUArray.scala 271:13]
          dataPathReady_w_4.accumulate <= UInt<1>("h0") @[AccumulatorWithALUArray.scala 272:18]
          simdReadEnqueuer.io.in.valid <= io.control.valid @[MultiEnqueue.scala 150:17]
          wire dataPathReady_acc_io_control_w_4 : { flip ready : UInt<1>, valid : UInt<1>, bits : { address : UInt<11>, accumulate : UInt<1>, write : UInt<1>}} @[ReadyValid.scala 16:17]
          dataPathReady_acc_io_control_w_4.bits <= dataPathReady_w_4 @[ReadyValid.scala 17:12]
          dataPathReady_acc_io_control_w_4.valid <= simdReadEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
          simdReadEnqueuer.io.out[0].ready <= dataPathReady_acc_io_control_w_4.ready @[ReadyValid.scala 19:11]
          acc.io.control <= dataPathReady_acc_io_control_w_4 @[MultiEnqueue.scala 151:10]
          wire dataPathReady_accOutputDemux_io_enq_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
          dataPathReady_accOutputDemux_io_enq_w_1.bits <= UInt<1>("h1") @[ReadyValid.scala 17:12]
          dataPathReady_accOutputDemux_io_enq_w_1.valid <= simdReadEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
          simdReadEnqueuer.io.out[1].ready <= dataPathReady_accOutputDemux_io_enq_w_1.ready @[ReadyValid.scala 19:11]
          accOutputDemux.io.enq <= dataPathReady_accOutputDemux_io_enq_w_1 @[MultiEnqueue.scala 152:10]
          wire dataPathReady_aluOutputDemux_io_enq_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
          dataPathReady_aluOutputDemux_io_enq_w_1.bits <= UInt<1>("h0") @[ReadyValid.scala 17:12]
          dataPathReady_aluOutputDemux_io_enq_w_1.valid <= simdReadEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
          simdReadEnqueuer.io.out[2].ready <= dataPathReady_aluOutputDemux_io_enq_w_1.ready @[ReadyValid.scala 19:11]
          aluOutputDemux.io.enq <= dataPathReady_aluOutputDemux_io_enq_w_1 @[MultiEnqueue.scala 153:10]
          wire dataPathReady_alu_io_instruction_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}} @[ReadyValid.scala 16:17]
          dataPathReady_alu_io_instruction_w.bits <= io.control.bits.instruction @[ReadyValid.scala 17:12]
          dataPathReady_alu_io_instruction_w.valid <= simdReadEnqueuer.io.out[3].valid @[ReadyValid.scala 18:13]
          simdReadEnqueuer.io.out[3].ready <= dataPathReady_alu_io_instruction_w.ready @[ReadyValid.scala 19:11]
          alu.io.instruction <= dataPathReady_alu_io_instruction_w @[MultiEnqueue.scala 154:10]
          dataPathReady_1 <= simdReadEnqueuer.io.in.ready @[AccumulatorWithALUArray.scala 222:23]
      else :
        when io.control.bits.write : @[AccumulatorWithALUArray.scala 235:32]
          wire dataPathReady_w_5 : { address : UInt<11>, accumulate : UInt<1>, write : UInt<1>} @[AccumulatorWithALUArray.scala 261:17]
          dataPathReady_w_5.address <= io.control.bits.writeAddress @[AccumulatorWithALUArray.scala 262:15]
          dataPathReady_w_5.write <= UInt<1>("h1") @[AccumulatorWithALUArray.scala 263:13]
          dataPathReady_w_5.accumulate <= io.control.bits.accumulate @[AccumulatorWithALUArray.scala 264:18]
          simdWriteEnqueuer.io.in.valid <= io.control.valid @[MultiEnqueue.scala 150:17]
          wire dataPathReady_acc_io_control_w_5 : { flip ready : UInt<1>, valid : UInt<1>, bits : { address : UInt<11>, accumulate : UInt<1>, write : UInt<1>}} @[ReadyValid.scala 16:17]
          dataPathReady_acc_io_control_w_5.bits <= dataPathReady_w_5 @[ReadyValid.scala 17:12]
          dataPathReady_acc_io_control_w_5.valid <= simdWriteEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
          simdWriteEnqueuer.io.out[0].ready <= dataPathReady_acc_io_control_w_5.ready @[ReadyValid.scala 19:11]
          acc.io.control <= dataPathReady_acc_io_control_w_5 @[MultiEnqueue.scala 151:10]
          wire dataPathReady_aluOutputDemux_io_enq_w_2 : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
          dataPathReady_aluOutputDemux_io_enq_w_2.bits <= UInt<1>("h1") @[ReadyValid.scala 17:12]
          dataPathReady_aluOutputDemux_io_enq_w_2.valid <= simdWriteEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
          simdWriteEnqueuer.io.out[1].ready <= dataPathReady_aluOutputDemux_io_enq_w_2.ready @[ReadyValid.scala 19:11]
          aluOutputDemux.io.enq <= dataPathReady_aluOutputDemux_io_enq_w_2 @[MultiEnqueue.scala 152:10]
          wire dataPathReady_accInputMux_io_enq_w_3 : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
          dataPathReady_accInputMux_io_enq_w_3.bits <= UInt<1>("h1") @[ReadyValid.scala 17:12]
          dataPathReady_accInputMux_io_enq_w_3.valid <= simdWriteEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
          simdWriteEnqueuer.io.out[2].ready <= dataPathReady_accInputMux_io_enq_w_3.ready @[ReadyValid.scala 19:11]
          accInputMux.io.enq <= dataPathReady_accInputMux_io_enq_w_3 @[MultiEnqueue.scala 153:10]
          wire dataPathReady_alu_io_instruction_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}} @[ReadyValid.scala 16:17]
          dataPathReady_alu_io_instruction_w_1.bits <= io.control.bits.instruction @[ReadyValid.scala 17:12]
          dataPathReady_alu_io_instruction_w_1.valid <= simdWriteEnqueuer.io.out[3].valid @[ReadyValid.scala 18:13]
          simdWriteEnqueuer.io.out[3].ready <= dataPathReady_alu_io_instruction_w_1.ready @[ReadyValid.scala 19:11]
          alu.io.instruction <= dataPathReady_alu_io_instruction_w_1 @[MultiEnqueue.scala 154:10]
          dataPathReady_1 <= simdWriteEnqueuer.io.in.ready @[AccumulatorWithALUArray.scala 236:23]
        else :
          simdEnqueuer.io.in.valid <= io.control.valid @[MultiEnqueue.scala 84:17]
          wire dataPathReady_aluOutputDemux_io_enq_w_3 : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
          dataPathReady_aluOutputDemux_io_enq_w_3.bits <= UInt<1>("h0") @[ReadyValid.scala 17:12]
          dataPathReady_aluOutputDemux_io_enq_w_3.valid <= simdEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
          simdEnqueuer.io.out[0].ready <= dataPathReady_aluOutputDemux_io_enq_w_3.ready @[ReadyValid.scala 19:11]
          aluOutputDemux.io.enq <= dataPathReady_aluOutputDemux_io_enq_w_3 @[MultiEnqueue.scala 85:10]
          wire dataPathReady_alu_io_instruction_w_2 : { flip ready : UInt<1>, valid : UInt<1>, bits : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}} @[ReadyValid.scala 16:17]
          dataPathReady_alu_io_instruction_w_2.bits <= io.control.bits.instruction @[ReadyValid.scala 17:12]
          dataPathReady_alu_io_instruction_w_2.valid <= simdEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
          simdEnqueuer.io.out[1].ready <= dataPathReady_alu_io_instruction_w_2.ready @[ReadyValid.scala 19:11]
          alu.io.instruction <= dataPathReady_alu_io_instruction_w_2 @[MultiEnqueue.scala 86:10]
          dataPathReady_1 <= simdEnqueuer.io.in.ready @[AccumulatorWithALUArray.scala 248:23]
      io.control.ready <= dataPathReady_1 @[AccumulatorWithALUArray.scala 257:19]

  extmodule bram_dp_128x8192 :
    input clka : UInt<1>
    input wea : UInt<1>
    input ena : UInt<1>
    input addra : UInt<13>
    input dia : UInt<128>
    output doa : UInt<128>
    input clkb : UInt<1>
    input web : UInt<1>
    input enb : UInt<1>
    input addrb : UInt<13>
    input dib : UInt<128>
    output dob : UInt<128>
    defname = bram_dp_128x8192

  module InnerDualPortMem_1 :
    input clock : Clock
    input reset : Reset
    output io : { portA : { flip address : UInt<13>, read : { flip enable : UInt<1>, data : Fixed<16><<8>>[8]}, write : { flip enable : UInt<1>, flip data : Fixed<16><<8>>[8]}}, portB : { flip address : UInt<13>, read : { flip enable : UInt<1>, data : Fixed<16><<8>>[8]}, write : { flip enable : UInt<1>, flip data : Fixed<16><<8>>[8]}}}

    inst mem of bram_dp_128x8192 @[DualPortMem.scala 173:25]
    mem.dob is invalid
    mem.dib is invalid
    mem.addrb is invalid
    mem.enb is invalid
    mem.web is invalid
    mem.clkb is invalid
    mem.doa is invalid
    mem.dia is invalid
    mem.addra is invalid
    mem.ena is invalid
    mem.wea is invalid
    mem.clka is invalid
    node _mem_io_clka_T = asUInt(clock) @[DualPortMem.scala 175:30]
    node _mem_io_clka_T_1 = bits(_mem_io_clka_T, 0, 0) @[DualPortMem.scala 175:30]
    mem.clka <= _mem_io_clka_T_1 @[DualPortMem.scala 175:21]
    node _mem_io_ena_T = asUInt(reset) @[DualPortMem.scala 176:30]
    node _mem_io_ena_T_1 = eq(_mem_io_ena_T, UInt<1>("h0")) @[DualPortMem.scala 176:23]
    mem.ena <= _mem_io_ena_T_1 @[DualPortMem.scala 176:20]
    mem.addra <= io.portA.address @[DualPortMem.scala 177:22]
    wire _io_portA_read_data_WIRE : Fixed<16><<8>>[8] @[DualPortMem.scala 178:50]
    wire _io_portA_read_data_WIRE_1 : UInt<128>
    _io_portA_read_data_WIRE_1 <= mem.doa
    node _io_portA_read_data_T = bits(_io_portA_read_data_WIRE_1, 15, 0) @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_1 = asFixedPoint(_io_portA_read_data_T, 8) @[DualPortMem.scala 178:50]
    _io_portA_read_data_WIRE[0] <= _io_portA_read_data_T_1 @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_2 = bits(_io_portA_read_data_WIRE_1, 31, 16) @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_3 = asFixedPoint(_io_portA_read_data_T_2, 8) @[DualPortMem.scala 178:50]
    _io_portA_read_data_WIRE[1] <= _io_portA_read_data_T_3 @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_4 = bits(_io_portA_read_data_WIRE_1, 47, 32) @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_5 = asFixedPoint(_io_portA_read_data_T_4, 8) @[DualPortMem.scala 178:50]
    _io_portA_read_data_WIRE[2] <= _io_portA_read_data_T_5 @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_6 = bits(_io_portA_read_data_WIRE_1, 63, 48) @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_7 = asFixedPoint(_io_portA_read_data_T_6, 8) @[DualPortMem.scala 178:50]
    _io_portA_read_data_WIRE[3] <= _io_portA_read_data_T_7 @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_8 = bits(_io_portA_read_data_WIRE_1, 79, 64) @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_9 = asFixedPoint(_io_portA_read_data_T_8, 8) @[DualPortMem.scala 178:50]
    _io_portA_read_data_WIRE[4] <= _io_portA_read_data_T_9 @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_10 = bits(_io_portA_read_data_WIRE_1, 95, 80) @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_11 = asFixedPoint(_io_portA_read_data_T_10, 8) @[DualPortMem.scala 178:50]
    _io_portA_read_data_WIRE[5] <= _io_portA_read_data_T_11 @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_12 = bits(_io_portA_read_data_WIRE_1, 111, 96) @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_13 = asFixedPoint(_io_portA_read_data_T_12, 8) @[DualPortMem.scala 178:50]
    _io_portA_read_data_WIRE[6] <= _io_portA_read_data_T_13 @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_14 = bits(_io_portA_read_data_WIRE_1, 127, 112) @[DualPortMem.scala 178:50]
    node _io_portA_read_data_T_15 = asFixedPoint(_io_portA_read_data_T_14, 8) @[DualPortMem.scala 178:50]
    _io_portA_read_data_WIRE[7] <= _io_portA_read_data_T_15 @[DualPortMem.scala 178:50]
    io.portA.read.data <= _io_portA_read_data_WIRE @[DualPortMem.scala 178:28]
    mem.wea <= io.portA.write.enable @[DualPortMem.scala 179:20]
    wire _mem_io_dia_WIRE : UInt<128> @[DualPortMem.scala 180:51]
    node _mem_io_dia_T = asUInt(io.portA.write.data[0]) @[DualPortMem.scala 180:51]
    node _mem_io_dia_T_1 = asUInt(io.portA.write.data[1]) @[DualPortMem.scala 180:51]
    node _mem_io_dia_T_2 = asUInt(io.portA.write.data[2]) @[DualPortMem.scala 180:51]
    node _mem_io_dia_T_3 = asUInt(io.portA.write.data[3]) @[DualPortMem.scala 180:51]
    node _mem_io_dia_T_4 = asUInt(io.portA.write.data[4]) @[DualPortMem.scala 180:51]
    node _mem_io_dia_T_5 = asUInt(io.portA.write.data[5]) @[DualPortMem.scala 180:51]
    node _mem_io_dia_T_6 = asUInt(io.portA.write.data[6]) @[DualPortMem.scala 180:51]
    node _mem_io_dia_T_7 = asUInt(io.portA.write.data[7]) @[DualPortMem.scala 180:51]
    node mem_io_dia_lo_lo = cat(_mem_io_dia_T_1, _mem_io_dia_T) @[DualPortMem.scala 180:51]
    node mem_io_dia_lo_hi = cat(_mem_io_dia_T_3, _mem_io_dia_T_2) @[DualPortMem.scala 180:51]
    node mem_io_dia_lo = cat(mem_io_dia_lo_hi, mem_io_dia_lo_lo) @[DualPortMem.scala 180:51]
    node mem_io_dia_hi_lo = cat(_mem_io_dia_T_5, _mem_io_dia_T_4) @[DualPortMem.scala 180:51]
    node mem_io_dia_hi_hi = cat(_mem_io_dia_T_7, _mem_io_dia_T_6) @[DualPortMem.scala 180:51]
    node mem_io_dia_hi = cat(mem_io_dia_hi_hi, mem_io_dia_hi_lo) @[DualPortMem.scala 180:51]
    node _mem_io_dia_T_8 = cat(mem_io_dia_hi, mem_io_dia_lo) @[DualPortMem.scala 180:51]
    _mem_io_dia_WIRE <= _mem_io_dia_T_8 @[DualPortMem.scala 180:51]
    mem.dia <= _mem_io_dia_WIRE @[DualPortMem.scala 180:20]
    node _mem_io_clkb_T = asUInt(clock) @[DualPortMem.scala 182:30]
    node _mem_io_clkb_T_1 = bits(_mem_io_clkb_T, 0, 0) @[DualPortMem.scala 182:30]
    mem.clkb <= _mem_io_clkb_T_1 @[DualPortMem.scala 182:21]
    node _mem_io_enb_T = asUInt(reset) @[DualPortMem.scala 183:30]
    node _mem_io_enb_T_1 = eq(_mem_io_enb_T, UInt<1>("h0")) @[DualPortMem.scala 183:23]
    mem.enb <= _mem_io_enb_T_1 @[DualPortMem.scala 183:20]
    mem.addrb <= io.portB.address @[DualPortMem.scala 184:22]
    wire _io_portB_read_data_WIRE : Fixed<16><<8>>[8] @[DualPortMem.scala 185:50]
    wire _io_portB_read_data_WIRE_1 : UInt<128>
    _io_portB_read_data_WIRE_1 <= mem.dob
    node _io_portB_read_data_T = bits(_io_portB_read_data_WIRE_1, 15, 0) @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_1 = asFixedPoint(_io_portB_read_data_T, 8) @[DualPortMem.scala 185:50]
    _io_portB_read_data_WIRE[0] <= _io_portB_read_data_T_1 @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_2 = bits(_io_portB_read_data_WIRE_1, 31, 16) @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_3 = asFixedPoint(_io_portB_read_data_T_2, 8) @[DualPortMem.scala 185:50]
    _io_portB_read_data_WIRE[1] <= _io_portB_read_data_T_3 @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_4 = bits(_io_portB_read_data_WIRE_1, 47, 32) @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_5 = asFixedPoint(_io_portB_read_data_T_4, 8) @[DualPortMem.scala 185:50]
    _io_portB_read_data_WIRE[2] <= _io_portB_read_data_T_5 @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_6 = bits(_io_portB_read_data_WIRE_1, 63, 48) @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_7 = asFixedPoint(_io_portB_read_data_T_6, 8) @[DualPortMem.scala 185:50]
    _io_portB_read_data_WIRE[3] <= _io_portB_read_data_T_7 @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_8 = bits(_io_portB_read_data_WIRE_1, 79, 64) @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_9 = asFixedPoint(_io_portB_read_data_T_8, 8) @[DualPortMem.scala 185:50]
    _io_portB_read_data_WIRE[4] <= _io_portB_read_data_T_9 @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_10 = bits(_io_portB_read_data_WIRE_1, 95, 80) @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_11 = asFixedPoint(_io_portB_read_data_T_10, 8) @[DualPortMem.scala 185:50]
    _io_portB_read_data_WIRE[5] <= _io_portB_read_data_T_11 @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_12 = bits(_io_portB_read_data_WIRE_1, 111, 96) @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_13 = asFixedPoint(_io_portB_read_data_T_12, 8) @[DualPortMem.scala 185:50]
    _io_portB_read_data_WIRE[6] <= _io_portB_read_data_T_13 @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_14 = bits(_io_portB_read_data_WIRE_1, 127, 112) @[DualPortMem.scala 185:50]
    node _io_portB_read_data_T_15 = asFixedPoint(_io_portB_read_data_T_14, 8) @[DualPortMem.scala 185:50]
    _io_portB_read_data_WIRE[7] <= _io_portB_read_data_T_15 @[DualPortMem.scala 185:50]
    io.portB.read.data <= _io_portB_read_data_WIRE @[DualPortMem.scala 185:28]
    mem.web <= io.portB.write.enable @[DualPortMem.scala 186:20]
    wire _mem_io_dib_WIRE : UInt<128> @[DualPortMem.scala 187:51]
    node _mem_io_dib_T = asUInt(io.portB.write.data[0]) @[DualPortMem.scala 187:51]
    node _mem_io_dib_T_1 = asUInt(io.portB.write.data[1]) @[DualPortMem.scala 187:51]
    node _mem_io_dib_T_2 = asUInt(io.portB.write.data[2]) @[DualPortMem.scala 187:51]
    node _mem_io_dib_T_3 = asUInt(io.portB.write.data[3]) @[DualPortMem.scala 187:51]
    node _mem_io_dib_T_4 = asUInt(io.portB.write.data[4]) @[DualPortMem.scala 187:51]
    node _mem_io_dib_T_5 = asUInt(io.portB.write.data[5]) @[DualPortMem.scala 187:51]
    node _mem_io_dib_T_6 = asUInt(io.portB.write.data[6]) @[DualPortMem.scala 187:51]
    node _mem_io_dib_T_7 = asUInt(io.portB.write.data[7]) @[DualPortMem.scala 187:51]
    node mem_io_dib_lo_lo = cat(_mem_io_dib_T_1, _mem_io_dib_T) @[DualPortMem.scala 187:51]
    node mem_io_dib_lo_hi = cat(_mem_io_dib_T_3, _mem_io_dib_T_2) @[DualPortMem.scala 187:51]
    node mem_io_dib_lo = cat(mem_io_dib_lo_hi, mem_io_dib_lo_lo) @[DualPortMem.scala 187:51]
    node mem_io_dib_hi_lo = cat(_mem_io_dib_T_5, _mem_io_dib_T_4) @[DualPortMem.scala 187:51]
    node mem_io_dib_hi_hi = cat(_mem_io_dib_T_7, _mem_io_dib_T_6) @[DualPortMem.scala 187:51]
    node mem_io_dib_hi = cat(mem_io_dib_hi_hi, mem_io_dib_hi_lo) @[DualPortMem.scala 187:51]
    node _mem_io_dib_T_8 = cat(mem_io_dib_hi, mem_io_dib_lo) @[DualPortMem.scala 187:51]
    _mem_io_dib_WIRE <= _mem_io_dib_T_8 @[DualPortMem.scala 187:51]
    mem.dib <= _mem_io_dib_WIRE @[DualPortMem.scala 187:20]

  module Queue_21 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, count : UInt<2>}

    cmem ram : Fixed<16><<8>>[8] [3] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<2>, clock with :
      reset => (reset, UInt<2>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<2>, clock with :
      reset => (reset, UInt<2>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<2>("h2")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
      when wrap : @[Counter.scala 88:20]
        enq_ptr_value <= UInt<1>("h0") @[Counter.scala 88:28]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<2>("h2")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
      when wrap_1 : @[Counter.scala 88:20]
        deq_ptr_value <= UInt<1>("h0") @[Counter.scala 88:28]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = mux(maybe_full, UInt<2>("h3"), UInt<1>("h0")) @[Decoupled.scala 319:10]
    node _io_count_T_1 = gt(deq_ptr_value, enq_ptr_value) @[Decoupled.scala 320:25]
    node _io_count_T_2 = add(UInt<2>("h3"), ptr_diff) @[Decoupled.scala 320:57]
    node _io_count_T_3 = tail(_io_count_T_2, 1) @[Decoupled.scala 320:57]
    node _io_count_T_4 = mux(_io_count_T_1, _io_count_T_3, ptr_diff) @[Decoupled.scala 320:10]
    node _io_count_T_5 = mux(ptr_match, _io_count_T, _io_count_T_4) @[Decoupled.scala 317:20]
    io.count <= _io_count_T_5 @[Decoupled.scala 317:14]

  module Queue_22 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<2>}

    cmem ram : UInt<1> [2] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Queue_23 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, count : UInt<2>}

    cmem ram : Fixed<16><<8>>[8] [3] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<2>, clock with :
      reset => (reset, UInt<2>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<2>, clock with :
      reset => (reset, UInt<2>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<2>("h2")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
      when wrap : @[Counter.scala 88:20]
        enq_ptr_value <= UInt<1>("h0") @[Counter.scala 88:28]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<2>("h2")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
      when wrap_1 : @[Counter.scala 88:20]
        deq_ptr_value <= UInt<1>("h0") @[Counter.scala 88:28]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = mux(maybe_full, UInt<2>("h3"), UInt<1>("h0")) @[Decoupled.scala 319:10]
    node _io_count_T_1 = gt(deq_ptr_value, enq_ptr_value) @[Decoupled.scala 320:25]
    node _io_count_T_2 = add(UInt<2>("h3"), ptr_diff) @[Decoupled.scala 320:57]
    node _io_count_T_3 = tail(_io_count_T_2, 1) @[Decoupled.scala 320:57]
    node _io_count_T_4 = mux(_io_count_T_1, _io_count_T_3, ptr_diff) @[Decoupled.scala 320:10]
    node _io_count_T_5 = mux(ptr_match, _io_count_T, _io_count_T_4) @[Decoupled.scala 317:20]
    io.count <= _io_count_T_5 @[Decoupled.scala 317:14]

  module Queue_24 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<2>}

    cmem ram : UInt<1> [2] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module DualPortMem_1 :
    input clock : Clock
    input reset : Reset
    output io : { portA : { flip control : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<13>, size : UInt<13>}}, flip input : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, output : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, wrote : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, status : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<13>, size : UInt<13>}}, inputStatus : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, portB : { flip control : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<13>, size : UInt<13>}}, flip input : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, output : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, wrote : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, status : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<13>, size : UInt<13>}}, inputStatus : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, flip tracepoint : UInt<1>, flip programCounter : UInt<32>}

    inst mem of InnerDualPortMem_1 @[DualPortMem.scala 33:19]
    mem.clock <= clock
    mem.reset <= reset
    inst output of Queue_21 @[DualPortMem.scala 48:24]
    output.clock <= clock
    output.reset <= reset
    node outputReady = lt(output.io.count, UInt<2>("h2")) @[DualPortMem.scala 55:39]
    mem.io.portA.address <= io.portA.control.bits.address @[DualPortMem.scala 57:19]
    when io.portA.control.bits.write : @[DualPortMem.scala 59:30]
      io.portA.control.ready <= io.portA.input.valid @[DualPortMem.scala 60:21]
      node _mem_io_portA_write_enable_T = and(io.portA.control.valid, io.portA.input.valid) @[DualPortMem.scala 61:43]
      mem.io.portA.write.enable <= _mem_io_portA_write_enable_T @[DualPortMem.scala 61:26]
      mem.io.portA.read.enable <= UInt<1>("h0") @[DualPortMem.scala 62:25]
    else :
      io.portA.control.ready <= outputReady @[DualPortMem.scala 64:21]
      mem.io.portA.write.enable <= UInt<1>("h0") @[DualPortMem.scala 65:26]
      node _mem_io_portA_read_enable_T = and(io.portA.control.valid, outputReady) @[DualPortMem.scala 66:42]
      mem.io.portA.read.enable <= _mem_io_portA_read_enable_T @[DualPortMem.scala 66:25]
    output.io.enq.bits[0] <= mem.io.portA.read.data[0] @[DualPortMem.scala 69:24]
    output.io.enq.bits[1] <= mem.io.portA.read.data[1] @[DualPortMem.scala 69:24]
    output.io.enq.bits[2] <= mem.io.portA.read.data[2] @[DualPortMem.scala 69:24]
    output.io.enq.bits[3] <= mem.io.portA.read.data[3] @[DualPortMem.scala 69:24]
    output.io.enq.bits[4] <= mem.io.portA.read.data[4] @[DualPortMem.scala 69:24]
    output.io.enq.bits[5] <= mem.io.portA.read.data[5] @[DualPortMem.scala 69:24]
    output.io.enq.bits[6] <= mem.io.portA.read.data[6] @[DualPortMem.scala 69:24]
    output.io.enq.bits[7] <= mem.io.portA.read.data[7] @[DualPortMem.scala 69:24]
    wire _output_io_enq_valid_sr_WIRE : UInt<1>[1] @[package.scala 75:57]
    _output_io_enq_valid_sr_WIRE[0] <= UInt<1>("h0") @[package.scala 75:57]
    reg output_io_enq_valid_sr : UInt<1>[1], clock with :
      reset => (reset, _output_io_enq_valid_sr_WIRE) @[ShiftRegister.scala 10:22]
    output_io_enq_valid_sr[0] <= mem.io.portA.read.enable @[ShiftRegister.scala 25:12]
    output.io.enq.valid <= output_io_enq_valid_sr[0] @[DualPortMem.scala 70:25]
    io.portA.output.bits <= output.io.deq.bits @[DualPortMem.scala 72:17]
    io.portA.output.valid <= output.io.deq.valid @[DualPortMem.scala 72:17]
    output.io.deq.ready <= io.portA.output.ready @[DualPortMem.scala 72:17]
    mem.io.portA.write.data[0] <= io.portA.input.bits[0] @[DualPortMem.scala 74:22]
    mem.io.portA.write.data[1] <= io.portA.input.bits[1] @[DualPortMem.scala 74:22]
    mem.io.portA.write.data[2] <= io.portA.input.bits[2] @[DualPortMem.scala 74:22]
    mem.io.portA.write.data[3] <= io.portA.input.bits[3] @[DualPortMem.scala 74:22]
    mem.io.portA.write.data[4] <= io.portA.input.bits[4] @[DualPortMem.scala 74:22]
    mem.io.portA.write.data[5] <= io.portA.input.bits[5] @[DualPortMem.scala 74:22]
    mem.io.portA.write.data[6] <= io.portA.input.bits[6] @[DualPortMem.scala 74:22]
    mem.io.portA.write.data[7] <= io.portA.input.bits[7] @[DualPortMem.scala 74:22]
    node _io_portA_input_ready_T = and(io.portA.control.valid, io.portA.control.bits.write) @[DualPortMem.scala 75:34]
    io.portA.input.ready <= _io_portA_input_ready_T @[DualPortMem.scala 75:17]
    io.portA.status.bits <= io.portA.control.bits @[DualPortMem.scala 89:22]
    node _io_portA_status_valid_T = and(io.portA.control.valid, io.portA.control.ready) @[DualPortMem.scala 90:40]
    io.portA.status.valid <= _io_portA_status_valid_T @[DualPortMem.scala 90:23]
    io.portA.inputStatus.bits <= io.portA.input.bits @[DualPortMem.scala 92:27]
    node _io_portA_inputStatus_valid_T = and(io.portA.input.valid, io.portA.input.ready) @[DualPortMem.scala 93:43]
    io.portA.inputStatus.valid <= _io_portA_inputStatus_valid_T @[DualPortMem.scala 93:28]
    inst wrote of Queue_22 @[Mem.scala 22:19]
    wrote.clock <= clock
    wrote.reset <= reset
    io.portA.wrote.bits <= wrote.io.deq.bits @[Mem.scala 23:7]
    io.portA.wrote.valid <= wrote.io.deq.valid @[Mem.scala 23:7]
    wrote.io.deq.ready <= io.portA.wrote.ready @[Mem.scala 23:7]
    wrote.io.enq.bits <= UInt<1>("h1") @[DualPortMem.scala 96:16]
    wrote.io.enq.valid <= mem.io.portA.write.enable @[DualPortMem.scala 97:17]
    inst output_1 of Queue_23 @[DualPortMem.scala 48:24]
    output_1.clock <= clock
    output_1.reset <= reset
    node outputReady_1 = lt(output_1.io.count, UInt<2>("h2")) @[DualPortMem.scala 55:39]
    mem.io.portB.address <= io.portB.control.bits.address @[DualPortMem.scala 57:19]
    when io.portB.control.bits.write : @[DualPortMem.scala 59:30]
      io.portB.control.ready <= io.portB.input.valid @[DualPortMem.scala 60:21]
      node _mem_io_portB_write_enable_T = and(io.portB.control.valid, io.portB.input.valid) @[DualPortMem.scala 61:43]
      mem.io.portB.write.enable <= _mem_io_portB_write_enable_T @[DualPortMem.scala 61:26]
      mem.io.portB.read.enable <= UInt<1>("h0") @[DualPortMem.scala 62:25]
    else :
      io.portB.control.ready <= outputReady_1 @[DualPortMem.scala 64:21]
      mem.io.portB.write.enable <= UInt<1>("h0") @[DualPortMem.scala 65:26]
      node _mem_io_portB_read_enable_T = and(io.portB.control.valid, outputReady_1) @[DualPortMem.scala 66:42]
      mem.io.portB.read.enable <= _mem_io_portB_read_enable_T @[DualPortMem.scala 66:25]
    output_1.io.enq.bits[0] <= mem.io.portB.read.data[0] @[DualPortMem.scala 69:24]
    output_1.io.enq.bits[1] <= mem.io.portB.read.data[1] @[DualPortMem.scala 69:24]
    output_1.io.enq.bits[2] <= mem.io.portB.read.data[2] @[DualPortMem.scala 69:24]
    output_1.io.enq.bits[3] <= mem.io.portB.read.data[3] @[DualPortMem.scala 69:24]
    output_1.io.enq.bits[4] <= mem.io.portB.read.data[4] @[DualPortMem.scala 69:24]
    output_1.io.enq.bits[5] <= mem.io.portB.read.data[5] @[DualPortMem.scala 69:24]
    output_1.io.enq.bits[6] <= mem.io.portB.read.data[6] @[DualPortMem.scala 69:24]
    output_1.io.enq.bits[7] <= mem.io.portB.read.data[7] @[DualPortMem.scala 69:24]
    wire _output_io_enq_valid_sr_WIRE_1 : UInt<1>[1] @[package.scala 75:57]
    _output_io_enq_valid_sr_WIRE_1[0] <= UInt<1>("h0") @[package.scala 75:57]
    reg output_io_enq_valid_sr_1 : UInt<1>[1], clock with :
      reset => (reset, _output_io_enq_valid_sr_WIRE_1) @[ShiftRegister.scala 10:22]
    output_io_enq_valid_sr_1[0] <= mem.io.portB.read.enable @[ShiftRegister.scala 25:12]
    output_1.io.enq.valid <= output_io_enq_valid_sr_1[0] @[DualPortMem.scala 70:25]
    io.portB.output.bits <= output_1.io.deq.bits @[DualPortMem.scala 72:17]
    io.portB.output.valid <= output_1.io.deq.valid @[DualPortMem.scala 72:17]
    output_1.io.deq.ready <= io.portB.output.ready @[DualPortMem.scala 72:17]
    mem.io.portB.write.data[0] <= io.portB.input.bits[0] @[DualPortMem.scala 74:22]
    mem.io.portB.write.data[1] <= io.portB.input.bits[1] @[DualPortMem.scala 74:22]
    mem.io.portB.write.data[2] <= io.portB.input.bits[2] @[DualPortMem.scala 74:22]
    mem.io.portB.write.data[3] <= io.portB.input.bits[3] @[DualPortMem.scala 74:22]
    mem.io.portB.write.data[4] <= io.portB.input.bits[4] @[DualPortMem.scala 74:22]
    mem.io.portB.write.data[5] <= io.portB.input.bits[5] @[DualPortMem.scala 74:22]
    mem.io.portB.write.data[6] <= io.portB.input.bits[6] @[DualPortMem.scala 74:22]
    mem.io.portB.write.data[7] <= io.portB.input.bits[7] @[DualPortMem.scala 74:22]
    node _io_portB_input_ready_T = and(io.portB.control.valid, io.portB.control.bits.write) @[DualPortMem.scala 75:34]
    io.portB.input.ready <= _io_portB_input_ready_T @[DualPortMem.scala 75:17]
    io.portB.status.bits <= io.portB.control.bits @[DualPortMem.scala 89:22]
    node _io_portB_status_valid_T = and(io.portB.control.valid, io.portB.control.ready) @[DualPortMem.scala 90:40]
    io.portB.status.valid <= _io_portB_status_valid_T @[DualPortMem.scala 90:23]
    io.portB.inputStatus.bits <= io.portB.input.bits @[DualPortMem.scala 92:27]
    node _io_portB_inputStatus_valid_T = and(io.portB.input.valid, io.portB.input.ready) @[DualPortMem.scala 93:43]
    io.portB.inputStatus.valid <= _io_portB_inputStatus_valid_T @[DualPortMem.scala 93:28]
    inst wrote_1 of Queue_24 @[Mem.scala 22:19]
    wrote_1.clock <= clock
    wrote_1.reset <= reset
    io.portB.wrote.bits <= wrote_1.io.deq.bits @[Mem.scala 23:7]
    io.portB.wrote.valid <= wrote_1.io.deq.valid @[Mem.scala 23:7]
    wrote_1.io.deq.ready <= io.portB.wrote.ready @[Mem.scala 23:7]
    wrote_1.io.enq.bits <= UInt<1>("h1") @[DualPortMem.scala 96:16]
    wrote_1.io.enq.valid <= mem.io.portB.write.enable @[DualPortMem.scala 97:17]

  module Demux_3 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip sel : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<2>}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[3]}

    wire _io_out_0_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 75:57]
    node _io_out_0_bits_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[0] <= _io_out_0_bits_T @[package.scala 75:57]
    node _io_out_0_bits_T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[1] <= _io_out_0_bits_T_1 @[package.scala 75:57]
    node _io_out_0_bits_T_2 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[2] <= _io_out_0_bits_T_2 @[package.scala 75:57]
    node _io_out_0_bits_T_3 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[3] <= _io_out_0_bits_T_3 @[package.scala 75:57]
    node _io_out_0_bits_T_4 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[4] <= _io_out_0_bits_T_4 @[package.scala 75:57]
    node _io_out_0_bits_T_5 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[5] <= _io_out_0_bits_T_5 @[package.scala 75:57]
    node _io_out_0_bits_T_6 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[6] <= _io_out_0_bits_T_6 @[package.scala 75:57]
    node _io_out_0_bits_T_7 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[7] <= _io_out_0_bits_T_7 @[package.scala 75:57]
    io.out[0].bits <= _io_out_0_bits_WIRE @[Demux.scala 27:14]
    io.out[0].valid <= UInt<1>("h0") @[Demux.scala 28:15]
    wire _io_out_1_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 75:57]
    node _io_out_1_bits_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[0] <= _io_out_1_bits_T @[package.scala 75:57]
    node _io_out_1_bits_T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[1] <= _io_out_1_bits_T_1 @[package.scala 75:57]
    node _io_out_1_bits_T_2 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[2] <= _io_out_1_bits_T_2 @[package.scala 75:57]
    node _io_out_1_bits_T_3 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[3] <= _io_out_1_bits_T_3 @[package.scala 75:57]
    node _io_out_1_bits_T_4 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[4] <= _io_out_1_bits_T_4 @[package.scala 75:57]
    node _io_out_1_bits_T_5 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[5] <= _io_out_1_bits_T_5 @[package.scala 75:57]
    node _io_out_1_bits_T_6 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[6] <= _io_out_1_bits_T_6 @[package.scala 75:57]
    node _io_out_1_bits_T_7 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[7] <= _io_out_1_bits_T_7 @[package.scala 75:57]
    io.out[1].bits <= _io_out_1_bits_WIRE @[Demux.scala 27:14]
    io.out[1].valid <= UInt<1>("h0") @[Demux.scala 28:15]
    wire _io_out_2_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 75:57]
    node _io_out_2_bits_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_2_bits_WIRE[0] <= _io_out_2_bits_T @[package.scala 75:57]
    node _io_out_2_bits_T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_2_bits_WIRE[1] <= _io_out_2_bits_T_1 @[package.scala 75:57]
    node _io_out_2_bits_T_2 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_2_bits_WIRE[2] <= _io_out_2_bits_T_2 @[package.scala 75:57]
    node _io_out_2_bits_T_3 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_2_bits_WIRE[3] <= _io_out_2_bits_T_3 @[package.scala 75:57]
    node _io_out_2_bits_T_4 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_2_bits_WIRE[4] <= _io_out_2_bits_T_4 @[package.scala 75:57]
    node _io_out_2_bits_T_5 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_2_bits_WIRE[5] <= _io_out_2_bits_T_5 @[package.scala 75:57]
    node _io_out_2_bits_T_6 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_2_bits_WIRE[6] <= _io_out_2_bits_T_6 @[package.scala 75:57]
    node _io_out_2_bits_T_7 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_2_bits_WIRE[7] <= _io_out_2_bits_T_7 @[package.scala 75:57]
    io.out[2].bits <= _io_out_2_bits_WIRE @[Demux.scala 27:14]
    io.out[2].valid <= UInt<1>("h0") @[Demux.scala 28:15]
    io.out[io.sel.bits].bits <= io.in.bits @[Demux.scala 32:12]
    node _io_out_valid_T = and(io.sel.valid, io.in.valid) @[Demux.scala 33:26]
    io.out[io.sel.bits].valid <= _io_out_valid_T @[Demux.scala 33:13]
    node _io_sel_ready_T = and(io.in.valid, io.out[io.sel.bits].ready) @[Demux.scala 34:25]
    io.sel.ready <= _io_sel_ready_T @[Demux.scala 34:13]
    node _io_in_ready_T = and(io.sel.valid, io.out[io.sel.bits].ready) @[Demux.scala 35:25]
    io.in.ready <= _io_in_ready_T @[Demux.scala 35:12]

  module Mux_2 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2], flip sel : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}

    wire in : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2] @[Mux.scala 47:19]
    in[0] <= io.in[0] @[Mux.scala 47:19]
    in[1] <= io.in[1] @[Mux.scala 47:19]
    in[UInt<1>("h0")].ready <= UInt<1>("h0") @[Mux.scala 52:19]
    in[UInt<1>("h1")].ready <= UInt<1>("h0") @[Mux.scala 52:19]
    io.out.bits <= in[io.sel.bits].bits @[Mux.scala 57:15]
    node _io_out_valid_T = and(io.sel.valid, in[io.sel.bits].valid) @[Mux.scala 58:29]
    io.out.valid <= _io_out_valid_T @[Mux.scala 58:16]
    node _io_sel_ready_T = and(in[io.sel.bits].valid, io.out.ready) @[Mux.scala 59:26]
    io.sel.ready <= _io_sel_ready_T @[Mux.scala 59:13]
    node _in_ready_T = and(io.sel.valid, io.out.ready) @[Mux.scala 60:26]
    in[io.sel.bits].ready <= _in_ready_T @[Mux.scala 60:13]

  module Mux_3 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2], flip sel : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}

    wire in : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2] @[Mux.scala 47:19]
    in[0] <= io.in[0] @[Mux.scala 47:19]
    in[1] <= io.in[1] @[Mux.scala 47:19]
    in[UInt<1>("h0")].ready <= UInt<1>("h0") @[Mux.scala 52:19]
    in[UInt<1>("h1")].ready <= UInt<1>("h0") @[Mux.scala 52:19]
    io.out.bits <= in[io.sel.bits].bits @[Mux.scala 57:15]
    node _io_out_valid_T = and(io.sel.valid, in[io.sel.bits].valid) @[Mux.scala 58:29]
    io.out.valid <= _io_out_valid_T @[Mux.scala 58:16]
    node _io_sel_ready_T = and(in[io.sel.bits].valid, io.out.ready) @[Mux.scala 59:26]
    io.sel.ready <= _io_sel_ready_T @[Mux.scala 59:13]
    node _in_ready_T = and(io.sel.valid, io.out.ready) @[Mux.scala 60:26]
    in[io.sel.bits].ready <= _in_ready_T @[Mux.scala 60:13]

  module Counter_7 :
    input clock : Clock
    input reset : Reset
    output io : { value : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<13>}, flip resetValue : UInt<1>}

    reg value : UInt<13>, clock with :
      reset => (reset, UInt<13>("h0")) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h0")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<13>("h1fff")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h0") @[Counter.scala 22:13]
      else :
        node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h0") @[Counter.scala 28:11]

  module SizeHandler_2 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : { sel : UInt<2>, size : UInt<13>}}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : { sel : UInt<2>}}}

    inst sizeCounter of Counter_7 @[Counter.scala 34:19]
    sizeCounter.clock <= clock
    sizeCounter.reset <= reset
    sizeCounter.io.resetValue <= UInt<1>("h0") @[Counter.scala 35:21]
    sizeCounter.io.value.ready <= UInt<1>("h0") @[Counter.scala 36:22]
    io.out.valid <= io.in.valid @[SizeHandler.scala 25:16]
    io.out.bits.sel <= io.in.bits.sel @[SizeHandler.scala 28:34]
    node fire = and(io.in.valid, io.out.ready) @[SizeHandler.scala 32:23]
    node _T = eq(sizeCounter.io.value.bits, io.in.bits.size) @[SizeHandler.scala 34:34]
    when _T : @[SizeHandler.scala 34:52]
      io.in.ready <= io.out.ready @[SizeHandler.scala 35:14]
      sizeCounter.io.resetValue <= fire @[SizeHandler.scala 36:31]
    else :
      io.in.ready <= UInt<1>("h0") @[SizeHandler.scala 38:14]
      sizeCounter.io.value.ready <= fire @[SizeHandler.scala 39:32]

  module Queue_25 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { sel : UInt<2>, size : UInt<13>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { sel : UInt<2>, size : UInt<13>}}, count : UInt<1>}

    cmem ram : { sel : UInt<2>, size : UInt<13>} [1] @[Decoupled.scala 259:95]
    wire enq_ptr_value : UInt
    enq_ptr_value <= UInt<1>("h0")
    wire deq_ptr_value : UInt
    deq_ptr_value <= UInt<1>("h0")
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[UInt<1>("h0")], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
    when do_deq : @[Decoupled.scala 276:16]
      skip
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[UInt<1>("h0")], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    when io.deq.ready : @[Decoupled.scala 309:24]
      io.enq.ready <= UInt<1>("h1") @[Decoupled.scala 309:39]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<1>("h1"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Counter_8 :
    input clock : Clock
    input reset : Reset
    output io : { value : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<13>}, flip resetValue : UInt<1>}

    reg value : UInt<13>, clock with :
      reset => (reset, UInt<13>("h0")) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h0")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<13>("h1fff")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h0") @[Counter.scala 22:13]
      else :
        node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h0") @[Counter.scala 28:11]

  module SizeHandler_3 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : { sel : UInt<1>, size : UInt<13>}}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : { sel : UInt<1>}}}

    inst sizeCounter of Counter_8 @[Counter.scala 34:19]
    sizeCounter.clock <= clock
    sizeCounter.reset <= reset
    sizeCounter.io.resetValue <= UInt<1>("h0") @[Counter.scala 35:21]
    sizeCounter.io.value.ready <= UInt<1>("h0") @[Counter.scala 36:22]
    io.out.valid <= io.in.valid @[SizeHandler.scala 25:16]
    io.out.bits.sel <= io.in.bits.sel @[SizeHandler.scala 28:34]
    node fire = and(io.in.valid, io.out.ready) @[SizeHandler.scala 32:23]
    node _T = eq(sizeCounter.io.value.bits, io.in.bits.size) @[SizeHandler.scala 34:34]
    when _T : @[SizeHandler.scala 34:52]
      io.in.ready <= io.out.ready @[SizeHandler.scala 35:14]
      sizeCounter.io.resetValue <= fire @[SizeHandler.scala 36:31]
    else :
      io.in.ready <= UInt<1>("h0") @[SizeHandler.scala 38:14]
      sizeCounter.io.value.ready <= fire @[SizeHandler.scala 39:32]

  module Queue_26 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { sel : UInt<1>, size : UInt<13>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { sel : UInt<1>, size : UInt<13>}}, count : UInt<1>}

    cmem ram : { sel : UInt<1>, size : UInt<13>} [1] @[Decoupled.scala 259:95]
    wire enq_ptr_value : UInt
    enq_ptr_value <= UInt<1>("h0")
    wire deq_ptr_value : UInt
    deq_ptr_value <= UInt<1>("h0")
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[UInt<1>("h0")], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
    when do_deq : @[Decoupled.scala 276:16]
      skip
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[UInt<1>("h0")], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    when io.deq.ready : @[Decoupled.scala 309:24]
      io.enq.ready <= UInt<1>("h1") @[Decoupled.scala 309:39]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<1>("h1"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Counter_9 :
    input clock : Clock
    input reset : Reset
    output io : { value : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<13>}, flip resetValue : UInt<1>}

    reg value : UInt<13>, clock with :
      reset => (reset, UInt<13>("h0")) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h0")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<13>("h1fff")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h0") @[Counter.scala 22:13]
      else :
        node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h0") @[Counter.scala 28:11]

  module SizeHandler_4 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : { sel : UInt<1>, size : UInt<13>}}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : { sel : UInt<1>}}}

    inst sizeCounter of Counter_9 @[Counter.scala 34:19]
    sizeCounter.clock <= clock
    sizeCounter.reset <= reset
    sizeCounter.io.resetValue <= UInt<1>("h0") @[Counter.scala 35:21]
    sizeCounter.io.value.ready <= UInt<1>("h0") @[Counter.scala 36:22]
    io.out.valid <= io.in.valid @[SizeHandler.scala 25:16]
    io.out.bits.sel <= io.in.bits.sel @[SizeHandler.scala 28:34]
    node fire = and(io.in.valid, io.out.ready) @[SizeHandler.scala 32:23]
    node _T = eq(sizeCounter.io.value.bits, io.in.bits.size) @[SizeHandler.scala 34:34]
    when _T : @[SizeHandler.scala 34:52]
      io.in.ready <= io.out.ready @[SizeHandler.scala 35:14]
      sizeCounter.io.resetValue <= fire @[SizeHandler.scala 36:31]
    else :
      io.in.ready <= UInt<1>("h0") @[SizeHandler.scala 38:14]
      sizeCounter.io.value.ready <= fire @[SizeHandler.scala 39:32]

  module Queue_27 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { sel : UInt<1>, size : UInt<13>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { sel : UInt<1>, size : UInt<13>}}, count : UInt<5>}

    cmem ram : { sel : UInt<1>, size : UInt<13>} [16] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<4>, clock with :
      reset => (reset, UInt<4>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<4>, clock with :
      reset => (reset, UInt<4>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<4>("hf")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<4>("hf")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    when io.deq.ready : @[Decoupled.scala 309:24]
      io.enq.ready <= UInt<1>("h1") @[Decoupled.scala 309:39]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<5>("h10"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module MultiEnqueue_15 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>}[1]}

    reg enq_0 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    node allEnqueued = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]

  module MultiEnqueue_16 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>}[2]}

    reg enq_0 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node allEnqueued = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_1 = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]

  module LocalRouter :
    input clock : Clock
    input reset : Reset
    output io : { flip control : { flip ready : UInt<1>, valid : UInt<1>, bits : { kind : UInt<4>, size : UInt<13>}}, mem : { flip output : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, input : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, array : { input : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip output : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, weightInput : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, acc : { flip output : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, input : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, flip timeout : UInt<1>, flip tracepoint : UInt<1>, flip programCounter : UInt<32>}

    inst memReadDataDemuxModule of Demux_3 @[LocalRouter.scala 55:38]
    memReadDataDemuxModule.clock <= clock
    memReadDataDemuxModule.reset <= reset
    memReadDataDemuxModule.io.in <= io.mem.output @[LocalRouter.scala 62:32]
    io.array.weightInput.bits <= memReadDataDemuxModule.io.out[0].bits @[LocalRouter.scala 63:24]
    io.array.weightInput.valid <= memReadDataDemuxModule.io.out[0].valid @[LocalRouter.scala 63:24]
    memReadDataDemuxModule.io.out[0].ready <= io.array.weightInput.ready @[LocalRouter.scala 63:24]
    io.array.input.bits <= memReadDataDemuxModule.io.out[1].bits @[LocalRouter.scala 64:18]
    io.array.input.valid <= memReadDataDemuxModule.io.out[1].valid @[LocalRouter.scala 64:18]
    memReadDataDemuxModule.io.out[1].ready <= io.array.input.ready @[LocalRouter.scala 64:18]
    inst memWriteDataMuxModule of Mux_2 @[LocalRouter.scala 66:37]
    memWriteDataMuxModule.clock <= clock
    memWriteDataMuxModule.reset <= reset
    wire _memWriteDataMuxModule_io_in_0_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 75:57]
    node _memWriteDataMuxModule_io_in_0_bits_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _memWriteDataMuxModule_io_in_0_bits_WIRE[0] <= _memWriteDataMuxModule_io_in_0_bits_T @[package.scala 75:57]
    node _memWriteDataMuxModule_io_in_0_bits_T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _memWriteDataMuxModule_io_in_0_bits_WIRE[1] <= _memWriteDataMuxModule_io_in_0_bits_T_1 @[package.scala 75:57]
    node _memWriteDataMuxModule_io_in_0_bits_T_2 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _memWriteDataMuxModule_io_in_0_bits_WIRE[2] <= _memWriteDataMuxModule_io_in_0_bits_T_2 @[package.scala 75:57]
    node _memWriteDataMuxModule_io_in_0_bits_T_3 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _memWriteDataMuxModule_io_in_0_bits_WIRE[3] <= _memWriteDataMuxModule_io_in_0_bits_T_3 @[package.scala 75:57]
    node _memWriteDataMuxModule_io_in_0_bits_T_4 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _memWriteDataMuxModule_io_in_0_bits_WIRE[4] <= _memWriteDataMuxModule_io_in_0_bits_T_4 @[package.scala 75:57]
    node _memWriteDataMuxModule_io_in_0_bits_T_5 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _memWriteDataMuxModule_io_in_0_bits_WIRE[5] <= _memWriteDataMuxModule_io_in_0_bits_T_5 @[package.scala 75:57]
    node _memWriteDataMuxModule_io_in_0_bits_T_6 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _memWriteDataMuxModule_io_in_0_bits_WIRE[6] <= _memWriteDataMuxModule_io_in_0_bits_T_6 @[package.scala 75:57]
    node _memWriteDataMuxModule_io_in_0_bits_T_7 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _memWriteDataMuxModule_io_in_0_bits_WIRE[7] <= _memWriteDataMuxModule_io_in_0_bits_T_7 @[package.scala 75:57]
    memWriteDataMuxModule.io.in[0].bits[0] <= _memWriteDataMuxModule_io_in_0_bits_WIRE[0] @[package.scala 404:14]
    memWriteDataMuxModule.io.in[0].bits[1] <= _memWriteDataMuxModule_io_in_0_bits_WIRE[1] @[package.scala 404:14]
    memWriteDataMuxModule.io.in[0].bits[2] <= _memWriteDataMuxModule_io_in_0_bits_WIRE[2] @[package.scala 404:14]
    memWriteDataMuxModule.io.in[0].bits[3] <= _memWriteDataMuxModule_io_in_0_bits_WIRE[3] @[package.scala 404:14]
    memWriteDataMuxModule.io.in[0].bits[4] <= _memWriteDataMuxModule_io_in_0_bits_WIRE[4] @[package.scala 404:14]
    memWriteDataMuxModule.io.in[0].bits[5] <= _memWriteDataMuxModule_io_in_0_bits_WIRE[5] @[package.scala 404:14]
    memWriteDataMuxModule.io.in[0].bits[6] <= _memWriteDataMuxModule_io_in_0_bits_WIRE[6] @[package.scala 404:14]
    memWriteDataMuxModule.io.in[0].bits[7] <= _memWriteDataMuxModule_io_in_0_bits_WIRE[7] @[package.scala 404:14]
    memWriteDataMuxModule.io.in[0].valid <= UInt<1>("h0") @[package.scala 405:15]
    memWriteDataMuxModule.io.in[1] <= io.acc.output @[LocalRouter.scala 74:34]
    io.mem.input.bits <= memWriteDataMuxModule.io.out.bits @[LocalRouter.scala 75:16]
    io.mem.input.valid <= memWriteDataMuxModule.io.out.valid @[LocalRouter.scala 75:16]
    memWriteDataMuxModule.io.out.ready <= io.mem.input.ready @[LocalRouter.scala 75:16]
    inst accWriteDataMuxModule of Mux_3 @[LocalRouter.scala 77:37]
    accWriteDataMuxModule.clock <= clock
    accWriteDataMuxModule.reset <= reset
    accWriteDataMuxModule.io.in[0] <= io.array.output @[LocalRouter.scala 84:34]
    accWriteDataMuxModule.io.in[1] <= memReadDataDemuxModule.io.out[2] @[LocalRouter.scala 85:34]
    io.acc.input.bits <= accWriteDataMuxModule.io.out.bits @[LocalRouter.scala 86:16]
    io.acc.input.valid <= accWriteDataMuxModule.io.out.valid @[LocalRouter.scala 86:16]
    accWriteDataMuxModule.io.out.ready <= io.acc.input.ready @[LocalRouter.scala 86:16]
    inst sizeHandler of SizeHandler_2 @[package.scala 33:29]
    sizeHandler.clock <= clock
    sizeHandler.reset <= reset
    inst memReadDataDemux of Queue_25 @[Mem.scala 22:19]
    memReadDataDemux.clock <= clock
    memReadDataDemux.reset <= reset
    sizeHandler.io.in <= memReadDataDemux.io.deq @[Mem.scala 23:7]
    memReadDataDemuxModule.io.sel.bits <= sizeHandler.io.out.bits.sel @[package.scala 38:17]
    memReadDataDemuxModule.io.sel.valid <= sizeHandler.io.out.valid @[package.scala 39:18]
    sizeHandler.io.out.ready <= memReadDataDemuxModule.io.sel.ready @[package.scala 40:30]
    inst sizeHandler_1 of SizeHandler_3 @[package.scala 33:29]
    sizeHandler_1.clock <= clock
    sizeHandler_1.reset <= reset
    inst memWriteDataMux of Queue_26 @[Mem.scala 22:19]
    memWriteDataMux.clock <= clock
    memWriteDataMux.reset <= reset
    sizeHandler_1.io.in <= memWriteDataMux.io.deq @[Mem.scala 23:7]
    memWriteDataMuxModule.io.sel.bits <= sizeHandler_1.io.out.bits.sel @[package.scala 38:17]
    memWriteDataMuxModule.io.sel.valid <= sizeHandler_1.io.out.valid @[package.scala 39:18]
    sizeHandler_1.io.out.ready <= memWriteDataMuxModule.io.sel.ready @[package.scala 40:30]
    inst sizeHandler_2 of SizeHandler_4 @[package.scala 33:29]
    sizeHandler_2.clock <= clock
    sizeHandler_2.reset <= reset
    inst accWriteDataMux of Queue_27 @[Mem.scala 22:19]
    accWriteDataMux.clock <= clock
    accWriteDataMux.reset <= reset
    sizeHandler_2.io.in <= accWriteDataMux.io.deq @[Mem.scala 23:7]
    accWriteDataMuxModule.io.sel.bits <= sizeHandler_2.io.out.bits.sel @[package.scala 38:17]
    accWriteDataMuxModule.io.sel.valid <= sizeHandler_2.io.out.valid @[package.scala 39:18]
    sizeHandler_2.io.out.ready <= accWriteDataMuxModule.io.sel.ready @[package.scala 40:30]
    wire _memReadDataDemux_io_enq_bits_WIRE : { sel : UInt<2>, size : UInt<13>} @[package.scala 75:57]
    _memReadDataDemux_io_enq_bits_WIRE.size <= UInt<13>("h0") @[package.scala 75:57]
    _memReadDataDemux_io_enq_bits_WIRE.sel <= UInt<2>("h0") @[package.scala 75:57]
    memReadDataDemux.io.enq.bits.size <= _memReadDataDemux_io_enq_bits_WIRE.size @[package.scala 404:14]
    memReadDataDemux.io.enq.bits.sel <= _memReadDataDemux_io_enq_bits_WIRE.sel @[package.scala 404:14]
    memReadDataDemux.io.enq.valid <= UInt<1>("h0") @[package.scala 405:15]
    wire _memWriteDataMux_io_enq_bits_WIRE : { sel : UInt<1>, size : UInt<13>} @[package.scala 75:57]
    _memWriteDataMux_io_enq_bits_WIRE.size <= UInt<13>("h0") @[package.scala 75:57]
    _memWriteDataMux_io_enq_bits_WIRE.sel <= UInt<1>("h0") @[package.scala 75:57]
    memWriteDataMux.io.enq.bits.size <= _memWriteDataMux_io_enq_bits_WIRE.size @[package.scala 404:14]
    memWriteDataMux.io.enq.bits.sel <= _memWriteDataMux_io_enq_bits_WIRE.sel @[package.scala 404:14]
    memWriteDataMux.io.enq.valid <= UInt<1>("h0") @[package.scala 405:15]
    wire _accWriteDataMux_io_enq_bits_WIRE : { sel : UInt<1>, size : UInt<13>} @[package.scala 75:57]
    _accWriteDataMux_io_enq_bits_WIRE.size <= UInt<13>("h0") @[package.scala 75:57]
    _accWriteDataMux_io_enq_bits_WIRE.sel <= UInt<1>("h0") @[package.scala 75:57]
    accWriteDataMux.io.enq.bits.size <= _accWriteDataMux_io_enq_bits_WIRE.size @[package.scala 404:14]
    accWriteDataMux.io.enq.bits.sel <= _accWriteDataMux_io_enq_bits_WIRE.sel @[package.scala 404:14]
    accWriteDataMux.io.enq.valid <= UInt<1>("h0") @[package.scala 405:15]
    inst enqueuer1 of MultiEnqueue_15 @[MultiEnqueue.scala 182:43]
    enqueuer1.clock <= clock
    enqueuer1.reset <= reset
    inst enqueuer2 of MultiEnqueue_16 @[MultiEnqueue.scala 182:43]
    enqueuer2.clock <= clock
    enqueuer2.reset <= reset
    enqueuer1.io.in.valid <= UInt<1>("h0") @[MultiEnqueue.scala 40:17]
    enqueuer1.io.out[0].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    enqueuer2.io.in.valid <= UInt<1>("h0") @[MultiEnqueue.scala 40:17]
    enqueuer2.io.out[0].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    enqueuer2.io.out[1].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    node _T = eq(io.control.bits.kind, UInt<1>("h1")) @[LocalRouter.scala 123:26]
    when _T : @[LocalRouter.scala 123:72]
      wire io_control_ready_w : { sel : UInt<2>, size : UInt<13>} @[Mux.scala 20:19]
      io_control_ready_w.sel <= UInt<1>("h0") @[Mux.scala 21:13]
      io_control_ready_w.size <= io.control.bits.size @[Mux.scala 22:14]
      enqueuer1.io.in.valid <= io.control.valid @[MultiEnqueue.scala 60:17]
      wire io_control_ready_memReadDataDemux_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { sel : UInt<2>, size : UInt<13>}} @[ReadyValid.scala 16:17]
      io_control_ready_memReadDataDemux_io_enq_w.bits <= io_control_ready_w @[ReadyValid.scala 17:12]
      io_control_ready_memReadDataDemux_io_enq_w.valid <= enqueuer1.io.out[0].valid @[ReadyValid.scala 18:13]
      enqueuer1.io.out[0].ready <= io_control_ready_memReadDataDemux_io_enq_w.ready @[ReadyValid.scala 19:11]
      memReadDataDemux.io.enq <= io_control_ready_memReadDataDemux_io_enq_w @[MultiEnqueue.scala 61:10]
      io.control.ready <= enqueuer1.io.in.ready @[LocalRouter.scala 124:19]
    else :
      node _T_1 = eq(io.control.bits.kind, UInt<2>("h2")) @[LocalRouter.scala 129:32]
      when _T_1 : @[LocalRouter.scala 129:78]
        wire io_control_ready_w_1 : { sel : UInt<2>, size : UInt<13>} @[Mux.scala 20:19]
        io_control_ready_w_1.sel <= UInt<1>("h1") @[Mux.scala 21:13]
        io_control_ready_w_1.size <= io.control.bits.size @[Mux.scala 22:14]
        wire io_control_ready_w_2 : { sel : UInt<1>, size : UInt<13>} @[Mux.scala 20:19]
        io_control_ready_w_2.sel <= UInt<1>("h0") @[Mux.scala 21:13]
        io_control_ready_w_2.size <= io.control.bits.size @[Mux.scala 22:14]
        enqueuer2.io.in.valid <= io.control.valid @[MultiEnqueue.scala 84:17]
        wire io_control_ready_memReadDataDemux_io_enq_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : { sel : UInt<2>, size : UInt<13>}} @[ReadyValid.scala 16:17]
        io_control_ready_memReadDataDemux_io_enq_w_1.bits <= io_control_ready_w_1 @[ReadyValid.scala 17:12]
        io_control_ready_memReadDataDemux_io_enq_w_1.valid <= enqueuer2.io.out[0].valid @[ReadyValid.scala 18:13]
        enqueuer2.io.out[0].ready <= io_control_ready_memReadDataDemux_io_enq_w_1.ready @[ReadyValid.scala 19:11]
        memReadDataDemux.io.enq <= io_control_ready_memReadDataDemux_io_enq_w_1 @[MultiEnqueue.scala 85:10]
        wire io_control_ready_accWriteDataMux_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { sel : UInt<1>, size : UInt<13>}} @[ReadyValid.scala 16:17]
        io_control_ready_accWriteDataMux_io_enq_w.bits <= io_control_ready_w_2 @[ReadyValid.scala 17:12]
        io_control_ready_accWriteDataMux_io_enq_w.valid <= enqueuer2.io.out[1].valid @[ReadyValid.scala 18:13]
        enqueuer2.io.out[1].ready <= io_control_ready_accWriteDataMux_io_enq_w.ready @[ReadyValid.scala 19:11]
        accWriteDataMux.io.enq <= io_control_ready_accWriteDataMux_io_enq_w @[MultiEnqueue.scala 86:10]
        io.control.ready <= enqueuer2.io.in.ready @[LocalRouter.scala 130:19]
      else :
        node _T_2 = eq(io.control.bits.kind, UInt<2>("h3")) @[LocalRouter.scala 137:32]
        when _T_2 : @[LocalRouter.scala 137:70]
          wire io_control_ready_w_3 : { sel : UInt<1>, size : UInt<13>} @[Mux.scala 20:19]
          io_control_ready_w_3.sel <= UInt<1>("h0") @[Mux.scala 21:13]
          io_control_ready_w_3.size <= io.control.bits.size @[Mux.scala 22:14]
          enqueuer1.io.in.valid <= io.control.valid @[MultiEnqueue.scala 60:17]
          wire io_control_ready_accWriteDataMux_io_enq_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : { sel : UInt<1>, size : UInt<13>}} @[ReadyValid.scala 16:17]
          io_control_ready_accWriteDataMux_io_enq_w_1.bits <= io_control_ready_w_3 @[ReadyValid.scala 17:12]
          io_control_ready_accWriteDataMux_io_enq_w_1.valid <= enqueuer1.io.out[0].valid @[ReadyValid.scala 18:13]
          enqueuer1.io.out[0].ready <= io_control_ready_accWriteDataMux_io_enq_w_1.ready @[ReadyValid.scala 19:11]
          accWriteDataMux.io.enq <= io_control_ready_accWriteDataMux_io_enq_w_1 @[MultiEnqueue.scala 61:10]
          io.control.ready <= enqueuer1.io.in.ready @[LocalRouter.scala 138:19]
        else :
          node _T_3 = eq(io.control.bits.kind, UInt<3>("h4")) @[LocalRouter.scala 143:32]
          when _T_3 : @[LocalRouter.scala 143:78]
            wire io_control_ready_w_4 : { sel : UInt<1>, size : UInt<13>} @[Mux.scala 20:19]
            io_control_ready_w_4.sel <= UInt<1>("h1") @[Mux.scala 21:13]
            io_control_ready_w_4.size <= io.control.bits.size @[Mux.scala 22:14]
            enqueuer1.io.in.valid <= io.control.valid @[MultiEnqueue.scala 60:17]
            wire io_control_ready_memWriteDataMux_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { sel : UInt<1>, size : UInt<13>}} @[ReadyValid.scala 16:17]
            io_control_ready_memWriteDataMux_io_enq_w.bits <= io_control_ready_w_4 @[ReadyValid.scala 17:12]
            io_control_ready_memWriteDataMux_io_enq_w.valid <= enqueuer1.io.out[0].valid @[ReadyValid.scala 18:13]
            enqueuer1.io.out[0].ready <= io_control_ready_memWriteDataMux_io_enq_w.ready @[ReadyValid.scala 19:11]
            memWriteDataMux.io.enq <= io_control_ready_memWriteDataMux_io_enq_w @[MultiEnqueue.scala 61:10]
            io.control.ready <= enqueuer1.io.in.ready @[LocalRouter.scala 144:19]
          else :
            node _T_4 = eq(io.control.bits.kind, UInt<3>("h5")) @[LocalRouter.scala 150:23]
            when _T_4 : @[LocalRouter.scala 151:5]
              wire io_control_ready_w_5 : { sel : UInt<2>, size : UInt<13>} @[Mux.scala 20:19]
              io_control_ready_w_5.sel <= UInt<2>("h2") @[Mux.scala 21:13]
              io_control_ready_w_5.size <= io.control.bits.size @[Mux.scala 22:14]
              wire io_control_ready_w_6 : { sel : UInt<1>, size : UInt<13>} @[Mux.scala 20:19]
              io_control_ready_w_6.sel <= UInt<1>("h1") @[Mux.scala 21:13]
              io_control_ready_w_6.size <= io.control.bits.size @[Mux.scala 22:14]
              enqueuer2.io.in.valid <= io.control.valid @[MultiEnqueue.scala 84:17]
              wire io_control_ready_memReadDataDemux_io_enq_w_2 : { flip ready : UInt<1>, valid : UInt<1>, bits : { sel : UInt<2>, size : UInt<13>}} @[ReadyValid.scala 16:17]
              io_control_ready_memReadDataDemux_io_enq_w_2.bits <= io_control_ready_w_5 @[ReadyValid.scala 17:12]
              io_control_ready_memReadDataDemux_io_enq_w_2.valid <= enqueuer2.io.out[0].valid @[ReadyValid.scala 18:13]
              enqueuer2.io.out[0].ready <= io_control_ready_memReadDataDemux_io_enq_w_2.ready @[ReadyValid.scala 19:11]
              memReadDataDemux.io.enq <= io_control_ready_memReadDataDemux_io_enq_w_2 @[MultiEnqueue.scala 85:10]
              wire io_control_ready_accWriteDataMux_io_enq_w_2 : { flip ready : UInt<1>, valid : UInt<1>, bits : { sel : UInt<1>, size : UInt<13>}} @[ReadyValid.scala 16:17]
              io_control_ready_accWriteDataMux_io_enq_w_2.bits <= io_control_ready_w_6 @[ReadyValid.scala 17:12]
              io_control_ready_accWriteDataMux_io_enq_w_2.valid <= enqueuer2.io.out[1].valid @[ReadyValid.scala 18:13]
              enqueuer2.io.out[1].ready <= io_control_ready_accWriteDataMux_io_enq_w_2.ready @[ReadyValid.scala 19:11]
              accWriteDataMux.io.enq <= io_control_ready_accWriteDataMux_io_enq_w_2 @[MultiEnqueue.scala 86:10]
              io.control.ready <= enqueuer2.io.in.ready @[LocalRouter.scala 152:19]
            else :
              io.control.ready <= UInt<1>("h1") @[LocalRouter.scala 160:19]

  module Mux_4 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2], flip sel : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}

    wire in : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2] @[Mux.scala 47:19]
    in[0] <= io.in[0] @[Mux.scala 47:19]
    in[1] <= io.in[1] @[Mux.scala 47:19]
    in[UInt<1>("h0")].ready <= UInt<1>("h0") @[Mux.scala 52:19]
    in[UInt<1>("h1")].ready <= UInt<1>("h0") @[Mux.scala 52:19]
    io.out.bits <= in[io.sel.bits].bits @[Mux.scala 57:15]
    node _io_out_valid_T = and(io.sel.valid, in[io.sel.bits].valid) @[Mux.scala 58:29]
    io.out.valid <= _io_out_valid_T @[Mux.scala 58:16]
    node _io_sel_ready_T = and(in[io.sel.bits].valid, io.out.ready) @[Mux.scala 59:26]
    io.sel.ready <= _io_sel_ready_T @[Mux.scala 59:13]
    node _in_ready_T = and(io.sel.valid, io.out.ready) @[Mux.scala 60:26]
    in[io.sel.bits].ready <= _in_ready_T @[Mux.scala 60:13]

  module Demux_4 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip sel : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2]}

    wire _io_out_0_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 75:57]
    node _io_out_0_bits_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[0] <= _io_out_0_bits_T @[package.scala 75:57]
    node _io_out_0_bits_T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[1] <= _io_out_0_bits_T_1 @[package.scala 75:57]
    node _io_out_0_bits_T_2 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[2] <= _io_out_0_bits_T_2 @[package.scala 75:57]
    node _io_out_0_bits_T_3 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[3] <= _io_out_0_bits_T_3 @[package.scala 75:57]
    node _io_out_0_bits_T_4 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[4] <= _io_out_0_bits_T_4 @[package.scala 75:57]
    node _io_out_0_bits_T_5 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[5] <= _io_out_0_bits_T_5 @[package.scala 75:57]
    node _io_out_0_bits_T_6 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[6] <= _io_out_0_bits_T_6 @[package.scala 75:57]
    node _io_out_0_bits_T_7 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_0_bits_WIRE[7] <= _io_out_0_bits_T_7 @[package.scala 75:57]
    io.out[0].bits <= _io_out_0_bits_WIRE @[Demux.scala 27:14]
    io.out[0].valid <= UInt<1>("h0") @[Demux.scala 28:15]
    wire _io_out_1_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 75:57]
    node _io_out_1_bits_T = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[0] <= _io_out_1_bits_T @[package.scala 75:57]
    node _io_out_1_bits_T_1 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[1] <= _io_out_1_bits_T_1 @[package.scala 75:57]
    node _io_out_1_bits_T_2 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[2] <= _io_out_1_bits_T_2 @[package.scala 75:57]
    node _io_out_1_bits_T_3 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[3] <= _io_out_1_bits_T_3 @[package.scala 75:57]
    node _io_out_1_bits_T_4 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[4] <= _io_out_1_bits_T_4 @[package.scala 75:57]
    node _io_out_1_bits_T_5 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[5] <= _io_out_1_bits_T_5 @[package.scala 75:57]
    node _io_out_1_bits_T_6 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[6] <= _io_out_1_bits_T_6 @[package.scala 75:57]
    node _io_out_1_bits_T_7 = asFixedPoint(UInt<16>("h0"), 8) @[package.scala 75:57]
    _io_out_1_bits_WIRE[7] <= _io_out_1_bits_T_7 @[package.scala 75:57]
    io.out[1].bits <= _io_out_1_bits_WIRE @[Demux.scala 27:14]
    io.out[1].valid <= UInt<1>("h0") @[Demux.scala 28:15]
    io.out[io.sel.bits].bits <= io.in.bits @[Demux.scala 32:12]
    node _io_out_valid_T = and(io.sel.valid, io.in.valid) @[Demux.scala 33:26]
    io.out[io.sel.bits].valid <= _io_out_valid_T @[Demux.scala 33:13]
    node _io_sel_ready_T = and(io.in.valid, io.out[io.sel.bits].ready) @[Demux.scala 34:25]
    io.sel.ready <= _io_sel_ready_T @[Demux.scala 34:13]
    node _io_in_ready_T = and(io.sel.valid, io.out[io.sel.bits].ready) @[Demux.scala 35:25]
    io.in.ready <= _io_in_ready_T @[Demux.scala 35:12]

  module HostRouter :
    input clock : Clock
    input reset : Reset
    output io : { flip control : { flip ready : UInt<1>, valid : UInt<1>, bits : { kind : UInt<2>}}, dram0 : { flip dataIn : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, dataOut : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, dram1 : { flip dataIn : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, dataOut : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, mem : { flip output : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, input : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}}

    inst dataIn_mux of Mux_4 @[Mux.scala 71:21]
    dataIn_mux.clock <= clock
    dataIn_mux.reset <= reset
    dataIn_mux.io.in[0] <= io.dram0.dataIn @[Mux.scala 79:18]
    dataIn_mux.io.in[1] <= io.dram1.dataIn @[Mux.scala 80:18]
    io.mem.input.bits <= dataIn_mux.io.out.bits @[Mux.scala 81:9]
    io.mem.input.valid <= dataIn_mux.io.out.valid @[Mux.scala 81:9]
    dataIn_mux.io.out.ready <= io.mem.input.ready @[Mux.scala 81:9]
    inst dataOut_demux of Demux_4 @[Demux.scala 46:23]
    dataOut_demux.clock <= clock
    dataOut_demux.reset <= reset
    dataOut_demux.io.in <= io.mem.output @[Demux.scala 54:17]
    io.dram0.dataOut.bits <= dataOut_demux.io.out[0].bits @[Demux.scala 55:10]
    io.dram0.dataOut.valid <= dataOut_demux.io.out[0].valid @[Demux.scala 55:10]
    dataOut_demux.io.out[0].ready <= io.dram0.dataOut.ready @[Demux.scala 55:10]
    io.dram1.dataOut.bits <= dataOut_demux.io.out[1].bits @[Demux.scala 56:10]
    io.dram1.dataOut.valid <= dataOut_demux.io.out[1].valid @[Demux.scala 56:10]
    dataOut_demux.io.out[1].ready <= io.dram1.dataOut.ready @[Demux.scala 56:10]
    node _isDataIn_T = eq(io.control.bits.kind, UInt<1>("h0")) @[HostRouter.scala 57:10]
    node _isDataIn_T_1 = eq(io.control.bits.kind, UInt<2>("h2")) @[HostRouter.scala 57:26]
    node isDataIn = or(_isDataIn_T, _isDataIn_T_1) @[HostRouter.scala 57:18]
    node _isDataOut_T = eq(io.control.bits.kind, UInt<1>("h1")) @[HostRouter.scala 61:10]
    node _isDataOut_T_1 = eq(io.control.bits.kind, UInt<2>("h3")) @[HostRouter.scala 61:27]
    node isDataOut = or(_isDataOut_T, _isDataOut_T_1) @[HostRouter.scala 61:19]
    node _io_control_ready_T = and(isDataIn, dataIn_mux.io.sel.ready) @[HostRouter.scala 41:30]
    node _io_control_ready_T_1 = and(isDataOut, dataOut_demux.io.sel.ready) @[HostRouter.scala 41:61]
    node _io_control_ready_T_2 = or(_io_control_ready_T, _io_control_ready_T_1) @[HostRouter.scala 41:47]
    io.control.ready <= _io_control_ready_T_2 @[HostRouter.scala 41:17]
    node _mux_io_sel_valid_T = and(io.control.valid, isDataIn) @[HostRouter.scala 43:33]
    dataIn_mux.io.sel.valid <= _mux_io_sel_valid_T @[HostRouter.scala 43:16]
    node _mux_io_sel_bits_T = bits(io.control.bits.kind, 1, 1) @[HostRouter.scala 44:35]
    dataIn_mux.io.sel.bits <= _mux_io_sel_bits_T @[HostRouter.scala 44:15]
    node _demux_io_sel_valid_T = and(io.control.valid, isDataOut) @[HostRouter.scala 46:34]
    dataOut_demux.io.sel.valid <= _demux_io_sel_valid_T @[HostRouter.scala 46:17]
    node _demux_io_sel_bits_T = bits(io.control.bits.kind, 1, 1) @[HostRouter.scala 47:36]
    dataOut_demux.io.sel.bits <= _demux_io_sel_bits_T @[HostRouter.scala 47:16]

  module Queue_28 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, readAddress : UInt<11>, writeAddress : UInt<11>, accumulate : UInt<1>, write : UInt<1>, read : UInt<1>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, readAddress : UInt<11>, writeAddress : UInt<11>, accumulate : UInt<1>, write : UInt<1>, read : UInt<1>}}, count : UInt<2>}

    cmem ram : { instruction : { op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, readAddress : UInt<11>, writeAddress : UInt<11>, accumulate : UInt<1>, write : UInt<1>, read : UInt<1>} [2] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Queue_29 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { load : UInt<1>, zeroes : UInt<1>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { load : UInt<1>, zeroes : UInt<1>}}, count : UInt<2>}

    cmem ram : { load : UInt<1>, zeroes : UInt<1>} [2] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module TCU :
    input clock : Clock
    input reset : Reset
    output io : { flip instruction : { flip ready : UInt<1>, valid : UInt<1>, bits : { opcode : UInt<4>, flags : UInt<4>, arguments : UInt<56>}}, status : { flip ready : UInt<1>, valid : UInt<1>, bits : { last : UInt<1>, bits : { opcode : UInt<4>, flags : UInt<4>, arguments : UInt<56>}}}, dram0 : { control : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>}}, flip dataIn : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, dataOut : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, dram1 : { control : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>}}, flip dataIn : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, dataOut : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, config : { dram0AddressOffset : UInt<32>, dram0CacheBehaviour : UInt<4>, dram1AddressOffset : UInt<32>, dram1CacheBehaviour : UInt<4>}, timeout : UInt<1>, error : UInt<1>, tracepoint : UInt<1>, programCounter : UInt<32>, sample : { flip ready : UInt<1>, valid : UInt<1>, bits : { last : UInt<1>, bits : { flags : { instruction : { ready : UInt<1>, valid : UInt<1>}, memPortA : { ready : UInt<1>, valid : UInt<1>}, memPortB : { ready : UInt<1>, valid : UInt<1>}, dram0 : { ready : UInt<1>, valid : UInt<1>}, dram1 : { ready : UInt<1>, valid : UInt<1>}, dataflow : { ready : UInt<1>, valid : UInt<1>}, acc : { ready : UInt<1>, valid : UInt<1>}, array : { ready : UInt<1>, valid : UInt<1>}}, programCounter : UInt<32>}}}}

    inst decoder of Decoder @[TCU.scala 64:23]
    decoder.clock <= clock
    decoder.reset <= reset
    inst array of SystolicArray @[TCU.scala 65:21]
    array.clock <= clock
    array.reset <= reset
    inst acc of AccumulatorWithALUArray @[TCU.scala 68:19]
    acc.clock <= clock
    acc.reset <= reset
    inst mem of DualPortMem_1 @[TCU.scala 71:19]
    mem.clock <= clock
    mem.reset <= reset
    inst router of LocalRouter @[TCU.scala 80:22]
    router.clock <= clock
    router.reset <= reset
    inst hostRouter of HostRouter @[TCU.scala 87:26]
    hostRouter.clock <= clock
    hostRouter.reset <= reset
    decoder.io.instruction <= io.instruction @[TCU.scala 97:26]
    io.status.bits <= decoder.io.status.bits @[TCU.scala 98:13]
    io.status.valid <= decoder.io.status.valid @[TCU.scala 98:13]
    decoder.io.status.ready <= io.status.ready @[TCU.scala 98:13]
    io.dram0.control.bits <= decoder.io.dram0.bits @[TCU.scala 99:20]
    io.dram0.control.valid <= decoder.io.dram0.valid @[TCU.scala 99:20]
    decoder.io.dram0.ready <= io.dram0.control.ready @[TCU.scala 99:20]
    io.dram1.control.bits <= decoder.io.dram1.bits @[TCU.scala 100:20]
    io.dram1.control.valid <= decoder.io.dram1.valid @[TCU.scala 100:20]
    decoder.io.dram1.ready <= io.dram1.control.ready @[TCU.scala 100:20]
    io.config <= decoder.io.config @[TCU.scala 101:13]
    io.timeout <= decoder.io.timeout @[TCU.scala 102:14]
    io.error <= decoder.io.error @[TCU.scala 103:12]
    io.tracepoint <= decoder.io.tracepoint @[TCU.scala 104:17]
    io.programCounter <= decoder.io.programCounter @[TCU.scala 105:21]
    io.sample.bits <= decoder.io.sample.bits @[TCU.scala 106:13]
    io.sample.valid <= decoder.io.sample.valid @[TCU.scala 106:13]
    decoder.io.sample.ready <= io.sample.ready @[TCU.scala 106:13]
    decoder.io.nooped.ready <= UInt<1>("h1") @[TCU.scala 107:27]
    decoder.io.skipped.ready <= UInt<1>("h1") @[TCU.scala 108:28]
    inst acc_io_control_q of Queue_28 @[TCU.scala 110:39]
    acc_io_control_q.clock <= clock
    acc_io_control_q.reset <= reset
    acc_io_control_q.io.enq <= decoder.io.acc @[TCU.scala 110:39]
    acc.io.control <= acc_io_control_q.io.deq @[TCU.scala 110:18]
    acc.io.tracepoint <= decoder.io.tracepoint @[TCU.scala 111:21]
    acc.io.programCounter <= decoder.io.programCounter @[TCU.scala 112:25]
    acc.io.nooped.ready <= UInt<1>("h1") @[TCU.scala 113:23]
    acc.io.computed.ready <= UInt<1>("h1") @[TCU.scala 114:25]
    acc.io.wrote.ready <= UInt<1>("h1") @[TCU.scala 115:22]
    inst array_io_control_q of Queue_29 @[TCU.scala 117:41]
    array_io_control_q.clock <= clock
    array_io_control_q.reset <= reset
    array_io_control_q.io.enq <= decoder.io.array @[TCU.scala 117:41]
    array.io.control <= array_io_control_q.io.deq @[TCU.scala 117:20]
    array.io.loaded.ready <= UInt<1>("h1") @[TCU.scala 118:25]
    array.io.ran.ready <= UInt<1>("h1") @[TCU.scala 119:22]
    mem.io.tracepoint <= decoder.io.tracepoint @[TCU.scala 122:21]
    mem.io.programCounter <= decoder.io.programCounter @[TCU.scala 123:25]
    mem.io.portA.control <= decoder.io.memPortA @[TCU.scala 124:17]
    mem.io.portA.status.ready <= UInt<1>("h1") @[TCU.scala 125:22]
    mem.io.portA.inputStatus.ready <= UInt<1>("h1") @[TCU.scala 126:27]
    mem.io.portA.wrote.ready <= UInt<1>("h1") @[TCU.scala 127:21]
    router.io.timeout <= decoder.io.timeout @[TCU.scala 129:21]
    router.io.tracepoint <= decoder.io.tracepoint @[TCU.scala 130:24]
    router.io.programCounter <= decoder.io.programCounter @[TCU.scala 131:28]
    router.io.control <= decoder.io.dataflow @[TCU.scala 133:21]
    router.io.mem.output <= mem.io.portA.output @[TCU.scala 135:24]
    mem.io.portA.input <= router.io.mem.input @[TCU.scala 136:15]
    array.io.input <= router.io.array.input @[TCU.scala 138:18]
    router.io.array.output <= array.io.output @[TCU.scala 139:26]
    array.io.weight <= router.io.array.weightInput @[TCU.scala 140:19]
    acc.io.input <= router.io.acc.input @[TCU.scala 142:16]
    router.io.acc.output <= acc.io.output @[TCU.scala 143:24]
    hostRouter.io.control <= decoder.io.hostDataflow @[TCU.scala 146:25]
    mem.io.portB.control <= decoder.io.memPortB @[TCU.scala 148:17]
    mem.io.portB.input <= hostRouter.io.mem.input @[TCU.scala 149:15]
    hostRouter.io.mem.output <= mem.io.portB.output @[TCU.scala 150:28]
    mem.io.portB.status.ready <= UInt<1>("h1") @[TCU.scala 151:22]
    mem.io.portB.inputStatus.ready <= UInt<1>("h1") @[TCU.scala 152:27]
    mem.io.portB.wrote.ready <= UInt<1>("h1") @[TCU.scala 153:21]
    hostRouter.io.dram0.dataIn <= io.dram0.dataIn @[TCU.scala 155:30]
    io.dram0.dataOut.bits <= hostRouter.io.dram0.dataOut.bits @[TCU.scala 156:20]
    io.dram0.dataOut.valid <= hostRouter.io.dram0.dataOut.valid @[TCU.scala 156:20]
    hostRouter.io.dram0.dataOut.ready <= io.dram0.dataOut.ready @[TCU.scala 156:20]
    hostRouter.io.dram1.dataIn <= io.dram1.dataIn @[TCU.scala 158:30]
    io.dram1.dataOut.bits <= hostRouter.io.dram1.dataOut.bits @[TCU.scala 159:20]
    io.dram1.dataOut.valid <= hostRouter.io.dram1.dataOut.valid @[TCU.scala 159:20]
    hostRouter.io.dram1.dataOut.ready <= io.dram1.dataOut.ready @[TCU.scala 159:20]

  module Queue_30 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, count : UInt<2>}

    cmem ram : UInt<8> [2] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    when io.deq.ready : @[Decoupled.scala 309:24]
      io.enq.ready <= UInt<1>("h1") @[Decoupled.scala 309:39]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Queue_31 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, count : UInt<2>}

    cmem ram : UInt<8> [2] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    when io.deq.ready : @[Decoupled.scala 309:24]
      io.enq.ready <= UInt<1>("h1") @[Decoupled.scala 309:39]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Queue_32 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<2>}

    cmem ram : UInt<1> [2] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    when io.deq.ready : @[Decoupled.scala 309:24]
      io.enq.ready <= UInt<1>("h1") @[Decoupled.scala 309:39]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Counter_10 :
    input clock : Clock
    input reset : Reset
    output io : { value : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, flip resetValue : UInt<1>}

    reg value : UInt<8>, clock with :
      reset => (reset, UInt<8>("h0")) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h0")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<8>("hff")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h0") @[Counter.scala 22:13]
      else :
        node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h0") @[Counter.scala 28:11]

  module BurstSplitter :
    input clock : Clock
    input reset : Reset
    output io : { flip control : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}

    io.out.bits.last <= io.in.bits.last @[MemBoundarySplitter.scala 34:34]
    io.out.bits.resp <= io.in.bits.resp @[MemBoundarySplitter.scala 34:34]
    io.out.bits.data <= io.in.bits.data @[MemBoundarySplitter.scala 34:34]
    io.out.bits.id <= io.in.bits.id @[MemBoundarySplitter.scala 34:34]
    node _io_out_valid_T = and(io.control.valid, io.in.valid) @[MemBoundarySplitter.scala 40:36]
    io.out.valid <= _io_out_valid_T @[MemBoundarySplitter.scala 40:16]
    node _io_in_ready_T = and(io.control.valid, io.out.ready) @[MemBoundarySplitter.scala 41:35]
    io.in.ready <= _io_in_ready_T @[MemBoundarySplitter.scala 41:15]
    inst counter of Counter_10 @[Counter.scala 34:19]
    counter.clock <= clock
    counter.reset <= reset
    counter.io.resetValue <= UInt<1>("h0") @[Counter.scala 35:21]
    counter.io.value.ready <= UInt<1>("h0") @[Counter.scala 36:22]
    node _T = eq(counter.io.value.bits, io.control.bits) @[MemBoundarySplitter.scala 45:30]
    when _T : @[MemBoundarySplitter.scala 45:51]
      io.out.bits.last <= UInt<1>("h1") @[MemBoundarySplitter.scala 46:10]
      node _counter_io_resetValue_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 50:35]
      counter.io.resetValue <= _counter_io_resetValue_T @[MemBoundarySplitter.scala 47:27]
      node _io_control_ready_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 50:35]
      io.control.ready <= _io_control_ready_T @[MemBoundarySplitter.scala 48:22]
    else :
      io.out.bits.last <= UInt<1>("h0") @[MemBoundarySplitter.scala 50:10]
      node _counter_io_value_ready_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 50:35]
      counter.io.value.ready <= _counter_io_value_ready_T @[MemBoundarySplitter.scala 51:28]
      io.control.ready <= UInt<1>("h0") @[MemBoundarySplitter.scala 52:22]

  module Counter_11 :
    input clock : Clock
    input reset : Reset
    output io : { value : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, flip resetValue : UInt<1>}

    reg value : UInt<8>, clock with :
      reset => (reset, UInt<8>("h0")) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h0")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<8>("hff")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h0") @[Counter.scala 22:13]
      else :
        node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h0") @[Counter.scala 28:11]

  module BurstSplitter_1 :
    input clock : Clock
    input reset : Reset
    output io : { flip control : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}}

    io.out.bits.last <= io.in.bits.last @[MemBoundarySplitter.scala 34:34]
    io.out.bits.strb <= io.in.bits.strb @[MemBoundarySplitter.scala 34:34]
    io.out.bits.data <= io.in.bits.data @[MemBoundarySplitter.scala 34:34]
    io.out.bits.id <= io.in.bits.id @[MemBoundarySplitter.scala 34:34]
    node _io_out_valid_T = and(io.control.valid, io.in.valid) @[MemBoundarySplitter.scala 40:36]
    io.out.valid <= _io_out_valid_T @[MemBoundarySplitter.scala 40:16]
    node _io_in_ready_T = and(io.control.valid, io.out.ready) @[MemBoundarySplitter.scala 41:35]
    io.in.ready <= _io_in_ready_T @[MemBoundarySplitter.scala 41:15]
    inst counter of Counter_11 @[Counter.scala 34:19]
    counter.clock <= clock
    counter.reset <= reset
    counter.io.resetValue <= UInt<1>("h0") @[Counter.scala 35:21]
    counter.io.value.ready <= UInt<1>("h0") @[Counter.scala 36:22]
    node _T = eq(counter.io.value.bits, io.control.bits) @[MemBoundarySplitter.scala 45:30]
    when _T : @[MemBoundarySplitter.scala 45:51]
      io.out.bits.last <= UInt<1>("h1") @[MemBoundarySplitter.scala 46:10]
      node _counter_io_resetValue_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 50:35]
      counter.io.resetValue <= _counter_io_resetValue_T @[MemBoundarySplitter.scala 47:27]
      node _io_control_ready_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 50:35]
      io.control.ready <= _io_control_ready_T @[MemBoundarySplitter.scala 48:22]
    else :
      io.out.bits.last <= UInt<1>("h0") @[MemBoundarySplitter.scala 50:10]
      node _counter_io_value_ready_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 50:35]
      counter.io.value.ready <= _counter_io_value_ready_T @[MemBoundarySplitter.scala 51:28]
      io.control.ready <= UInt<1>("h0") @[MemBoundarySplitter.scala 52:22]

  module Filter :
    input clock : Clock
    input reset : Reset
    output io : { flip control : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, resp : UInt<2>}}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, resp : UInt<2>}}}

    io.out.bits <= io.in.bits @[MemBoundarySplitter.scala 69:15]
    when io.control.bits : @[MemBoundarySplitter.scala 71:25]
      node _io_out_valid_T = and(io.control.valid, io.in.valid) @[MemBoundarySplitter.scala 72:38]
      io.out.valid <= _io_out_valid_T @[MemBoundarySplitter.scala 72:18]
      node _io_in_ready_T = and(io.control.valid, io.out.ready) @[MemBoundarySplitter.scala 73:37]
      io.in.ready <= _io_in_ready_T @[MemBoundarySplitter.scala 73:17]
      node _io_control_ready_T = and(io.in.valid, io.out.ready) @[MemBoundarySplitter.scala 74:37]
      io.control.ready <= _io_control_ready_T @[MemBoundarySplitter.scala 74:22]
    else :
      io.out.valid <= UInt<1>("h0") @[MemBoundarySplitter.scala 76:18]
      io.in.ready <= io.control.valid @[MemBoundarySplitter.scala 77:17]
      io.control.ready <= io.in.valid @[MemBoundarySplitter.scala 78:22]

  module MultiEnqueue_17 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>}[2]}

    reg enq_0 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node allEnqueued = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_1 = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]

  module MultiEnqueue_18 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>}[3]}

    reg enq_0 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_2 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_2 = or(io.out[2].ready, enq_2) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_3 = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node allEnqueued = and(_allEnqueued_T_3, _allEnqueued_T_2) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_1 = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
    node _io_out_2_valid_T = eq(enq_2, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_2_valid_T_1 = and(io.in.valid, _io_out_2_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[2].valid <= _io_out_2_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_2 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_2 = eq(enq_2, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_2 : @[MultiEnqueue.scala 31:21]
        node _enq_2_T = and(io.out[2].valid, io.out[2].ready) @[MultiEnqueue.scala 32:35]
        enq_2 <= _enq_2_T @[MultiEnqueue.scala 32:16]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]

  module MemBoundarySplitter :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { writeAddress : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, writeData : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, flip writeResponse : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, resp : UInt<2>}}, readAddress : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, flip readData : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}, out : { writeAddress : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, writeData : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, flip writeResponse : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, resp : UInt<2>}}, readAddress : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, flip readData : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}}

    inst readDataQueue of Queue_30 @[MemBoundarySplitter.scala 111:29]
    readDataQueue.clock <= clock
    readDataQueue.reset <= reset
    inst writeDataQueue of Queue_31 @[MemBoundarySplitter.scala 114:30]
    writeDataQueue.clock <= clock
    writeDataQueue.reset <= reset
    inst writeResponseQueue of Queue_32 @[MemBoundarySplitter.scala 117:34]
    writeResponseQueue.clock <= clock
    writeResponseQueue.reset <= reset
    inst readMerger of BurstSplitter @[MemBoundarySplitter.scala 121:26]
    readMerger.clock <= clock
    readMerger.reset <= reset
    readMerger.io.control <= readDataQueue.io.deq @[MemBoundarySplitter.scala 122:25]
    readMerger.io.in <= io.out.readData @[MemBoundarySplitter.scala 123:20]
    io.in.readData.bits <= readMerger.io.out.bits @[MemBoundarySplitter.scala 124:18]
    io.in.readData.valid <= readMerger.io.out.valid @[MemBoundarySplitter.scala 124:18]
    readMerger.io.out.ready <= io.in.readData.ready @[MemBoundarySplitter.scala 124:18]
    inst writeSplitter of BurstSplitter_1 @[MemBoundarySplitter.scala 125:29]
    writeSplitter.clock <= clock
    writeSplitter.reset <= reset
    writeSplitter.io.control <= writeDataQueue.io.deq @[MemBoundarySplitter.scala 126:28]
    writeSplitter.io.in <= io.in.writeData @[MemBoundarySplitter.scala 127:23]
    io.out.writeData.bits <= writeSplitter.io.out.bits @[MemBoundarySplitter.scala 128:20]
    io.out.writeData.valid <= writeSplitter.io.out.valid @[MemBoundarySplitter.scala 128:20]
    writeSplitter.io.out.ready <= io.out.writeData.ready @[MemBoundarySplitter.scala 128:20]
    inst writeResponseFilter of Filter @[MemBoundarySplitter.scala 129:35]
    writeResponseFilter.clock <= clock
    writeResponseFilter.reset <= reset
    writeResponseFilter.io.control <= writeResponseQueue.io.deq @[MemBoundarySplitter.scala 130:34]
    writeResponseFilter.io.in <= io.out.writeResponse @[MemBoundarySplitter.scala 131:29]
    io.in.writeResponse.bits <= writeResponseFilter.io.out.bits @[MemBoundarySplitter.scala 132:23]
    io.in.writeResponse.valid <= writeResponseFilter.io.out.valid @[MemBoundarySplitter.scala 132:23]
    writeResponseFilter.io.out.ready <= io.in.writeResponse.ready @[MemBoundarySplitter.scala 132:23]
    reg readAddressCounter : UInt<11>, clock with :
      reset => (reset, UInt<11>("h0")) @[MemBoundarySplitter.scala 137:35]
    reg readLenCounter : UInt<8>, clock with :
      reset => (reset, UInt<8>("h0")) @[MemBoundarySplitter.scala 140:31]
    reg writeAddressCounter : UInt<11>, clock with :
      reset => (reset, UInt<11>("h0")) @[MemBoundarySplitter.scala 141:36]
    reg writeLenCounter : UInt<8>, clock with :
      reset => (reset, UInt<8>("h0")) @[MemBoundarySplitter.scala 144:32]
    inst readEnqueuer of MultiEnqueue_17 @[MultiEnqueue.scala 182:43]
    readEnqueuer.clock <= clock
    readEnqueuer.reset <= reset
    inst writeEnqueuer of MultiEnqueue_18 @[MultiEnqueue.scala 182:43]
    writeEnqueuer.clock <= clock
    writeEnqueuer.reset <= reset
    node lengthBytes = mul(io.in.readAddress.bits.len, UInt<4>("h8")) @[MemBoundarySplitter.scala 105:30]
    node _T = gt(lengthBytes, UInt<13>("h1000")) @[MemBoundarySplitter.scala 106:18]
    node _T_1 = rem(io.in.readAddress.bits.addr, UInt<13>("h1000")) @[MemBoundarySplitter.scala 106:45]
    node _T_2 = sub(UInt<13>("h1001"), lengthBytes) @[MemBoundarySplitter.scala 106:79]
    node _T_3 = tail(_T_2, 1) @[MemBoundarySplitter.scala 106:79]
    node _T_4 = gt(_T_1, _T_3) @[MemBoundarySplitter.scala 106:59]
    node _T_5 = or(_T, _T_4) @[MemBoundarySplitter.scala 106:32]
    when _T_5 : @[MemBoundarySplitter.scala 150:74]
      node _addr_T = add(io.in.readAddress.bits.addr, readAddressCounter) @[MemBoundarySplitter.scala 151:44]
      node addr = tail(_addr_T, 1) @[MemBoundarySplitter.scala 151:44]
      node _availableAddresses_T = rem(addr, UInt<13>("h1000")) @[MemBoundarySplitter.scala 153:27]
      node _availableAddresses_T_1 = sub(UInt<13>("h1000"), _availableAddresses_T) @[MemBoundarySplitter.scala 153:19]
      node availableAddresses = tail(_availableAddresses_T_1, 1) @[MemBoundarySplitter.scala 153:19]
      node availableBeats = div(availableAddresses, UInt<4>("h8")) @[MemBoundarySplitter.scala 154:45]
      node _len_T = eq(readLenCounter, UInt<1>("h0")) @[MemBoundarySplitter.scala 156:22]
      node _len_T_1 = gt(availableBeats, readLenCounter) @[MemBoundarySplitter.scala 109:43]
      node _len_T_2 = mux(_len_T_1, readLenCounter, availableBeats) @[MemBoundarySplitter.scala 109:40]
      node _len_T_3 = mux(_len_T, availableBeats, _len_T_2) @[MemBoundarySplitter.scala 155:18]
      node _len_T_4 = sub(_len_T_3, UInt<1>("h1")) @[MemBoundarySplitter.scala 159:7]
      node len = tail(_len_T_4, 1) @[MemBoundarySplitter.scala 159:7]
      wire address : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>} @[MemBoundarySplitter.scala 161:23]
      address.qos <= io.in.readAddress.bits.qos @[MemBoundarySplitter.scala 164:11]
      address.prot <= io.in.readAddress.bits.prot @[MemBoundarySplitter.scala 164:11]
      address.cache <= io.in.readAddress.bits.cache @[MemBoundarySplitter.scala 164:11]
      address.lock <= io.in.readAddress.bits.lock @[MemBoundarySplitter.scala 164:11]
      address.burst <= io.in.readAddress.bits.burst @[MemBoundarySplitter.scala 164:11]
      address.size <= io.in.readAddress.bits.size @[MemBoundarySplitter.scala 164:11]
      address.len <= io.in.readAddress.bits.len @[MemBoundarySplitter.scala 164:11]
      address.addr <= io.in.readAddress.bits.addr @[MemBoundarySplitter.scala 164:11]
      address.id <= io.in.readAddress.bits.id @[MemBoundarySplitter.scala 164:11]
      address.addr <= addr @[MemBoundarySplitter.scala 167:18]
      address.len <= len @[MemBoundarySplitter.scala 168:17]
      node _T_6 = eq(readLenCounter, UInt<1>("h0")) @[MemBoundarySplitter.scala 170:25]
      when _T_6 : @[MemBoundarySplitter.scala 170:34]
        readEnqueuer.io.in.valid <= io.in.readAddress.valid @[MultiEnqueue.scala 84:17]
        wire ready_io_out_readAddress_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}} @[ReadyValid.scala 16:17]
        ready_io_out_readAddress_w.bits <= address @[ReadyValid.scala 17:12]
        ready_io_out_readAddress_w.valid <= readEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
        readEnqueuer.io.out[0].ready <= ready_io_out_readAddress_w.ready @[ReadyValid.scala 19:11]
        io.out.readAddress <= ready_io_out_readAddress_w @[MultiEnqueue.scala 85:10]
        wire ready_readDataQueue_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>} @[ReadyValid.scala 16:17]
        ready_readDataQueue_io_enq_w.bits <= io.in.readAddress.bits.len @[ReadyValid.scala 17:12]
        ready_readDataQueue_io_enq_w.valid <= readEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
        readEnqueuer.io.out[1].ready <= ready_readDataQueue_io_enq_w.ready @[ReadyValid.scala 19:11]
        readDataQueue.io.enq <= ready_readDataQueue_io_enq_w @[MultiEnqueue.scala 86:10]
        io.in.readAddress.ready <= UInt<1>("h0") @[Decoupled.scala 88:20]
        node _T_7 = and(io.in.readAddress.valid, readEnqueuer.io.in.ready) @[MemBoundarySplitter.scala 180:36]
        when _T_7 : @[MemBoundarySplitter.scala 180:46]
          readAddressCounter <= availableAddresses @[MemBoundarySplitter.scala 181:28]
          node _readLenCounter_T = sub(io.in.readAddress.bits.len, len) @[MemBoundarySplitter.scala 182:54]
          node _readLenCounter_T_1 = tail(_readLenCounter_T, 1) @[MemBoundarySplitter.scala 182:54]
          readLenCounter <= _readLenCounter_T_1 @[MemBoundarySplitter.scala 182:24]
      else :
        node _T_8 = leq(readLenCounter, availableBeats) @[MemBoundarySplitter.scala 184:31]
        when _T_8 : @[MemBoundarySplitter.scala 184:50]
          io.out.readAddress.valid <= io.in.readAddress.valid @[MemBoundarySplitter.scala 186:32]
          io.in.readAddress.ready <= io.out.readAddress.ready @[MemBoundarySplitter.scala 187:31]
          io.out.readAddress.bits <= address @[MemBoundarySplitter.scala 188:31]
          readDataQueue.io.enq.valid <= UInt<1>("h0") @[Decoupled.scala 72:20]
          readDataQueue.io.enq.bits is invalid @[Decoupled.scala 73:19]
          readEnqueuer.io.in.valid <= UInt<1>("h0") @[ReadyValid.scala 24:11]
          readEnqueuer.io.out[0].ready <= UInt<1>("h0") @[ReadyValid.scala 28:11]
          readEnqueuer.io.out[1].ready <= UInt<1>("h0") @[ReadyValid.scala 28:11]
          node _T_9 = and(io.out.readAddress.ready, io.out.readAddress.valid) @[Decoupled.scala 50:35]
          when _T_9 : @[MemBoundarySplitter.scala 193:37]
            readAddressCounter <= UInt<1>("h0") @[MemBoundarySplitter.scala 194:28]
            readLenCounter <= UInt<1>("h0") @[MemBoundarySplitter.scala 195:24]
        else :
          io.out.readAddress.valid <= io.in.readAddress.valid @[MemBoundarySplitter.scala 199:32]
          io.out.readAddress.bits <= address @[MemBoundarySplitter.scala 200:31]
          readDataQueue.io.enq.valid <= UInt<1>("h0") @[Decoupled.scala 72:20]
          readDataQueue.io.enq.bits is invalid @[Decoupled.scala 73:19]
          readEnqueuer.io.in.valid <= UInt<1>("h0") @[ReadyValid.scala 24:11]
          readEnqueuer.io.out[0].ready <= UInt<1>("h0") @[ReadyValid.scala 28:11]
          readEnqueuer.io.out[1].ready <= UInt<1>("h0") @[ReadyValid.scala 28:11]
          io.in.readAddress.ready <= UInt<1>("h0") @[Decoupled.scala 88:20]
          node _T_10 = and(io.out.readAddress.ready, io.out.readAddress.valid) @[Decoupled.scala 50:35]
          when _T_10 : @[MemBoundarySplitter.scala 206:37]
            node _readAddressCounter_T = add(readAddressCounter, availableAddresses) @[MemBoundarySplitter.scala 208:50]
            node _readAddressCounter_T_1 = tail(_readAddressCounter_T, 1) @[MemBoundarySplitter.scala 208:50]
            readAddressCounter <= _readAddressCounter_T_1 @[MemBoundarySplitter.scala 208:28]
            node _readLenCounter_T_2 = add(len, UInt<1>("h1")) @[MemBoundarySplitter.scala 210:49]
            node _readLenCounter_T_3 = tail(_readLenCounter_T_2, 1) @[MemBoundarySplitter.scala 210:49]
            node _readLenCounter_T_4 = sub(readLenCounter, _readLenCounter_T_3) @[MemBoundarySplitter.scala 210:42]
            node _readLenCounter_T_5 = tail(_readLenCounter_T_4, 1) @[MemBoundarySplitter.scala 210:42]
            readLenCounter <= _readLenCounter_T_5 @[MemBoundarySplitter.scala 210:24]
    else :
      readEnqueuer.io.in.valid <= io.in.readAddress.valid @[MultiEnqueue.scala 84:17]
      wire io_in_readAddress_ready_io_out_readAddress_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}} @[ReadyValid.scala 16:17]
      io_in_readAddress_ready_io_out_readAddress_w.bits <= io.in.readAddress.bits @[ReadyValid.scala 17:12]
      io_in_readAddress_ready_io_out_readAddress_w.valid <= readEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
      readEnqueuer.io.out[0].ready <= io_in_readAddress_ready_io_out_readAddress_w.ready @[ReadyValid.scala 19:11]
      io.out.readAddress <= io_in_readAddress_ready_io_out_readAddress_w @[MultiEnqueue.scala 85:10]
      wire io_in_readAddress_ready_readDataQueue_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>} @[ReadyValid.scala 16:17]
      io_in_readAddress_ready_readDataQueue_io_enq_w.bits <= io.in.readAddress.bits.len @[ReadyValid.scala 17:12]
      io_in_readAddress_ready_readDataQueue_io_enq_w.valid <= readEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
      readEnqueuer.io.out[1].ready <= io_in_readAddress_ready_readDataQueue_io_enq_w.ready @[ReadyValid.scala 19:11]
      readDataQueue.io.enq <= io_in_readAddress_ready_readDataQueue_io_enq_w @[MultiEnqueue.scala 86:10]
      io.in.readAddress.ready <= readEnqueuer.io.in.ready @[MemBoundarySplitter.scala 214:29]
    node lengthBytes_1 = mul(io.in.writeAddress.bits.len, UInt<4>("h8")) @[MemBoundarySplitter.scala 105:30]
    node _T_11 = gt(lengthBytes_1, UInt<13>("h1000")) @[MemBoundarySplitter.scala 106:18]
    node _T_12 = rem(io.in.writeAddress.bits.addr, UInt<13>("h1000")) @[MemBoundarySplitter.scala 106:45]
    node _T_13 = sub(UInt<13>("h1001"), lengthBytes_1) @[MemBoundarySplitter.scala 106:79]
    node _T_14 = tail(_T_13, 1) @[MemBoundarySplitter.scala 106:79]
    node _T_15 = gt(_T_12, _T_14) @[MemBoundarySplitter.scala 106:59]
    node _T_16 = or(_T_11, _T_15) @[MemBoundarySplitter.scala 106:32]
    when _T_16 : @[MemBoundarySplitter.scala 224:76]
      node _addr_T_1 = add(io.in.writeAddress.bits.addr, writeAddressCounter) @[MemBoundarySplitter.scala 225:45]
      node addr_1 = tail(_addr_T_1, 1) @[MemBoundarySplitter.scala 225:45]
      node _availableAddresses_T_2 = rem(addr_1, UInt<13>("h1000")) @[MemBoundarySplitter.scala 227:27]
      node _availableAddresses_T_3 = sub(UInt<13>("h1000"), _availableAddresses_T_2) @[MemBoundarySplitter.scala 227:19]
      node availableAddresses_1 = tail(_availableAddresses_T_3, 1) @[MemBoundarySplitter.scala 227:19]
      node availableBeats_1 = div(availableAddresses_1, UInt<4>("h8")) @[MemBoundarySplitter.scala 228:45]
      node _len_T_5 = eq(writeLenCounter, UInt<1>("h0")) @[MemBoundarySplitter.scala 230:23]
      node _len_T_6 = gt(availableBeats_1, writeLenCounter) @[MemBoundarySplitter.scala 109:43]
      node _len_T_7 = mux(_len_T_6, writeLenCounter, availableBeats_1) @[MemBoundarySplitter.scala 109:40]
      node _len_T_8 = mux(_len_T_5, availableBeats_1, _len_T_7) @[MemBoundarySplitter.scala 229:18]
      node _len_T_9 = sub(_len_T_8, UInt<1>("h1")) @[MemBoundarySplitter.scala 233:7]
      node len_1 = tail(_len_T_9, 1) @[MemBoundarySplitter.scala 233:7]
      wire address_1 : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>} @[MemBoundarySplitter.scala 235:23]
      address_1.qos <= io.in.writeAddress.bits.qos @[MemBoundarySplitter.scala 238:11]
      address_1.prot <= io.in.writeAddress.bits.prot @[MemBoundarySplitter.scala 238:11]
      address_1.cache <= io.in.writeAddress.bits.cache @[MemBoundarySplitter.scala 238:11]
      address_1.lock <= io.in.writeAddress.bits.lock @[MemBoundarySplitter.scala 238:11]
      address_1.burst <= io.in.writeAddress.bits.burst @[MemBoundarySplitter.scala 238:11]
      address_1.size <= io.in.writeAddress.bits.size @[MemBoundarySplitter.scala 238:11]
      address_1.len <= io.in.writeAddress.bits.len @[MemBoundarySplitter.scala 238:11]
      address_1.addr <= io.in.writeAddress.bits.addr @[MemBoundarySplitter.scala 238:11]
      address_1.id <= io.in.writeAddress.bits.id @[MemBoundarySplitter.scala 238:11]
      address_1.addr <= addr_1 @[MemBoundarySplitter.scala 241:18]
      address_1.len <= len_1 @[MemBoundarySplitter.scala 242:17]
      node _T_17 = eq(writeLenCounter, UInt<1>("h0")) @[MemBoundarySplitter.scala 244:26]
      when _T_17 : @[MemBoundarySplitter.scala 244:35]
        writeEnqueuer.io.in.valid <= io.in.writeAddress.valid @[MultiEnqueue.scala 114:17]
        wire ready_io_out_writeAddress_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}} @[ReadyValid.scala 16:17]
        ready_io_out_writeAddress_w.bits <= address_1 @[ReadyValid.scala 17:12]
        ready_io_out_writeAddress_w.valid <= writeEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
        writeEnqueuer.io.out[0].ready <= ready_io_out_writeAddress_w.ready @[ReadyValid.scala 19:11]
        io.out.writeAddress <= ready_io_out_writeAddress_w @[MultiEnqueue.scala 115:10]
        wire ready_writeDataQueue_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>} @[ReadyValid.scala 16:17]
        ready_writeDataQueue_io_enq_w.bits <= address_1.len @[ReadyValid.scala 17:12]
        ready_writeDataQueue_io_enq_w.valid <= writeEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
        writeEnqueuer.io.out[1].ready <= ready_writeDataQueue_io_enq_w.ready @[ReadyValid.scala 19:11]
        writeDataQueue.io.enq <= ready_writeDataQueue_io_enq_w @[MultiEnqueue.scala 116:10]
        wire ready_writeResponseQueue_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
        ready_writeResponseQueue_io_enq_w.bits <= UInt<1>("h0") @[ReadyValid.scala 17:12]
        ready_writeResponseQueue_io_enq_w.valid <= writeEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
        writeEnqueuer.io.out[2].ready <= ready_writeResponseQueue_io_enq_w.ready @[ReadyValid.scala 19:11]
        writeResponseQueue.io.enq <= ready_writeResponseQueue_io_enq_w @[MultiEnqueue.scala 117:10]
        io.in.writeAddress.ready <= UInt<1>("h0") @[Decoupled.scala 88:20]
        node _T_18 = and(io.in.writeAddress.valid, writeEnqueuer.io.in.ready) @[MemBoundarySplitter.scala 256:37]
        when _T_18 : @[MemBoundarySplitter.scala 256:47]
          writeAddressCounter <= availableAddresses_1 @[MemBoundarySplitter.scala 257:29]
          node _writeLenCounter_T = sub(io.in.writeAddress.bits.len, len_1) @[MemBoundarySplitter.scala 258:56]
          node _writeLenCounter_T_1 = tail(_writeLenCounter_T, 1) @[MemBoundarySplitter.scala 258:56]
          writeLenCounter <= _writeLenCounter_T_1 @[MemBoundarySplitter.scala 258:25]
      else :
        node _T_19 = leq(writeLenCounter, availableBeats_1) @[MemBoundarySplitter.scala 260:32]
        when _T_19 : @[MemBoundarySplitter.scala 260:51]
          writeEnqueuer.io.in.valid <= io.in.writeAddress.valid @[MultiEnqueue.scala 114:17]
          wire ready_io_out_writeAddress_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}} @[ReadyValid.scala 16:17]
          ready_io_out_writeAddress_w_1.bits <= address_1 @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_1.valid <= writeEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
          writeEnqueuer.io.out[0].ready <= ready_io_out_writeAddress_w_1.ready @[ReadyValid.scala 19:11]
          io.out.writeAddress <= ready_io_out_writeAddress_w_1 @[MultiEnqueue.scala 115:10]
          wire ready_writeDataQueue_io_enq_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>} @[ReadyValid.scala 16:17]
          ready_writeDataQueue_io_enq_w_1.bits <= address_1.len @[ReadyValid.scala 17:12]
          ready_writeDataQueue_io_enq_w_1.valid <= writeEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
          writeEnqueuer.io.out[1].ready <= ready_writeDataQueue_io_enq_w_1.ready @[ReadyValid.scala 19:11]
          writeDataQueue.io.enq <= ready_writeDataQueue_io_enq_w_1 @[MultiEnqueue.scala 116:10]
          wire ready_writeResponseQueue_io_enq_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
          ready_writeResponseQueue_io_enq_w_1.bits <= UInt<1>("h1") @[ReadyValid.scala 17:12]
          ready_writeResponseQueue_io_enq_w_1.valid <= writeEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
          writeEnqueuer.io.out[2].ready <= ready_writeResponseQueue_io_enq_w_1.ready @[ReadyValid.scala 19:11]
          writeResponseQueue.io.enq <= ready_writeResponseQueue_io_enq_w_1 @[MultiEnqueue.scala 117:10]
          io.in.writeAddress.ready <= writeEnqueuer.io.in.ready @[MemBoundarySplitter.scala 271:32]
          node _T_20 = and(io.in.writeAddress.valid, writeEnqueuer.io.in.ready) @[MemBoundarySplitter.scala 272:37]
          when _T_20 : @[MemBoundarySplitter.scala 272:47]
            writeAddressCounter <= UInt<1>("h0") @[MemBoundarySplitter.scala 273:29]
            writeLenCounter <= UInt<1>("h0") @[MemBoundarySplitter.scala 274:25]
        else :
          writeEnqueuer.io.in.valid <= io.in.writeAddress.valid @[MultiEnqueue.scala 114:17]
          wire ready_io_out_writeAddress_w_2 : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}} @[ReadyValid.scala 16:17]
          ready_io_out_writeAddress_w_2.bits <= address_1 @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_2.valid <= writeEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
          writeEnqueuer.io.out[0].ready <= ready_io_out_writeAddress_w_2.ready @[ReadyValid.scala 19:11]
          io.out.writeAddress <= ready_io_out_writeAddress_w_2 @[MultiEnqueue.scala 115:10]
          wire ready_writeDataQueue_io_enq_w_2 : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>} @[ReadyValid.scala 16:17]
          ready_writeDataQueue_io_enq_w_2.bits <= address_1.len @[ReadyValid.scala 17:12]
          ready_writeDataQueue_io_enq_w_2.valid <= writeEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
          writeEnqueuer.io.out[1].ready <= ready_writeDataQueue_io_enq_w_2.ready @[ReadyValid.scala 19:11]
          writeDataQueue.io.enq <= ready_writeDataQueue_io_enq_w_2 @[MultiEnqueue.scala 116:10]
          wire ready_writeResponseQueue_io_enq_w_2 : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
          ready_writeResponseQueue_io_enq_w_2.bits <= UInt<1>("h0") @[ReadyValid.scala 17:12]
          ready_writeResponseQueue_io_enq_w_2.valid <= writeEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
          writeEnqueuer.io.out[2].ready <= ready_writeResponseQueue_io_enq_w_2.ready @[ReadyValid.scala 19:11]
          writeResponseQueue.io.enq <= ready_writeResponseQueue_io_enq_w_2 @[MultiEnqueue.scala 117:10]
          io.in.writeAddress.ready <= UInt<1>("h0") @[Decoupled.scala 88:20]
          node _T_21 = and(io.in.writeAddress.valid, writeEnqueuer.io.in.ready) @[MemBoundarySplitter.scala 288:37]
          when _T_21 : @[MemBoundarySplitter.scala 288:47]
            node _writeAddressCounter_T = add(writeAddressCounter, availableAddresses_1) @[MemBoundarySplitter.scala 290:52]
            node _writeAddressCounter_T_1 = tail(_writeAddressCounter_T, 1) @[MemBoundarySplitter.scala 290:52]
            writeAddressCounter <= _writeAddressCounter_T_1 @[MemBoundarySplitter.scala 290:29]
            node _writeLenCounter_T_2 = add(len_1, UInt<1>("h1")) @[MemBoundarySplitter.scala 292:51]
            node _writeLenCounter_T_3 = tail(_writeLenCounter_T_2, 1) @[MemBoundarySplitter.scala 292:51]
            node _writeLenCounter_T_4 = sub(writeLenCounter, _writeLenCounter_T_3) @[MemBoundarySplitter.scala 292:44]
            node _writeLenCounter_T_5 = tail(_writeLenCounter_T_4, 1) @[MemBoundarySplitter.scala 292:44]
            writeLenCounter <= _writeLenCounter_T_5 @[MemBoundarySplitter.scala 292:25]
    else :
      writeEnqueuer.io.in.valid <= io.in.writeAddress.valid @[MultiEnqueue.scala 114:17]
      wire io_in_writeAddress_ready_io_out_writeAddress_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}} @[ReadyValid.scala 16:17]
      io_in_writeAddress_ready_io_out_writeAddress_w.bits <= io.in.writeAddress.bits @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_io_out_writeAddress_w.valid <= writeEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
      writeEnqueuer.io.out[0].ready <= io_in_writeAddress_ready_io_out_writeAddress_w.ready @[ReadyValid.scala 19:11]
      io.out.writeAddress <= io_in_writeAddress_ready_io_out_writeAddress_w @[MultiEnqueue.scala 115:10]
      wire io_in_writeAddress_ready_writeDataQueue_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>} @[ReadyValid.scala 16:17]
      io_in_writeAddress_ready_writeDataQueue_io_enq_w.bits <= io.in.writeAddress.bits.len @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_writeDataQueue_io_enq_w.valid <= writeEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
      writeEnqueuer.io.out[1].ready <= io_in_writeAddress_ready_writeDataQueue_io_enq_w.ready @[ReadyValid.scala 19:11]
      writeDataQueue.io.enq <= io_in_writeAddress_ready_writeDataQueue_io_enq_w @[MultiEnqueue.scala 116:10]
      wire io_in_writeAddress_ready_writeResponseQueue_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
      io_in_writeAddress_ready_writeResponseQueue_io_enq_w.bits <= UInt<1>("h1") @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_writeResponseQueue_io_enq_w.valid <= writeEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
      writeEnqueuer.io.out[2].ready <= io_in_writeAddress_ready_writeResponseQueue_io_enq_w.ready @[ReadyValid.scala 19:11]
      writeResponseQueue.io.enq <= io_in_writeAddress_ready_writeResponseQueue_io_enq_w @[MultiEnqueue.scala 117:10]
      io.in.writeAddress.ready <= writeEnqueuer.io.in.ready @[MemBoundarySplitter.scala 296:30]

  module Queue_33 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, count : UInt<2>}

    cmem ram : UInt<8> [2] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    when io.deq.ready : @[Decoupled.scala 309:24]
      io.enq.ready <= UInt<1>("h1") @[Decoupled.scala 309:39]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Queue_34 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, count : UInt<2>}

    cmem ram : UInt<8> [2] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    when io.deq.ready : @[Decoupled.scala 309:24]
      io.enq.ready <= UInt<1>("h1") @[Decoupled.scala 309:39]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Queue_35 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<2>}

    cmem ram : UInt<1> [2] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    when io.enq.valid : @[Decoupled.scala 300:24]
      io.deq.valid <= UInt<1>("h1") @[Decoupled.scala 300:39]
    when empty : @[Decoupled.scala 301:17]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 302:19]
      do_deq <= UInt<1>("h0") @[Decoupled.scala 303:14]
      when io.deq.ready : @[Decoupled.scala 304:26]
        do_enq <= UInt<1>("h0") @[Decoupled.scala 304:35]
    when io.deq.ready : @[Decoupled.scala 309:24]
      io.enq.ready <= UInt<1>("h1") @[Decoupled.scala 309:39]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Counter_12 :
    input clock : Clock
    input reset : Reset
    output io : { value : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, flip resetValue : UInt<1>}

    reg value : UInt<8>, clock with :
      reset => (reset, UInt<8>("h0")) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h0")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<8>("hff")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h0") @[Counter.scala 22:13]
      else :
        node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h0") @[Counter.scala 28:11]

  module BurstSplitter_2 :
    input clock : Clock
    input reset : Reset
    output io : { flip control : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}

    io.out.bits.last <= io.in.bits.last @[MemBoundarySplitter.scala 34:34]
    io.out.bits.resp <= io.in.bits.resp @[MemBoundarySplitter.scala 34:34]
    io.out.bits.data <= io.in.bits.data @[MemBoundarySplitter.scala 34:34]
    io.out.bits.id <= io.in.bits.id @[MemBoundarySplitter.scala 34:34]
    node _io_out_valid_T = and(io.control.valid, io.in.valid) @[MemBoundarySplitter.scala 40:36]
    io.out.valid <= _io_out_valid_T @[MemBoundarySplitter.scala 40:16]
    node _io_in_ready_T = and(io.control.valid, io.out.ready) @[MemBoundarySplitter.scala 41:35]
    io.in.ready <= _io_in_ready_T @[MemBoundarySplitter.scala 41:15]
    inst counter of Counter_12 @[Counter.scala 34:19]
    counter.clock <= clock
    counter.reset <= reset
    counter.io.resetValue <= UInt<1>("h0") @[Counter.scala 35:21]
    counter.io.value.ready <= UInt<1>("h0") @[Counter.scala 36:22]
    node _T = eq(counter.io.value.bits, io.control.bits) @[MemBoundarySplitter.scala 45:30]
    when _T : @[MemBoundarySplitter.scala 45:51]
      io.out.bits.last <= UInt<1>("h1") @[MemBoundarySplitter.scala 46:10]
      node _counter_io_resetValue_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 50:35]
      counter.io.resetValue <= _counter_io_resetValue_T @[MemBoundarySplitter.scala 47:27]
      node _io_control_ready_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 50:35]
      io.control.ready <= _io_control_ready_T @[MemBoundarySplitter.scala 48:22]
    else :
      io.out.bits.last <= UInt<1>("h0") @[MemBoundarySplitter.scala 50:10]
      node _counter_io_value_ready_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 50:35]
      counter.io.value.ready <= _counter_io_value_ready_T @[MemBoundarySplitter.scala 51:28]
      io.control.ready <= UInt<1>("h0") @[MemBoundarySplitter.scala 52:22]

  module Counter_13 :
    input clock : Clock
    input reset : Reset
    output io : { value : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, flip resetValue : UInt<1>}

    reg value : UInt<8>, clock with :
      reset => (reset, UInt<8>("h0")) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h0")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<8>("hff")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h0") @[Counter.scala 22:13]
      else :
        node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h0") @[Counter.scala 28:11]

  module BurstSplitter_3 :
    input clock : Clock
    input reset : Reset
    output io : { flip control : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}}

    io.out.bits.last <= io.in.bits.last @[MemBoundarySplitter.scala 34:34]
    io.out.bits.strb <= io.in.bits.strb @[MemBoundarySplitter.scala 34:34]
    io.out.bits.data <= io.in.bits.data @[MemBoundarySplitter.scala 34:34]
    io.out.bits.id <= io.in.bits.id @[MemBoundarySplitter.scala 34:34]
    node _io_out_valid_T = and(io.control.valid, io.in.valid) @[MemBoundarySplitter.scala 40:36]
    io.out.valid <= _io_out_valid_T @[MemBoundarySplitter.scala 40:16]
    node _io_in_ready_T = and(io.control.valid, io.out.ready) @[MemBoundarySplitter.scala 41:35]
    io.in.ready <= _io_in_ready_T @[MemBoundarySplitter.scala 41:15]
    inst counter of Counter_13 @[Counter.scala 34:19]
    counter.clock <= clock
    counter.reset <= reset
    counter.io.resetValue <= UInt<1>("h0") @[Counter.scala 35:21]
    counter.io.value.ready <= UInt<1>("h0") @[Counter.scala 36:22]
    node _T = eq(counter.io.value.bits, io.control.bits) @[MemBoundarySplitter.scala 45:30]
    when _T : @[MemBoundarySplitter.scala 45:51]
      io.out.bits.last <= UInt<1>("h1") @[MemBoundarySplitter.scala 46:10]
      node _counter_io_resetValue_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 50:35]
      counter.io.resetValue <= _counter_io_resetValue_T @[MemBoundarySplitter.scala 47:27]
      node _io_control_ready_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 50:35]
      io.control.ready <= _io_control_ready_T @[MemBoundarySplitter.scala 48:22]
    else :
      io.out.bits.last <= UInt<1>("h0") @[MemBoundarySplitter.scala 50:10]
      node _counter_io_value_ready_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 50:35]
      counter.io.value.ready <= _counter_io_value_ready_T @[MemBoundarySplitter.scala 51:28]
      io.control.ready <= UInt<1>("h0") @[MemBoundarySplitter.scala 52:22]

  module Filter_1 :
    input clock : Clock
    input reset : Reset
    output io : { flip control : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, resp : UInt<2>}}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, resp : UInt<2>}}}

    io.out.bits <= io.in.bits @[MemBoundarySplitter.scala 69:15]
    when io.control.bits : @[MemBoundarySplitter.scala 71:25]
      node _io_out_valid_T = and(io.control.valid, io.in.valid) @[MemBoundarySplitter.scala 72:38]
      io.out.valid <= _io_out_valid_T @[MemBoundarySplitter.scala 72:18]
      node _io_in_ready_T = and(io.control.valid, io.out.ready) @[MemBoundarySplitter.scala 73:37]
      io.in.ready <= _io_in_ready_T @[MemBoundarySplitter.scala 73:17]
      node _io_control_ready_T = and(io.in.valid, io.out.ready) @[MemBoundarySplitter.scala 74:37]
      io.control.ready <= _io_control_ready_T @[MemBoundarySplitter.scala 74:22]
    else :
      io.out.valid <= UInt<1>("h0") @[MemBoundarySplitter.scala 76:18]
      io.in.ready <= io.control.valid @[MemBoundarySplitter.scala 77:17]
      io.control.ready <= io.in.valid @[MemBoundarySplitter.scala 78:22]

  module MultiEnqueue_19 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>}[2]}

    reg enq_0 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node allEnqueued = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_1 = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]

  module MultiEnqueue_20 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>}[3]}

    reg enq_0 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_2 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_2 = or(io.out[2].ready, enq_2) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_3 = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node allEnqueued = and(_allEnqueued_T_3, _allEnqueued_T_2) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_1 = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
    node _io_out_2_valid_T = eq(enq_2, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_2_valid_T_1 = and(io.in.valid, _io_out_2_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[2].valid <= _io_out_2_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_2 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_2 = eq(enq_2, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_2 : @[MultiEnqueue.scala 31:21]
        node _enq_2_T = and(io.out[2].valid, io.out[2].ready) @[MultiEnqueue.scala 32:35]
        enq_2 <= _enq_2_T @[MultiEnqueue.scala 32:16]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]

  module MemBoundarySplitter_1 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { writeAddress : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, writeData : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, flip writeResponse : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, resp : UInt<2>}}, readAddress : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, flip readData : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}, out : { writeAddress : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, writeData : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, flip writeResponse : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, resp : UInt<2>}}, readAddress : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, flip readData : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}}

    inst readDataQueue of Queue_33 @[MemBoundarySplitter.scala 111:29]
    readDataQueue.clock <= clock
    readDataQueue.reset <= reset
    inst writeDataQueue of Queue_34 @[MemBoundarySplitter.scala 114:30]
    writeDataQueue.clock <= clock
    writeDataQueue.reset <= reset
    inst writeResponseQueue of Queue_35 @[MemBoundarySplitter.scala 117:34]
    writeResponseQueue.clock <= clock
    writeResponseQueue.reset <= reset
    inst readMerger of BurstSplitter_2 @[MemBoundarySplitter.scala 121:26]
    readMerger.clock <= clock
    readMerger.reset <= reset
    readMerger.io.control <= readDataQueue.io.deq @[MemBoundarySplitter.scala 122:25]
    readMerger.io.in <= io.out.readData @[MemBoundarySplitter.scala 123:20]
    io.in.readData.bits <= readMerger.io.out.bits @[MemBoundarySplitter.scala 124:18]
    io.in.readData.valid <= readMerger.io.out.valid @[MemBoundarySplitter.scala 124:18]
    readMerger.io.out.ready <= io.in.readData.ready @[MemBoundarySplitter.scala 124:18]
    inst writeSplitter of BurstSplitter_3 @[MemBoundarySplitter.scala 125:29]
    writeSplitter.clock <= clock
    writeSplitter.reset <= reset
    writeSplitter.io.control <= writeDataQueue.io.deq @[MemBoundarySplitter.scala 126:28]
    writeSplitter.io.in <= io.in.writeData @[MemBoundarySplitter.scala 127:23]
    io.out.writeData.bits <= writeSplitter.io.out.bits @[MemBoundarySplitter.scala 128:20]
    io.out.writeData.valid <= writeSplitter.io.out.valid @[MemBoundarySplitter.scala 128:20]
    writeSplitter.io.out.ready <= io.out.writeData.ready @[MemBoundarySplitter.scala 128:20]
    inst writeResponseFilter of Filter_1 @[MemBoundarySplitter.scala 129:35]
    writeResponseFilter.clock <= clock
    writeResponseFilter.reset <= reset
    writeResponseFilter.io.control <= writeResponseQueue.io.deq @[MemBoundarySplitter.scala 130:34]
    writeResponseFilter.io.in <= io.out.writeResponse @[MemBoundarySplitter.scala 131:29]
    io.in.writeResponse.bits <= writeResponseFilter.io.out.bits @[MemBoundarySplitter.scala 132:23]
    io.in.writeResponse.valid <= writeResponseFilter.io.out.valid @[MemBoundarySplitter.scala 132:23]
    writeResponseFilter.io.out.ready <= io.in.writeResponse.ready @[MemBoundarySplitter.scala 132:23]
    reg readAddressCounter : UInt<11>, clock with :
      reset => (reset, UInt<11>("h0")) @[MemBoundarySplitter.scala 137:35]
    reg readLenCounter : UInt<8>, clock with :
      reset => (reset, UInt<8>("h0")) @[MemBoundarySplitter.scala 140:31]
    reg writeAddressCounter : UInt<11>, clock with :
      reset => (reset, UInt<11>("h0")) @[MemBoundarySplitter.scala 141:36]
    reg writeLenCounter : UInt<8>, clock with :
      reset => (reset, UInt<8>("h0")) @[MemBoundarySplitter.scala 144:32]
    inst readEnqueuer of MultiEnqueue_19 @[MultiEnqueue.scala 182:43]
    readEnqueuer.clock <= clock
    readEnqueuer.reset <= reset
    inst writeEnqueuer of MultiEnqueue_20 @[MultiEnqueue.scala 182:43]
    writeEnqueuer.clock <= clock
    writeEnqueuer.reset <= reset
    node lengthBytes = mul(io.in.readAddress.bits.len, UInt<4>("h8")) @[MemBoundarySplitter.scala 105:30]
    node _T = gt(lengthBytes, UInt<13>("h1000")) @[MemBoundarySplitter.scala 106:18]
    node _T_1 = rem(io.in.readAddress.bits.addr, UInt<13>("h1000")) @[MemBoundarySplitter.scala 106:45]
    node _T_2 = sub(UInt<13>("h1001"), lengthBytes) @[MemBoundarySplitter.scala 106:79]
    node _T_3 = tail(_T_2, 1) @[MemBoundarySplitter.scala 106:79]
    node _T_4 = gt(_T_1, _T_3) @[MemBoundarySplitter.scala 106:59]
    node _T_5 = or(_T, _T_4) @[MemBoundarySplitter.scala 106:32]
    when _T_5 : @[MemBoundarySplitter.scala 150:74]
      node _addr_T = add(io.in.readAddress.bits.addr, readAddressCounter) @[MemBoundarySplitter.scala 151:44]
      node addr = tail(_addr_T, 1) @[MemBoundarySplitter.scala 151:44]
      node _availableAddresses_T = rem(addr, UInt<13>("h1000")) @[MemBoundarySplitter.scala 153:27]
      node _availableAddresses_T_1 = sub(UInt<13>("h1000"), _availableAddresses_T) @[MemBoundarySplitter.scala 153:19]
      node availableAddresses = tail(_availableAddresses_T_1, 1) @[MemBoundarySplitter.scala 153:19]
      node availableBeats = div(availableAddresses, UInt<4>("h8")) @[MemBoundarySplitter.scala 154:45]
      node _len_T = eq(readLenCounter, UInt<1>("h0")) @[MemBoundarySplitter.scala 156:22]
      node _len_T_1 = gt(availableBeats, readLenCounter) @[MemBoundarySplitter.scala 109:43]
      node _len_T_2 = mux(_len_T_1, readLenCounter, availableBeats) @[MemBoundarySplitter.scala 109:40]
      node _len_T_3 = mux(_len_T, availableBeats, _len_T_2) @[MemBoundarySplitter.scala 155:18]
      node _len_T_4 = sub(_len_T_3, UInt<1>("h1")) @[MemBoundarySplitter.scala 159:7]
      node len = tail(_len_T_4, 1) @[MemBoundarySplitter.scala 159:7]
      wire address : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>} @[MemBoundarySplitter.scala 161:23]
      address.qos <= io.in.readAddress.bits.qos @[MemBoundarySplitter.scala 164:11]
      address.prot <= io.in.readAddress.bits.prot @[MemBoundarySplitter.scala 164:11]
      address.cache <= io.in.readAddress.bits.cache @[MemBoundarySplitter.scala 164:11]
      address.lock <= io.in.readAddress.bits.lock @[MemBoundarySplitter.scala 164:11]
      address.burst <= io.in.readAddress.bits.burst @[MemBoundarySplitter.scala 164:11]
      address.size <= io.in.readAddress.bits.size @[MemBoundarySplitter.scala 164:11]
      address.len <= io.in.readAddress.bits.len @[MemBoundarySplitter.scala 164:11]
      address.addr <= io.in.readAddress.bits.addr @[MemBoundarySplitter.scala 164:11]
      address.id <= io.in.readAddress.bits.id @[MemBoundarySplitter.scala 164:11]
      address.addr <= addr @[MemBoundarySplitter.scala 167:18]
      address.len <= len @[MemBoundarySplitter.scala 168:17]
      node _T_6 = eq(readLenCounter, UInt<1>("h0")) @[MemBoundarySplitter.scala 170:25]
      when _T_6 : @[MemBoundarySplitter.scala 170:34]
        readEnqueuer.io.in.valid <= io.in.readAddress.valid @[MultiEnqueue.scala 84:17]
        wire ready_io_out_readAddress_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}} @[ReadyValid.scala 16:17]
        ready_io_out_readAddress_w.bits <= address @[ReadyValid.scala 17:12]
        ready_io_out_readAddress_w.valid <= readEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
        readEnqueuer.io.out[0].ready <= ready_io_out_readAddress_w.ready @[ReadyValid.scala 19:11]
        io.out.readAddress <= ready_io_out_readAddress_w @[MultiEnqueue.scala 85:10]
        wire ready_readDataQueue_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>} @[ReadyValid.scala 16:17]
        ready_readDataQueue_io_enq_w.bits <= io.in.readAddress.bits.len @[ReadyValid.scala 17:12]
        ready_readDataQueue_io_enq_w.valid <= readEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
        readEnqueuer.io.out[1].ready <= ready_readDataQueue_io_enq_w.ready @[ReadyValid.scala 19:11]
        readDataQueue.io.enq <= ready_readDataQueue_io_enq_w @[MultiEnqueue.scala 86:10]
        io.in.readAddress.ready <= UInt<1>("h0") @[Decoupled.scala 88:20]
        node _T_7 = and(io.in.readAddress.valid, readEnqueuer.io.in.ready) @[MemBoundarySplitter.scala 180:36]
        when _T_7 : @[MemBoundarySplitter.scala 180:46]
          readAddressCounter <= availableAddresses @[MemBoundarySplitter.scala 181:28]
          node _readLenCounter_T = sub(io.in.readAddress.bits.len, len) @[MemBoundarySplitter.scala 182:54]
          node _readLenCounter_T_1 = tail(_readLenCounter_T, 1) @[MemBoundarySplitter.scala 182:54]
          readLenCounter <= _readLenCounter_T_1 @[MemBoundarySplitter.scala 182:24]
      else :
        node _T_8 = leq(readLenCounter, availableBeats) @[MemBoundarySplitter.scala 184:31]
        when _T_8 : @[MemBoundarySplitter.scala 184:50]
          io.out.readAddress.valid <= io.in.readAddress.valid @[MemBoundarySplitter.scala 186:32]
          io.in.readAddress.ready <= io.out.readAddress.ready @[MemBoundarySplitter.scala 187:31]
          io.out.readAddress.bits <= address @[MemBoundarySplitter.scala 188:31]
          readDataQueue.io.enq.valid <= UInt<1>("h0") @[Decoupled.scala 72:20]
          readDataQueue.io.enq.bits is invalid @[Decoupled.scala 73:19]
          readEnqueuer.io.in.valid <= UInt<1>("h0") @[ReadyValid.scala 24:11]
          readEnqueuer.io.out[0].ready <= UInt<1>("h0") @[ReadyValid.scala 28:11]
          readEnqueuer.io.out[1].ready <= UInt<1>("h0") @[ReadyValid.scala 28:11]
          node _T_9 = and(io.out.readAddress.ready, io.out.readAddress.valid) @[Decoupled.scala 50:35]
          when _T_9 : @[MemBoundarySplitter.scala 193:37]
            readAddressCounter <= UInt<1>("h0") @[MemBoundarySplitter.scala 194:28]
            readLenCounter <= UInt<1>("h0") @[MemBoundarySplitter.scala 195:24]
        else :
          io.out.readAddress.valid <= io.in.readAddress.valid @[MemBoundarySplitter.scala 199:32]
          io.out.readAddress.bits <= address @[MemBoundarySplitter.scala 200:31]
          readDataQueue.io.enq.valid <= UInt<1>("h0") @[Decoupled.scala 72:20]
          readDataQueue.io.enq.bits is invalid @[Decoupled.scala 73:19]
          readEnqueuer.io.in.valid <= UInt<1>("h0") @[ReadyValid.scala 24:11]
          readEnqueuer.io.out[0].ready <= UInt<1>("h0") @[ReadyValid.scala 28:11]
          readEnqueuer.io.out[1].ready <= UInt<1>("h0") @[ReadyValid.scala 28:11]
          io.in.readAddress.ready <= UInt<1>("h0") @[Decoupled.scala 88:20]
          node _T_10 = and(io.out.readAddress.ready, io.out.readAddress.valid) @[Decoupled.scala 50:35]
          when _T_10 : @[MemBoundarySplitter.scala 206:37]
            node _readAddressCounter_T = add(readAddressCounter, availableAddresses) @[MemBoundarySplitter.scala 208:50]
            node _readAddressCounter_T_1 = tail(_readAddressCounter_T, 1) @[MemBoundarySplitter.scala 208:50]
            readAddressCounter <= _readAddressCounter_T_1 @[MemBoundarySplitter.scala 208:28]
            node _readLenCounter_T_2 = add(len, UInt<1>("h1")) @[MemBoundarySplitter.scala 210:49]
            node _readLenCounter_T_3 = tail(_readLenCounter_T_2, 1) @[MemBoundarySplitter.scala 210:49]
            node _readLenCounter_T_4 = sub(readLenCounter, _readLenCounter_T_3) @[MemBoundarySplitter.scala 210:42]
            node _readLenCounter_T_5 = tail(_readLenCounter_T_4, 1) @[MemBoundarySplitter.scala 210:42]
            readLenCounter <= _readLenCounter_T_5 @[MemBoundarySplitter.scala 210:24]
    else :
      readEnqueuer.io.in.valid <= io.in.readAddress.valid @[MultiEnqueue.scala 84:17]
      wire io_in_readAddress_ready_io_out_readAddress_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}} @[ReadyValid.scala 16:17]
      io_in_readAddress_ready_io_out_readAddress_w.bits <= io.in.readAddress.bits @[ReadyValid.scala 17:12]
      io_in_readAddress_ready_io_out_readAddress_w.valid <= readEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
      readEnqueuer.io.out[0].ready <= io_in_readAddress_ready_io_out_readAddress_w.ready @[ReadyValid.scala 19:11]
      io.out.readAddress <= io_in_readAddress_ready_io_out_readAddress_w @[MultiEnqueue.scala 85:10]
      wire io_in_readAddress_ready_readDataQueue_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>} @[ReadyValid.scala 16:17]
      io_in_readAddress_ready_readDataQueue_io_enq_w.bits <= io.in.readAddress.bits.len @[ReadyValid.scala 17:12]
      io_in_readAddress_ready_readDataQueue_io_enq_w.valid <= readEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
      readEnqueuer.io.out[1].ready <= io_in_readAddress_ready_readDataQueue_io_enq_w.ready @[ReadyValid.scala 19:11]
      readDataQueue.io.enq <= io_in_readAddress_ready_readDataQueue_io_enq_w @[MultiEnqueue.scala 86:10]
      io.in.readAddress.ready <= readEnqueuer.io.in.ready @[MemBoundarySplitter.scala 214:29]
    node lengthBytes_1 = mul(io.in.writeAddress.bits.len, UInt<4>("h8")) @[MemBoundarySplitter.scala 105:30]
    node _T_11 = gt(lengthBytes_1, UInt<13>("h1000")) @[MemBoundarySplitter.scala 106:18]
    node _T_12 = rem(io.in.writeAddress.bits.addr, UInt<13>("h1000")) @[MemBoundarySplitter.scala 106:45]
    node _T_13 = sub(UInt<13>("h1001"), lengthBytes_1) @[MemBoundarySplitter.scala 106:79]
    node _T_14 = tail(_T_13, 1) @[MemBoundarySplitter.scala 106:79]
    node _T_15 = gt(_T_12, _T_14) @[MemBoundarySplitter.scala 106:59]
    node _T_16 = or(_T_11, _T_15) @[MemBoundarySplitter.scala 106:32]
    when _T_16 : @[MemBoundarySplitter.scala 224:76]
      node _addr_T_1 = add(io.in.writeAddress.bits.addr, writeAddressCounter) @[MemBoundarySplitter.scala 225:45]
      node addr_1 = tail(_addr_T_1, 1) @[MemBoundarySplitter.scala 225:45]
      node _availableAddresses_T_2 = rem(addr_1, UInt<13>("h1000")) @[MemBoundarySplitter.scala 227:27]
      node _availableAddresses_T_3 = sub(UInt<13>("h1000"), _availableAddresses_T_2) @[MemBoundarySplitter.scala 227:19]
      node availableAddresses_1 = tail(_availableAddresses_T_3, 1) @[MemBoundarySplitter.scala 227:19]
      node availableBeats_1 = div(availableAddresses_1, UInt<4>("h8")) @[MemBoundarySplitter.scala 228:45]
      node _len_T_5 = eq(writeLenCounter, UInt<1>("h0")) @[MemBoundarySplitter.scala 230:23]
      node _len_T_6 = gt(availableBeats_1, writeLenCounter) @[MemBoundarySplitter.scala 109:43]
      node _len_T_7 = mux(_len_T_6, writeLenCounter, availableBeats_1) @[MemBoundarySplitter.scala 109:40]
      node _len_T_8 = mux(_len_T_5, availableBeats_1, _len_T_7) @[MemBoundarySplitter.scala 229:18]
      node _len_T_9 = sub(_len_T_8, UInt<1>("h1")) @[MemBoundarySplitter.scala 233:7]
      node len_1 = tail(_len_T_9, 1) @[MemBoundarySplitter.scala 233:7]
      wire address_1 : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>} @[MemBoundarySplitter.scala 235:23]
      address_1.qos <= io.in.writeAddress.bits.qos @[MemBoundarySplitter.scala 238:11]
      address_1.prot <= io.in.writeAddress.bits.prot @[MemBoundarySplitter.scala 238:11]
      address_1.cache <= io.in.writeAddress.bits.cache @[MemBoundarySplitter.scala 238:11]
      address_1.lock <= io.in.writeAddress.bits.lock @[MemBoundarySplitter.scala 238:11]
      address_1.burst <= io.in.writeAddress.bits.burst @[MemBoundarySplitter.scala 238:11]
      address_1.size <= io.in.writeAddress.bits.size @[MemBoundarySplitter.scala 238:11]
      address_1.len <= io.in.writeAddress.bits.len @[MemBoundarySplitter.scala 238:11]
      address_1.addr <= io.in.writeAddress.bits.addr @[MemBoundarySplitter.scala 238:11]
      address_1.id <= io.in.writeAddress.bits.id @[MemBoundarySplitter.scala 238:11]
      address_1.addr <= addr_1 @[MemBoundarySplitter.scala 241:18]
      address_1.len <= len_1 @[MemBoundarySplitter.scala 242:17]
      node _T_17 = eq(writeLenCounter, UInt<1>("h0")) @[MemBoundarySplitter.scala 244:26]
      when _T_17 : @[MemBoundarySplitter.scala 244:35]
        writeEnqueuer.io.in.valid <= io.in.writeAddress.valid @[MultiEnqueue.scala 114:17]
        wire ready_io_out_writeAddress_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}} @[ReadyValid.scala 16:17]
        ready_io_out_writeAddress_w.bits <= address_1 @[ReadyValid.scala 17:12]
        ready_io_out_writeAddress_w.valid <= writeEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
        writeEnqueuer.io.out[0].ready <= ready_io_out_writeAddress_w.ready @[ReadyValid.scala 19:11]
        io.out.writeAddress <= ready_io_out_writeAddress_w @[MultiEnqueue.scala 115:10]
        wire ready_writeDataQueue_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>} @[ReadyValid.scala 16:17]
        ready_writeDataQueue_io_enq_w.bits <= address_1.len @[ReadyValid.scala 17:12]
        ready_writeDataQueue_io_enq_w.valid <= writeEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
        writeEnqueuer.io.out[1].ready <= ready_writeDataQueue_io_enq_w.ready @[ReadyValid.scala 19:11]
        writeDataQueue.io.enq <= ready_writeDataQueue_io_enq_w @[MultiEnqueue.scala 116:10]
        wire ready_writeResponseQueue_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
        ready_writeResponseQueue_io_enq_w.bits <= UInt<1>("h0") @[ReadyValid.scala 17:12]
        ready_writeResponseQueue_io_enq_w.valid <= writeEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
        writeEnqueuer.io.out[2].ready <= ready_writeResponseQueue_io_enq_w.ready @[ReadyValid.scala 19:11]
        writeResponseQueue.io.enq <= ready_writeResponseQueue_io_enq_w @[MultiEnqueue.scala 117:10]
        io.in.writeAddress.ready <= UInt<1>("h0") @[Decoupled.scala 88:20]
        node _T_18 = and(io.in.writeAddress.valid, writeEnqueuer.io.in.ready) @[MemBoundarySplitter.scala 256:37]
        when _T_18 : @[MemBoundarySplitter.scala 256:47]
          writeAddressCounter <= availableAddresses_1 @[MemBoundarySplitter.scala 257:29]
          node _writeLenCounter_T = sub(io.in.writeAddress.bits.len, len_1) @[MemBoundarySplitter.scala 258:56]
          node _writeLenCounter_T_1 = tail(_writeLenCounter_T, 1) @[MemBoundarySplitter.scala 258:56]
          writeLenCounter <= _writeLenCounter_T_1 @[MemBoundarySplitter.scala 258:25]
      else :
        node _T_19 = leq(writeLenCounter, availableBeats_1) @[MemBoundarySplitter.scala 260:32]
        when _T_19 : @[MemBoundarySplitter.scala 260:51]
          writeEnqueuer.io.in.valid <= io.in.writeAddress.valid @[MultiEnqueue.scala 114:17]
          wire ready_io_out_writeAddress_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}} @[ReadyValid.scala 16:17]
          ready_io_out_writeAddress_w_1.bits <= address_1 @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_1.valid <= writeEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
          writeEnqueuer.io.out[0].ready <= ready_io_out_writeAddress_w_1.ready @[ReadyValid.scala 19:11]
          io.out.writeAddress <= ready_io_out_writeAddress_w_1 @[MultiEnqueue.scala 115:10]
          wire ready_writeDataQueue_io_enq_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>} @[ReadyValid.scala 16:17]
          ready_writeDataQueue_io_enq_w_1.bits <= address_1.len @[ReadyValid.scala 17:12]
          ready_writeDataQueue_io_enq_w_1.valid <= writeEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
          writeEnqueuer.io.out[1].ready <= ready_writeDataQueue_io_enq_w_1.ready @[ReadyValid.scala 19:11]
          writeDataQueue.io.enq <= ready_writeDataQueue_io_enq_w_1 @[MultiEnqueue.scala 116:10]
          wire ready_writeResponseQueue_io_enq_w_1 : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
          ready_writeResponseQueue_io_enq_w_1.bits <= UInt<1>("h1") @[ReadyValid.scala 17:12]
          ready_writeResponseQueue_io_enq_w_1.valid <= writeEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
          writeEnqueuer.io.out[2].ready <= ready_writeResponseQueue_io_enq_w_1.ready @[ReadyValid.scala 19:11]
          writeResponseQueue.io.enq <= ready_writeResponseQueue_io_enq_w_1 @[MultiEnqueue.scala 117:10]
          io.in.writeAddress.ready <= writeEnqueuer.io.in.ready @[MemBoundarySplitter.scala 271:32]
          node _T_20 = and(io.in.writeAddress.valid, writeEnqueuer.io.in.ready) @[MemBoundarySplitter.scala 272:37]
          when _T_20 : @[MemBoundarySplitter.scala 272:47]
            writeAddressCounter <= UInt<1>("h0") @[MemBoundarySplitter.scala 273:29]
            writeLenCounter <= UInt<1>("h0") @[MemBoundarySplitter.scala 274:25]
        else :
          writeEnqueuer.io.in.valid <= io.in.writeAddress.valid @[MultiEnqueue.scala 114:17]
          wire ready_io_out_writeAddress_w_2 : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}} @[ReadyValid.scala 16:17]
          ready_io_out_writeAddress_w_2.bits <= address_1 @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_2.valid <= writeEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
          writeEnqueuer.io.out[0].ready <= ready_io_out_writeAddress_w_2.ready @[ReadyValid.scala 19:11]
          io.out.writeAddress <= ready_io_out_writeAddress_w_2 @[MultiEnqueue.scala 115:10]
          wire ready_writeDataQueue_io_enq_w_2 : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>} @[ReadyValid.scala 16:17]
          ready_writeDataQueue_io_enq_w_2.bits <= address_1.len @[ReadyValid.scala 17:12]
          ready_writeDataQueue_io_enq_w_2.valid <= writeEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
          writeEnqueuer.io.out[1].ready <= ready_writeDataQueue_io_enq_w_2.ready @[ReadyValid.scala 19:11]
          writeDataQueue.io.enq <= ready_writeDataQueue_io_enq_w_2 @[MultiEnqueue.scala 116:10]
          wire ready_writeResponseQueue_io_enq_w_2 : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
          ready_writeResponseQueue_io_enq_w_2.bits <= UInt<1>("h0") @[ReadyValid.scala 17:12]
          ready_writeResponseQueue_io_enq_w_2.valid <= writeEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
          writeEnqueuer.io.out[2].ready <= ready_writeResponseQueue_io_enq_w_2.ready @[ReadyValid.scala 19:11]
          writeResponseQueue.io.enq <= ready_writeResponseQueue_io_enq_w_2 @[MultiEnqueue.scala 117:10]
          io.in.writeAddress.ready <= UInt<1>("h0") @[Decoupled.scala 88:20]
          node _T_21 = and(io.in.writeAddress.valid, writeEnqueuer.io.in.ready) @[MemBoundarySplitter.scala 288:37]
          when _T_21 : @[MemBoundarySplitter.scala 288:47]
            node _writeAddressCounter_T = add(writeAddressCounter, availableAddresses_1) @[MemBoundarySplitter.scala 290:52]
            node _writeAddressCounter_T_1 = tail(_writeAddressCounter_T, 1) @[MemBoundarySplitter.scala 290:52]
            writeAddressCounter <= _writeAddressCounter_T_1 @[MemBoundarySplitter.scala 290:29]
            node _writeLenCounter_T_2 = add(len_1, UInt<1>("h1")) @[MemBoundarySplitter.scala 292:51]
            node _writeLenCounter_T_3 = tail(_writeLenCounter_T_2, 1) @[MemBoundarySplitter.scala 292:51]
            node _writeLenCounter_T_4 = sub(writeLenCounter, _writeLenCounter_T_3) @[MemBoundarySplitter.scala 292:44]
            node _writeLenCounter_T_5 = tail(_writeLenCounter_T_4, 1) @[MemBoundarySplitter.scala 292:44]
            writeLenCounter <= _writeLenCounter_T_5 @[MemBoundarySplitter.scala 292:25]
    else :
      writeEnqueuer.io.in.valid <= io.in.writeAddress.valid @[MultiEnqueue.scala 114:17]
      wire io_in_writeAddress_ready_io_out_writeAddress_w : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}} @[ReadyValid.scala 16:17]
      io_in_writeAddress_ready_io_out_writeAddress_w.bits <= io.in.writeAddress.bits @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_io_out_writeAddress_w.valid <= writeEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
      writeEnqueuer.io.out[0].ready <= io_in_writeAddress_ready_io_out_writeAddress_w.ready @[ReadyValid.scala 19:11]
      io.out.writeAddress <= io_in_writeAddress_ready_io_out_writeAddress_w @[MultiEnqueue.scala 115:10]
      wire io_in_writeAddress_ready_writeDataQueue_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>} @[ReadyValid.scala 16:17]
      io_in_writeAddress_ready_writeDataQueue_io_enq_w.bits <= io.in.writeAddress.bits.len @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_writeDataQueue_io_enq_w.valid <= writeEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
      writeEnqueuer.io.out[1].ready <= io_in_writeAddress_ready_writeDataQueue_io_enq_w.ready @[ReadyValid.scala 19:11]
      writeDataQueue.io.enq <= io_in_writeAddress_ready_writeDataQueue_io_enq_w @[MultiEnqueue.scala 116:10]
      wire io_in_writeAddress_ready_writeResponseQueue_io_enq_w : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
      io_in_writeAddress_ready_writeResponseQueue_io_enq_w.bits <= UInt<1>("h1") @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_writeResponseQueue_io_enq_w.valid <= writeEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
      writeEnqueuer.io.out[2].ready <= io_in_writeAddress_ready_writeResponseQueue_io_enq_w.ready @[ReadyValid.scala 19:11]
      writeResponseQueue.io.enq <= io_in_writeAddress_ready_writeResponseQueue_io_enq_w @[MultiEnqueue.scala 117:10]
      io.in.writeAddress.ready <= writeEnqueuer.io.in.ready @[MemBoundarySplitter.scala 296:30]

  module Queue_36 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>}}, count : UInt<2>}

    cmem ram : { write : UInt<1>, address : UInt<20>, size : UInt<20>} [2] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module RequestSplitter :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>}}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>}}}

    wire _sizeCounter_WIRE : UInt<20> @[package.scala 72:41]
    _sizeCounter_WIRE <= UInt<1>("h0") @[package.scala 72:41]
    reg sizeCounter : UInt, clock with :
      reset => (reset, _sizeCounter_WIRE) @[RequestSplitter.scala 21:33]
    reg sizeCounterValid : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[RequestSplitter.scala 22:33]
    wire _addressOffset_WIRE : UInt<20> @[package.scala 72:41]
    _addressOffset_WIRE <= UInt<1>("h0") @[package.scala 72:41]
    reg addressOffset : UInt, clock with :
      reset => (reset, _addressOffset_WIRE) @[RequestSplitter.scala 23:33]
    node _address_T = add(io.in.bits.address, addressOffset) @[RequestSplitter.scala 24:42]
    node address = tail(_address_T, 1) @[RequestSplitter.scala 24:42]
    node _T = lt(io.in.bits.size, UInt<8>("h80")) @[RequestSplitter.scala 26:21]
    when _T : @[RequestSplitter.scala 26:34]
      io.out <= io.in @[RequestSplitter.scala 27:12]
    else :
      node _T_1 = lt(sizeCounter, UInt<8>("h80")) @[RequestSplitter.scala 29:42]
      node _T_2 = and(sizeCounterValid, _T_1) @[RequestSplitter.scala 29:27]
      when _T_2 : @[RequestSplitter.scala 29:55]
        wire io_out_bits_w : { write : UInt<1>, address : UInt<20>, size : UInt<20>} @[MemControl.scala 98:19]
        io_out_bits_w.address <= address @[MemControl.scala 99:17]
        io_out_bits_w.write <= io.in.bits.write @[MemControl.scala 100:15]
        io_out_bits_w.size <= sizeCounter @[MemControl.scala 101:14]
        io.out.bits <= io_out_bits_w @[RequestSplitter.scala 30:19]
        io.out.valid <= io.in.valid @[RequestSplitter.scala 36:20]
        io.in.ready <= io.out.ready @[RequestSplitter.scala 37:16]
        node _T_3 = and(io.in.valid, io.out.ready) @[RequestSplitter.scala 38:21]
        when _T_3 : @[RequestSplitter.scala 38:38]
          sizeCounterValid <= UInt<1>("h0") @[RequestSplitter.scala 39:26]
          addressOffset <= UInt<1>("h0") @[RequestSplitter.scala 40:23]
      else :
        wire io_out_bits_w_1 : { write : UInt<1>, address : UInt<20>, size : UInt<20>} @[MemControl.scala 98:19]
        io_out_bits_w_1.address <= address @[MemControl.scala 99:17]
        io_out_bits_w_1.write <= io.in.bits.write @[MemControl.scala 100:15]
        io_out_bits_w_1.size <= UInt<7>("h7f") @[MemControl.scala 101:14]
        io.out.bits <= io_out_bits_w_1 @[RequestSplitter.scala 43:19]
        io.out.valid <= io.in.valid @[RequestSplitter.scala 49:20]
        io.in.ready <= UInt<1>("h0") @[RequestSplitter.scala 50:16]
        node _T_4 = and(io.in.valid, io.out.ready) @[RequestSplitter.scala 51:21]
        when _T_4 : @[RequestSplitter.scala 51:38]
          when sizeCounterValid : @[RequestSplitter.scala 52:32]
            node _sizeCounter_T = sub(sizeCounter, UInt<8>("h80")) @[RequestSplitter.scala 53:38]
            node _sizeCounter_T_1 = tail(_sizeCounter_T, 1) @[RequestSplitter.scala 53:38]
            sizeCounter <= _sizeCounter_T_1 @[RequestSplitter.scala 53:23]
            node _addressOffset_T = add(addressOffset, UInt<8>("h80")) @[RequestSplitter.scala 54:42]
            node _addressOffset_T_1 = tail(_addressOffset_T, 1) @[RequestSplitter.scala 54:42]
            addressOffset <= _addressOffset_T_1 @[RequestSplitter.scala 54:25]
          else :
            node _sizeCounter_T_2 = sub(io.in.bits.size, UInt<8>("h80")) @[RequestSplitter.scala 56:39]
            node _sizeCounter_T_3 = tail(_sizeCounter_T_2, 1) @[RequestSplitter.scala 56:39]
            sizeCounter <= _sizeCounter_T_3 @[RequestSplitter.scala 56:23]
            addressOffset <= UInt<8>("h80") @[RequestSplitter.scala 57:25]
            sizeCounterValid <= UInt<1>("h1") @[RequestSplitter.scala 58:28]

  module Queue_37 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, count : UInt<2>}

    cmem ram : Fixed<16><<8>>[8] [2] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Queue_38 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}, count : UInt<2>}

    cmem ram : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>} [2] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Queue_39 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, resp : UInt<2>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, resp : UInt<2>}}, count : UInt<2>}

    cmem ram : { id : UInt<6>, resp : UInt<2>} [2] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module VectorSerializer :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}}

    wire _bits_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_1 = asFixedPoint(_bits_T, 8) @[package.scala 74:56]
    _bits_WIRE <= _bits_T_1 @[package.scala 74:56]
    wire _bits_WIRE_1 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_2 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_3 = asFixedPoint(_bits_T_2, 8) @[package.scala 74:56]
    _bits_WIRE_1 <= _bits_T_3 @[package.scala 74:56]
    wire _bits_WIRE_2 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_4 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_5 = asFixedPoint(_bits_T_4, 8) @[package.scala 74:56]
    _bits_WIRE_2 <= _bits_T_5 @[package.scala 74:56]
    wire _bits_WIRE_3 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_6 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_7 = asFixedPoint(_bits_T_6, 8) @[package.scala 74:56]
    _bits_WIRE_3 <= _bits_T_7 @[package.scala 74:56]
    wire _bits_WIRE_4 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_8 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_9 = asFixedPoint(_bits_T_8, 8) @[package.scala 74:56]
    _bits_WIRE_4 <= _bits_T_9 @[package.scala 74:56]
    wire _bits_WIRE_5 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_10 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_11 = asFixedPoint(_bits_T_10, 8) @[package.scala 74:56]
    _bits_WIRE_5 <= _bits_T_11 @[package.scala 74:56]
    wire _bits_WIRE_6 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_12 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_13 = asFixedPoint(_bits_T_12, 8) @[package.scala 74:56]
    _bits_WIRE_6 <= _bits_T_13 @[package.scala 74:56]
    wire _bits_WIRE_7 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_14 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_15 = asFixedPoint(_bits_T_14, 8) @[package.scala 74:56]
    _bits_WIRE_7 <= _bits_T_15 @[package.scala 74:56]
    wire _bits_WIRE_8 : Fixed<16><<8>>[8] @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[0] <= _bits_WIRE @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[1] <= _bits_WIRE_1 @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[2] <= _bits_WIRE_2 @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[3] <= _bits_WIRE_3 @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[4] <= _bits_WIRE_4 @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[5] <= _bits_WIRE_5 @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[6] <= _bits_WIRE_6 @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[7] <= _bits_WIRE_7 @[VectorSerializer.scala 37:30]
    reg bits : Fixed<16><<8>>[8], clock with :
      reset => (reset, _bits_WIRE_8) @[VectorSerializer.scala 37:22]
    reg valid : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[VectorSerializer.scala 38:22]
    node _T = and(valid, io.out.ready) @[VectorSerializer.scala 40:48]
    reg ctr : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    wire wrap : UInt<1>
    wrap <= UInt<1>("h0")
    when _T : @[Counter.scala 120:16]
      node wrap_wrap = eq(ctr, UInt<1>("h1")) @[Counter.scala 74:24]
      node _wrap_value_T = add(ctr, UInt<1>("h1")) @[Counter.scala 78:24]
      node _wrap_value_T_1 = tail(_wrap_value_T, 1) @[Counter.scala 78:24]
      ctr <= _wrap_value_T_1 @[Counter.scala 78:15]
      wrap <= wrap_wrap @[Counter.scala 120:23]
    node _out_T = mul(ctr, UInt<3>("h4")) @[VectorSerializer.scala 46:18]
    node _out_T_1 = add(_out_T, UInt<1>("h0")) @[VectorSerializer.scala 46:40]
    node _out_T_2 = tail(_out_T_1, 1) @[VectorSerializer.scala 46:40]
    node _out_T_3 = bits(_out_T_2, 2, 0)
    node _out_T_4 = asUInt(bits[_out_T_3]) @[VectorSerializer.scala 46:47]
    wire out_0 : UInt<16> @[Extend.scala 40:17]
    out_0 <= _out_T_4 @[Extend.scala 41:7]
    node _out_T_5 = mul(ctr, UInt<3>("h4")) @[VectorSerializer.scala 46:18]
    node _out_T_6 = add(_out_T_5, UInt<1>("h1")) @[VectorSerializer.scala 46:40]
    node _out_T_7 = tail(_out_T_6, 1) @[VectorSerializer.scala 46:40]
    node _out_T_8 = bits(_out_T_7, 2, 0)
    node _out_T_9 = asUInt(bits[_out_T_8]) @[VectorSerializer.scala 46:47]
    wire out_1 : UInt<16> @[Extend.scala 40:17]
    out_1 <= _out_T_9 @[Extend.scala 41:7]
    node _out_T_10 = mul(ctr, UInt<3>("h4")) @[VectorSerializer.scala 46:18]
    node _out_T_11 = add(_out_T_10, UInt<2>("h2")) @[VectorSerializer.scala 46:40]
    node _out_T_12 = tail(_out_T_11, 1) @[VectorSerializer.scala 46:40]
    node _out_T_13 = bits(_out_T_12, 2, 0)
    node _out_T_14 = asUInt(bits[_out_T_13]) @[VectorSerializer.scala 46:47]
    wire out_2 : UInt<16> @[Extend.scala 40:17]
    out_2 <= _out_T_14 @[Extend.scala 41:7]
    node _out_T_15 = mul(ctr, UInt<3>("h4")) @[VectorSerializer.scala 46:18]
    node _out_T_16 = add(_out_T_15, UInt<2>("h3")) @[VectorSerializer.scala 46:40]
    node _out_T_17 = tail(_out_T_16, 1) @[VectorSerializer.scala 46:40]
    node _out_T_18 = bits(_out_T_17, 2, 0)
    node _out_T_19 = asUInt(bits[_out_T_18]) @[VectorSerializer.scala 46:47]
    wire out_3 : UInt<16> @[Extend.scala 40:17]
    out_3 <= _out_T_19 @[Extend.scala 41:7]
    io.out.valid <= valid @[VectorSerializer.scala 50:16]
    node io_out_bits_lo = cat(out_1, out_0) @[Cat.scala 31:58]
    node io_out_bits_hi = cat(out_3, out_2) @[Cat.scala 31:58]
    node _io_out_bits_T = cat(io_out_bits_hi, io_out_bits_lo) @[Cat.scala 31:58]
    wire _io_out_bits_WIRE : UInt<64> @[VectorSerializer.scala 51:43]
    _io_out_bits_WIRE <= _io_out_bits_T @[VectorSerializer.scala 51:43]
    io.out.bits <= _io_out_bits_WIRE @[VectorSerializer.scala 51:15]
    node _io_in_ready_T = eq(valid, UInt<1>("h0")) @[VectorSerializer.scala 52:18]
    node _io_in_ready_T_1 = or(_io_in_ready_T, wrap) @[VectorSerializer.scala 52:25]
    io.in.ready <= _io_in_ready_T_1 @[VectorSerializer.scala 52:15]
    when io.in.ready : @[VectorSerializer.scala 54:21]
      when io.in.valid : @[VectorSerializer.scala 55:23]
        wire _WIRE : Fixed<16><<8>>[8] @[VectorSerializer.scala 56:34]
        node _T_1 = asUInt(io.in.bits[0]) @[VectorSerializer.scala 56:34]
        node _T_2 = asUInt(io.in.bits[1]) @[VectorSerializer.scala 56:34]
        node _T_3 = asUInt(io.in.bits[2]) @[VectorSerializer.scala 56:34]
        node _T_4 = asUInt(io.in.bits[3]) @[VectorSerializer.scala 56:34]
        node _T_5 = asUInt(io.in.bits[4]) @[VectorSerializer.scala 56:34]
        node _T_6 = asUInt(io.in.bits[5]) @[VectorSerializer.scala 56:34]
        node _T_7 = asUInt(io.in.bits[6]) @[VectorSerializer.scala 56:34]
        node _T_8 = asUInt(io.in.bits[7]) @[VectorSerializer.scala 56:34]
        node lo_lo = cat(_T_2, _T_1) @[VectorSerializer.scala 56:34]
        node lo_hi = cat(_T_4, _T_3) @[VectorSerializer.scala 56:34]
        node lo = cat(lo_hi, lo_lo) @[VectorSerializer.scala 56:34]
        node hi_lo = cat(_T_6, _T_5) @[VectorSerializer.scala 56:34]
        node hi_hi = cat(_T_8, _T_7) @[VectorSerializer.scala 56:34]
        node hi = cat(hi_hi, hi_lo) @[VectorSerializer.scala 56:34]
        node _T_9 = cat(hi, lo) @[VectorSerializer.scala 56:34]
        wire _WIRE_1 : UInt<128>
        _WIRE_1 <= _T_9
        node _T_10 = bits(_WIRE_1, 15, 0) @[VectorSerializer.scala 56:34]
        node _T_11 = asFixedPoint(_T_10, 8) @[VectorSerializer.scala 56:34]
        _WIRE[0] <= _T_11 @[VectorSerializer.scala 56:34]
        node _T_12 = bits(_WIRE_1, 31, 16) @[VectorSerializer.scala 56:34]
        node _T_13 = asFixedPoint(_T_12, 8) @[VectorSerializer.scala 56:34]
        _WIRE[1] <= _T_13 @[VectorSerializer.scala 56:34]
        node _T_14 = bits(_WIRE_1, 47, 32) @[VectorSerializer.scala 56:34]
        node _T_15 = asFixedPoint(_T_14, 8) @[VectorSerializer.scala 56:34]
        _WIRE[2] <= _T_15 @[VectorSerializer.scala 56:34]
        node _T_16 = bits(_WIRE_1, 63, 48) @[VectorSerializer.scala 56:34]
        node _T_17 = asFixedPoint(_T_16, 8) @[VectorSerializer.scala 56:34]
        _WIRE[3] <= _T_17 @[VectorSerializer.scala 56:34]
        node _T_18 = bits(_WIRE_1, 79, 64) @[VectorSerializer.scala 56:34]
        node _T_19 = asFixedPoint(_T_18, 8) @[VectorSerializer.scala 56:34]
        _WIRE[4] <= _T_19 @[VectorSerializer.scala 56:34]
        node _T_20 = bits(_WIRE_1, 95, 80) @[VectorSerializer.scala 56:34]
        node _T_21 = asFixedPoint(_T_20, 8) @[VectorSerializer.scala 56:34]
        _WIRE[5] <= _T_21 @[VectorSerializer.scala 56:34]
        node _T_22 = bits(_WIRE_1, 111, 96) @[VectorSerializer.scala 56:34]
        node _T_23 = asFixedPoint(_T_22, 8) @[VectorSerializer.scala 56:34]
        _WIRE[6] <= _T_23 @[VectorSerializer.scala 56:34]
        node _T_24 = bits(_WIRE_1, 127, 112) @[VectorSerializer.scala 56:34]
        node _T_25 = asFixedPoint(_T_24, 8) @[VectorSerializer.scala 56:34]
        _WIRE[7] <= _T_25 @[VectorSerializer.scala 56:34]
        bits <= _WIRE @[VectorSerializer.scala 56:12]
        valid <= UInt<1>("h1") @[VectorSerializer.scala 57:13]
      else :
        valid <= UInt<1>("h0") @[VectorSerializer.scala 59:13]

  module Counter_14 :
    input clock : Clock
    input reset : Reset
    output io : { value : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, flip resetValue : UInt<1>}

    reg value : UInt<8>, clock with :
      reset => (reset, UInt<8>("h0")) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h0")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<8>("hff")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h0") @[Counter.scala 22:13]
      else :
        node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h0") @[Counter.scala 28:11]

  module DataCounter :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}, flip len : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, last : UInt<1>}

    inst counter of Counter_14 @[Counter.scala 34:19]
    counter.clock <= clock
    counter.reset <= reset
    counter.io.resetValue <= UInt<1>("h0") @[Counter.scala 35:21]
    counter.io.value.ready <= UInt<1>("h0") @[Counter.scala 36:22]
    io.out.bits <= io.in.bits @[DataCounter.scala 25:15]
    node _io_out_valid_T = and(io.in.valid, io.len.valid) @[DataCounter.scala 26:28]
    io.out.valid <= _io_out_valid_T @[DataCounter.scala 26:16]
    node _io_in_ready_T = and(io.len.valid, io.out.ready) @[DataCounter.scala 27:25]
    io.in.ready <= _io_in_ready_T @[DataCounter.scala 27:12]
    node _T = eq(counter.io.value.bits, io.len.bits) @[DataCounter.scala 29:30]
    when _T : @[DataCounter.scala 29:44]
      node _io_last_T = and(io.in.valid, io.len.valid) @[DataCounter.scala 30:25]
      io.last <= _io_last_T @[DataCounter.scala 30:13]
      node _io_len_ready_T = and(io.in.valid, io.out.ready) @[DataCounter.scala 31:27]
      io.len.ready <= _io_len_ready_T @[DataCounter.scala 31:15]
      node _counter_io_resetValue_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 50:35]
      counter.io.resetValue <= _counter_io_resetValue_T @[DataCounter.scala 32:27]
    else :
      io.len.ready <= UInt<1>("h0") @[DataCounter.scala 34:15]
      io.last <= UInt<1>("h0") @[DataCounter.scala 35:13]
      node _counter_io_value_ready_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 50:35]
      counter.io.value.ready <= _counter_io_value_ready_T @[DataCounter.scala 36:28]

  module VectorDeserializer :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}

    wire _bits_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_1 = asFixedPoint(_bits_T, 8) @[package.scala 74:56]
    _bits_WIRE <= _bits_T_1 @[package.scala 74:56]
    wire _bits_WIRE_1 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_2 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_3 = asFixedPoint(_bits_T_2, 8) @[package.scala 74:56]
    _bits_WIRE_1 <= _bits_T_3 @[package.scala 74:56]
    wire _bits_WIRE_2 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_4 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_5 = asFixedPoint(_bits_T_4, 8) @[package.scala 74:56]
    _bits_WIRE_2 <= _bits_T_5 @[package.scala 74:56]
    wire _bits_WIRE_3 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_6 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_7 = asFixedPoint(_bits_T_6, 8) @[package.scala 74:56]
    _bits_WIRE_3 <= _bits_T_7 @[package.scala 74:56]
    wire _bits_WIRE_4 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_8 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_9 = asFixedPoint(_bits_T_8, 8) @[package.scala 74:56]
    _bits_WIRE_4 <= _bits_T_9 @[package.scala 74:56]
    wire _bits_WIRE_5 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_10 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_11 = asFixedPoint(_bits_T_10, 8) @[package.scala 74:56]
    _bits_WIRE_5 <= _bits_T_11 @[package.scala 74:56]
    wire _bits_WIRE_6 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_12 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_13 = asFixedPoint(_bits_T_12, 8) @[package.scala 74:56]
    _bits_WIRE_6 <= _bits_T_13 @[package.scala 74:56]
    wire _bits_WIRE_7 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_14 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_15 = asFixedPoint(_bits_T_14, 8) @[package.scala 74:56]
    _bits_WIRE_7 <= _bits_T_15 @[package.scala 74:56]
    wire _bits_WIRE_8 : Fixed<16><<8>>[8] @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[0] <= _bits_WIRE @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[1] <= _bits_WIRE_1 @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[2] <= _bits_WIRE_2 @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[3] <= _bits_WIRE_3 @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[4] <= _bits_WIRE_4 @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[5] <= _bits_WIRE_5 @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[6] <= _bits_WIRE_6 @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[7] <= _bits_WIRE_7 @[VectorDeserializer.scala 41:32]
    reg bits : Fixed<16><<8>>[8], clock with :
      reset => (reset, _bits_WIRE_8) @[VectorDeserializer.scala 41:24]
    reg valid : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[VectorDeserializer.scala 42:24]
    node _T = and(io.in.ready, io.in.valid) @[Decoupled.scala 50:35]
    reg ctr : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    wire wrap : UInt<1>
    wrap <= UInt<1>("h0")
    when _T : @[Counter.scala 120:16]
      node wrap_wrap = eq(ctr, UInt<1>("h1")) @[Counter.scala 74:24]
      node _wrap_value_T = add(ctr, UInt<1>("h1")) @[Counter.scala 78:24]
      node _wrap_value_T_1 = tail(_wrap_value_T, 1) @[Counter.scala 78:24]
      ctr <= _wrap_value_T_1 @[Counter.scala 78:15]
      wrap <= wrap_wrap @[Counter.scala 120:23]
    io.out.valid <= valid @[VectorDeserializer.scala 47:18]
    io.out.bits <= bits @[VectorDeserializer.scala 48:17]
    node _io_in_ready_T = eq(valid, UInt<1>("h0")) @[VectorDeserializer.scala 50:20]
    node _io_in_ready_T_1 = or(_io_in_ready_T, io.out.ready) @[VectorDeserializer.scala 50:27]
    io.in.ready <= _io_in_ready_T_1 @[VectorDeserializer.scala 50:17]
    node _T_1 = and(io.in.ready, io.in.valid) @[Decoupled.scala 50:35]
    when _T_1 : @[VectorDeserializer.scala 52:22]
      node _T_2 = mul(ctr, UInt<3>("h4")) @[VectorDeserializer.scala 54:18]
      node _T_3 = add(_T_2, UInt<1>("h0")) @[VectorDeserializer.scala 54:40]
      node _T_4 = tail(_T_3, 1) @[VectorDeserializer.scala 54:40]
      node _T_5 = bits(_T_4, 2, 0)
      node _bits_T_16 = bits(io.in.bits, 15, 0) @[VectorDeserializer.scala 55:30]
      wire bits_w : UInt<16> @[Extend.scala 40:17]
      bits_w <= _bits_T_16 @[Extend.scala 41:7]
      wire _bits_WIRE_9 : Fixed<16><<8>> @[VectorDeserializer.scala 37:57]
      node _bits_T_17 = asFixedPoint(bits_w, 8) @[VectorDeserializer.scala 37:57]
      _bits_WIRE_9 <= _bits_T_17 @[VectorDeserializer.scala 37:57]
      bits[_T_5] <= _bits_WIRE_9 @[VectorDeserializer.scala 54:47]
      node _T_6 = mul(ctr, UInt<3>("h4")) @[VectorDeserializer.scala 54:18]
      node _T_7 = add(_T_6, UInt<1>("h1")) @[VectorDeserializer.scala 54:40]
      node _T_8 = tail(_T_7, 1) @[VectorDeserializer.scala 54:40]
      node _T_9 = bits(_T_8, 2, 0)
      node _bits_T_18 = bits(io.in.bits, 31, 16) @[VectorDeserializer.scala 55:30]
      wire bits_w_1 : UInt<16> @[Extend.scala 40:17]
      bits_w_1 <= _bits_T_18 @[Extend.scala 41:7]
      wire _bits_WIRE_10 : Fixed<16><<8>> @[VectorDeserializer.scala 37:57]
      node _bits_T_19 = asFixedPoint(bits_w_1, 8) @[VectorDeserializer.scala 37:57]
      _bits_WIRE_10 <= _bits_T_19 @[VectorDeserializer.scala 37:57]
      bits[_T_9] <= _bits_WIRE_10 @[VectorDeserializer.scala 54:47]
      node _T_10 = mul(ctr, UInt<3>("h4")) @[VectorDeserializer.scala 54:18]
      node _T_11 = add(_T_10, UInt<2>("h2")) @[VectorDeserializer.scala 54:40]
      node _T_12 = tail(_T_11, 1) @[VectorDeserializer.scala 54:40]
      node _T_13 = bits(_T_12, 2, 0)
      node _bits_T_20 = bits(io.in.bits, 47, 32) @[VectorDeserializer.scala 55:30]
      wire bits_w_2 : UInt<16> @[Extend.scala 40:17]
      bits_w_2 <= _bits_T_20 @[Extend.scala 41:7]
      wire _bits_WIRE_11 : Fixed<16><<8>> @[VectorDeserializer.scala 37:57]
      node _bits_T_21 = asFixedPoint(bits_w_2, 8) @[VectorDeserializer.scala 37:57]
      _bits_WIRE_11 <= _bits_T_21 @[VectorDeserializer.scala 37:57]
      bits[_T_13] <= _bits_WIRE_11 @[VectorDeserializer.scala 54:47]
      node _T_14 = mul(ctr, UInt<3>("h4")) @[VectorDeserializer.scala 54:18]
      node _T_15 = add(_T_14, UInt<2>("h3")) @[VectorDeserializer.scala 54:40]
      node _T_16 = tail(_T_15, 1) @[VectorDeserializer.scala 54:40]
      node _T_17 = bits(_T_16, 2, 0)
      node _bits_T_22 = bits(io.in.bits, 63, 48) @[VectorDeserializer.scala 55:30]
      wire bits_w_3 : UInt<16> @[Extend.scala 40:17]
      bits_w_3 <= _bits_T_22 @[Extend.scala 41:7]
      wire _bits_WIRE_12 : Fixed<16><<8>> @[VectorDeserializer.scala 37:57]
      node _bits_T_23 = asFixedPoint(bits_w_3, 8) @[VectorDeserializer.scala 37:57]
      _bits_WIRE_12 <= _bits_T_23 @[VectorDeserializer.scala 37:57]
      bits[_T_17] <= _bits_WIRE_12 @[VectorDeserializer.scala 54:47]
      valid <= wrap @[VectorDeserializer.scala 61:13]
    node _T_18 = and(io.out.ready, io.out.valid) @[Decoupled.scala 50:35]
    when _T_18 : @[VectorDeserializer.scala 63:23]
      valid <= UInt<1>("h0") @[VectorDeserializer.scala 64:13]

  module MultiEnqueue_21 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>}[2]}

    reg enq_0 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node allEnqueued = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_1 = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]

  module Converter :
    input clock : Clock
    input reset : Reset
    output io : { mem : { flip control : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>}}, dataIn : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip dataOut : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, axi : { writeAddress : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, writeData : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, flip writeResponse : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, resp : UInt<2>}}, readAddress : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, flip readData : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}, flip addressOffset : UInt<32>, flip cacheBehavior : UInt<4>, flip timeout : UInt<1>, flip tracepoint : UInt<1>, flip programCounter : UInt<32>}

    inst control_q of Queue_36 @[Converter.scala 65:25]
    control_q.clock <= clock
    control_q.reset <= reset
    control_q.io.enq <= io.mem.control @[Converter.scala 65:25]
    inst control_splitter of RequestSplitter @[RequestSplitter.scala 69:26]
    control_splitter.clock <= clock
    control_splitter.reset <= reset
    control_splitter.io.in <= control_q.io.deq @[RequestSplitter.scala 70:20]
    inst dataOut of Queue_37 @[Converter.scala 67:41]
    dataOut.clock <= clock
    dataOut.reset <= reset
    dataOut.io.enq <= io.mem.dataOut @[Converter.scala 67:41]
    inst readData of Queue_38 @[Converter.scala 68:41]
    readData.clock <= clock
    readData.reset <= reset
    readData.io.enq <= io.axi.readData @[Converter.scala 68:41]
    inst writeResponse of Queue_39 @[Converter.scala 69:41]
    writeResponse.clock <= clock
    writeResponse.reset <= reset
    writeResponse.io.enq <= io.axi.writeResponse @[Converter.scala 69:41]
    node address = mul(control_splitter.io.out.bits.address, UInt<5>("h10")) @[Converter.scala 78:26]
    node _size_T = add(control_splitter.io.out.bits.size, UInt<1>("h1")) @[Converter.scala 81:24]
    node _size_T_1 = tail(_size_T, 1) @[Converter.scala 81:24]
    node _size_T_2 = mul(_size_T_1, UInt<2>("h2")) @[Converter.scala 81:31]
    node _size_T_3 = sub(_size_T_2, UInt<1>("h1")) @[Converter.scala 81:68]
    node size = tail(_size_T_3, 1) @[Converter.scala 81:68]
    inst ser of VectorSerializer @[Converter.scala 89:19]
    ser.clock <= clock
    ser.reset <= reset
    ser.io.in <= dataOut.io.deq @[Converter.scala 97:13]
    inst serCounter of DataCounter @[Converter.scala 99:26]
    serCounter.clock <= clock
    serCounter.reset <= reset
    serCounter.io.in <= ser.io.out @[Converter.scala 102:20]
    serCounter.io.len.bits <= size @[Converter.scala 103:26]
    serCounter.io.len.valid <= UInt<1>("h0") @[Converter.scala 104:27]
    inst des of VectorDeserializer @[Converter.scala 108:19]
    des.clock <= clock
    des.reset <= reset
    io.mem.dataIn.bits <= des.io.out.bits @[Converter.scala 116:17]
    io.mem.dataIn.valid <= des.io.out.valid @[Converter.scala 116:17]
    des.io.out.ready <= io.mem.dataIn.ready @[Converter.scala 116:17]
    reg writeResponseCount : UInt<8>, clock with :
      reset => (reset, UInt<8>("h0")) @[Converter.scala 123:35]
    reg readResponseCount : UInt<8>, clock with :
      reset => (reset, UInt<8>("h0")) @[Converter.scala 124:35]
    node _canWrite_T = eq(readResponseCount, UInt<1>("h0")) @[Converter.scala 126:24]
    node _canWrite_T_1 = lt(writeResponseCount, UInt<8>("hff")) @[Converter.scala 126:56]
    node canWrite = and(_canWrite_T, _canWrite_T_1) @[Converter.scala 126:33]
    node _canRead_T = eq(writeResponseCount, UInt<1>("h0")) @[Converter.scala 128:25]
    node _canRead_T_1 = lt(readResponseCount, UInt<8>("hff")) @[Converter.scala 128:56]
    node canRead = and(_canRead_T, _canRead_T_1) @[Converter.scala 128:34]
    node writeRequested = and(io.axi.writeAddress.ready, io.axi.writeAddress.valid) @[Converter.scala 129:50]
    node writeResponded = and(writeResponse.io.deq.ready, writeResponse.io.deq.valid) @[Converter.scala 130:44]
    node readRequested = and(io.axi.readAddress.ready, io.axi.readAddress.valid) @[Converter.scala 131:49]
    node _readResponded_T = and(readData.io.deq.ready, readData.io.deq.valid) @[Converter.scala 132:39]
    node readResponded = and(_readResponded_T, readData.io.deq.bits.last) @[Converter.scala 132:57]
    when writeRequested : @[Converter.scala 133:24]
      when writeResponded : @[Converter.scala 134:26]
        skip
      else :
        node _T = lt(writeResponseCount, UInt<8>("hff")) @[Converter.scala 137:31]
        when _T : @[Converter.scala 137:62]
          node _writeResponseCount_T = add(writeResponseCount, UInt<1>("h1")) @[Converter.scala 138:50]
          node _writeResponseCount_T_1 = tail(_writeResponseCount_T, 1) @[Converter.scala 138:50]
          writeResponseCount <= _writeResponseCount_T_1 @[Converter.scala 138:28]
    else :
      node _T_1 = gt(writeResponseCount, UInt<1>("h0")) @[Converter.scala 142:47]
      node _T_2 = and(writeResponded, _T_1) @[Converter.scala 142:25]
      when _T_2 : @[Converter.scala 142:54]
        node _writeResponseCount_T_2 = sub(writeResponseCount, UInt<1>("h1")) @[Converter.scala 143:48]
        node _writeResponseCount_T_3 = tail(_writeResponseCount_T_2, 1) @[Converter.scala 143:48]
        writeResponseCount <= _writeResponseCount_T_3 @[Converter.scala 143:26]
      else :
        skip
    when readRequested : @[Converter.scala 148:23]
      when readResponded : @[Converter.scala 149:25]
        skip
      else :
        node _T_3 = lt(readResponseCount, UInt<8>("hff")) @[Converter.scala 152:30]
        when _T_3 : @[Converter.scala 152:61]
          node _readResponseCount_T = add(readResponseCount, UInt<1>("h1")) @[Converter.scala 153:48]
          node _readResponseCount_T_1 = tail(_readResponseCount_T, 1) @[Converter.scala 153:48]
          readResponseCount <= _readResponseCount_T_1 @[Converter.scala 153:27]
    else :
      node _T_4 = gt(readResponseCount, UInt<1>("h0")) @[Converter.scala 157:45]
      node _T_5 = and(readResponded, _T_4) @[Converter.scala 157:24]
      when _T_5 : @[Converter.scala 157:52]
        node _readResponseCount_T_2 = sub(readResponseCount, UInt<1>("h1")) @[Converter.scala 158:46]
        node _readResponseCount_T_3 = tail(_readResponseCount_T_2, 1) @[Converter.scala 158:46]
        readResponseCount <= _readResponseCount_T_3 @[Converter.scala 158:25]
      else :
        skip
    io.axi.writeAddress.bits.id <= UInt<1>("h0") @[Address.scala 43:8]
    io.axi.writeAddress.bits.size <= UInt<2>("h3") @[Address.scala 47:10]
    io.axi.writeAddress.bits.burst <= UInt<1>("h1") @[Address.scala 51:11]
    io.axi.writeAddress.bits.lock <= UInt<1>("h0") @[Address.scala 55:10]
    io.axi.writeAddress.bits.cache <= UInt<1>("h0") @[Address.scala 56:11]
    io.axi.writeAddress.bits.prot <= UInt<1>("h0") @[Address.scala 57:10]
    io.axi.writeAddress.bits.qos <= UInt<1>("h0") @[Address.scala 58:9]
    node _T_6 = add(address, io.addressOffset) @[Converter.scala 168:15]
    node _T_7 = tail(_T_6, 1) @[Converter.scala 168:15]
    io.axi.writeAddress.bits.addr <= _T_7 @[Address.scala 27:10]
    io.axi.writeAddress.bits.len <= size @[Address.scala 28:9]
    io.axi.writeAddress.bits.cache <= io.cacheBehavior @[Address.scala 30:34]
    io.axi.writeAddress.valid <= UInt<1>("h0") @[Converter.scala 172:29]
    io.axi.writeData.bits.id <= UInt<1>("h0") @[WriteData.scala 31:8]
    io.axi.writeData.bits.strb <= UInt<8>("hff") @[WriteData.scala 39:14]
    io.axi.writeData.bits.data <= serCounter.io.out.bits @[WriteData.scala 20:15]
    io.axi.writeData.bits.last <= serCounter.io.last @[WriteData.scala 21:15]
    io.axi.writeData.valid <= UInt<1>("h0") @[Converter.scala 178:26]
    io.axi.writeData.valid <= serCounter.io.out.valid @[Converter.scala 179:26]
    serCounter.io.out.ready <= io.axi.writeData.ready @[Converter.scala 180:16]
    writeResponse.io.deq.ready <= UInt<1>("h1") @[Converter.scala 184:23]
    io.axi.readAddress.bits.id <= UInt<1>("h0") @[Address.scala 43:8]
    io.axi.readAddress.bits.size <= UInt<2>("h3") @[Address.scala 47:10]
    io.axi.readAddress.bits.burst <= UInt<1>("h1") @[Address.scala 51:11]
    io.axi.readAddress.bits.lock <= UInt<1>("h0") @[Address.scala 55:10]
    io.axi.readAddress.bits.cache <= UInt<1>("h0") @[Address.scala 56:11]
    io.axi.readAddress.bits.prot <= UInt<1>("h0") @[Address.scala 57:10]
    io.axi.readAddress.bits.qos <= UInt<1>("h0") @[Address.scala 58:9]
    node _T_8 = add(address, io.addressOffset) @[Converter.scala 190:15]
    node _T_9 = tail(_T_8, 1) @[Converter.scala 190:15]
    io.axi.readAddress.bits.addr <= _T_9 @[Address.scala 27:10]
    io.axi.readAddress.bits.len <= size @[Address.scala 28:9]
    io.axi.readAddress.bits.cache <= io.cacheBehavior @[Address.scala 30:34]
    io.axi.readAddress.valid <= UInt<1>("h0") @[Converter.scala 194:28]
    des.io.in.bits <= readData.io.deq.bits.data @[Converter.scala 199:18]
    des.io.in.valid <= readData.io.deq.valid @[Converter.scala 200:19]
    readData.io.deq.ready <= des.io.in.ready @[Converter.scala 201:18]
    inst writeEnqueue of MultiEnqueue_21 @[MultiEnqueue.scala 182:43]
    writeEnqueue.clock <= clock
    writeEnqueue.reset <= reset
    writeEnqueue.io.in.valid <= UInt<1>("h0") @[MultiEnqueue.scala 40:17]
    writeEnqueue.io.out[0].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    writeEnqueue.io.out[1].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    when control_splitter.io.out.bits.write : @[Converter.scala 207:28]
      node _writeEnqueue_io_in_valid_T = and(control_splitter.io.out.valid, canWrite) @[Converter.scala 208:47]
      writeEnqueue.io.in.valid <= _writeEnqueue_io_in_valid_T @[Converter.scala 208:30]
      control_splitter.io.out.ready <= writeEnqueue.io.in.ready @[Converter.scala 209:19]
      writeEnqueue.io.out[0].ready <= io.axi.writeAddress.ready @[Converter.scala 211:34]
      io.axi.writeAddress.valid <= writeEnqueue.io.out[0].valid @[Converter.scala 212:31]
      writeEnqueue.io.out[1].ready <= serCounter.io.len.ready @[Converter.scala 213:34]
      serCounter.io.len.valid <= writeEnqueue.io.out[1].valid @[Converter.scala 214:29]
    else :
      node _io_axi_readAddress_valid_T = and(control_splitter.io.out.valid, canRead) @[Converter.scala 216:47]
      io.axi.readAddress.valid <= _io_axi_readAddress_valid_T @[Converter.scala 216:30]
      node _splitter_io_out_ready_T = and(io.axi.readAddress.ready, canRead) @[Converter.scala 217:47]
      control_splitter.io.out.ready <= _splitter_io_out_ready_T @[Converter.scala 217:19]

  module Queue_40 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, count : UInt<2>}

    cmem ram : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>} [2] @[Decoupled.scala 259:95]
    reg value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg value_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(value_1, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(value_1, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      value_1 <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      value <= UInt<1>("h0") @[Counter.scala 99:11]
      value_1 <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Queue_41 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, count : UInt<2>}

    cmem ram : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>} [2] @[Decoupled.scala 259:95]
    reg value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg value_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(value_1, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(value_1, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      value_1 <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      value <= UInt<1>("h0") @[Counter.scala 99:11]
      value_1 <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Queue_42 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, count : UInt<2>}

    cmem ram : { id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>} [2] @[Decoupled.scala 259:95]
    reg value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg value_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(value_1, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(value_1, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      value_1 <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      value <= UInt<1>("h0") @[Counter.scala 99:11]
      value_1 <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Queue_43 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}, count : UInt<2>}

    cmem ram : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>} [2] @[Decoupled.scala 259:95]
    reg value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg value_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(value_1, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(value_1, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      value_1 <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      value <= UInt<1>("h0") @[Counter.scala 99:11]
      value_1 <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Queue_44 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, resp : UInt<2>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, resp : UInt<2>}}, count : UInt<2>}

    cmem ram : { id : UInt<6>, resp : UInt<2>} [2] @[Decoupled.scala 259:95]
    reg value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg value_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(value_1, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(value_1, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      value_1 <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      value <= UInt<1>("h0") @[Counter.scala 99:11]
      value_1 <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Queue_45 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { writeAddress : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, writeData : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, flip writeResponse : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, resp : UInt<2>}}, readAddress : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, flip readData : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}, out : { writeAddress : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, writeData : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, flip writeResponse : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, resp : UInt<2>}}, readAddress : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, flip readData : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}}

    inst io_out_readAddress_q of Queue_40 @[Decoupled.scala 361:21]
    io_out_readAddress_q.clock <= clock
    io_out_readAddress_q.reset <= reset
    io_out_readAddress_q.io.enq.valid <= io.in.readAddress.valid @[Decoupled.scala 363:22]
    io_out_readAddress_q.io.enq.bits.qos <= io.in.readAddress.bits.qos @[Decoupled.scala 364:21]
    io_out_readAddress_q.io.enq.bits.prot <= io.in.readAddress.bits.prot @[Decoupled.scala 364:21]
    io_out_readAddress_q.io.enq.bits.cache <= io.in.readAddress.bits.cache @[Decoupled.scala 364:21]
    io_out_readAddress_q.io.enq.bits.lock <= io.in.readAddress.bits.lock @[Decoupled.scala 364:21]
    io_out_readAddress_q.io.enq.bits.burst <= io.in.readAddress.bits.burst @[Decoupled.scala 364:21]
    io_out_readAddress_q.io.enq.bits.size <= io.in.readAddress.bits.size @[Decoupled.scala 364:21]
    io_out_readAddress_q.io.enq.bits.len <= io.in.readAddress.bits.len @[Decoupled.scala 364:21]
    io_out_readAddress_q.io.enq.bits.addr <= io.in.readAddress.bits.addr @[Decoupled.scala 364:21]
    io_out_readAddress_q.io.enq.bits.id <= io.in.readAddress.bits.id @[Decoupled.scala 364:21]
    io.in.readAddress.ready <= io_out_readAddress_q.io.enq.ready @[Decoupled.scala 365:17]
    io.out.readAddress.bits <= io_out_readAddress_q.io.deq.bits @[Queue.scala 14:22]
    io.out.readAddress.valid <= io_out_readAddress_q.io.deq.valid @[Queue.scala 14:22]
    io_out_readAddress_q.io.deq.ready <= io.out.readAddress.ready @[Queue.scala 14:22]
    inst io_out_writeAddress_q of Queue_41 @[Decoupled.scala 361:21]
    io_out_writeAddress_q.clock <= clock
    io_out_writeAddress_q.reset <= reset
    io_out_writeAddress_q.io.enq.valid <= io.in.writeAddress.valid @[Decoupled.scala 363:22]
    io_out_writeAddress_q.io.enq.bits.qos <= io.in.writeAddress.bits.qos @[Decoupled.scala 364:21]
    io_out_writeAddress_q.io.enq.bits.prot <= io.in.writeAddress.bits.prot @[Decoupled.scala 364:21]
    io_out_writeAddress_q.io.enq.bits.cache <= io.in.writeAddress.bits.cache @[Decoupled.scala 364:21]
    io_out_writeAddress_q.io.enq.bits.lock <= io.in.writeAddress.bits.lock @[Decoupled.scala 364:21]
    io_out_writeAddress_q.io.enq.bits.burst <= io.in.writeAddress.bits.burst @[Decoupled.scala 364:21]
    io_out_writeAddress_q.io.enq.bits.size <= io.in.writeAddress.bits.size @[Decoupled.scala 364:21]
    io_out_writeAddress_q.io.enq.bits.len <= io.in.writeAddress.bits.len @[Decoupled.scala 364:21]
    io_out_writeAddress_q.io.enq.bits.addr <= io.in.writeAddress.bits.addr @[Decoupled.scala 364:21]
    io_out_writeAddress_q.io.enq.bits.id <= io.in.writeAddress.bits.id @[Decoupled.scala 364:21]
    io.in.writeAddress.ready <= io_out_writeAddress_q.io.enq.ready @[Decoupled.scala 365:17]
    io.out.writeAddress.bits <= io_out_writeAddress_q.io.deq.bits @[Queue.scala 15:23]
    io.out.writeAddress.valid <= io_out_writeAddress_q.io.deq.valid @[Queue.scala 15:23]
    io_out_writeAddress_q.io.deq.ready <= io.out.writeAddress.ready @[Queue.scala 15:23]
    inst io_out_writeData_q of Queue_42 @[Decoupled.scala 361:21]
    io_out_writeData_q.clock <= clock
    io_out_writeData_q.reset <= reset
    io_out_writeData_q.io.enq.valid <= io.in.writeData.valid @[Decoupled.scala 363:22]
    io_out_writeData_q.io.enq.bits.last <= io.in.writeData.bits.last @[Decoupled.scala 364:21]
    io_out_writeData_q.io.enq.bits.strb <= io.in.writeData.bits.strb @[Decoupled.scala 364:21]
    io_out_writeData_q.io.enq.bits.data <= io.in.writeData.bits.data @[Decoupled.scala 364:21]
    io_out_writeData_q.io.enq.bits.id <= io.in.writeData.bits.id @[Decoupled.scala 364:21]
    io.in.writeData.ready <= io_out_writeData_q.io.enq.ready @[Decoupled.scala 365:17]
    io.out.writeData.bits <= io_out_writeData_q.io.deq.bits @[Queue.scala 16:20]
    io.out.writeData.valid <= io_out_writeData_q.io.deq.valid @[Queue.scala 16:20]
    io_out_writeData_q.io.deq.ready <= io.out.writeData.ready @[Queue.scala 16:20]
    inst io_in_readData_q of Queue_43 @[Decoupled.scala 361:21]
    io_in_readData_q.clock <= clock
    io_in_readData_q.reset <= reset
    io_in_readData_q.io.enq.valid <= io.out.readData.valid @[Decoupled.scala 363:22]
    io_in_readData_q.io.enq.bits.last <= io.out.readData.bits.last @[Decoupled.scala 364:21]
    io_in_readData_q.io.enq.bits.resp <= io.out.readData.bits.resp @[Decoupled.scala 364:21]
    io_in_readData_q.io.enq.bits.data <= io.out.readData.bits.data @[Decoupled.scala 364:21]
    io_in_readData_q.io.enq.bits.id <= io.out.readData.bits.id @[Decoupled.scala 364:21]
    io.out.readData.ready <= io_in_readData_q.io.enq.ready @[Decoupled.scala 365:17]
    io.in.readData.bits <= io_in_readData_q.io.deq.bits @[Queue.scala 17:18]
    io.in.readData.valid <= io_in_readData_q.io.deq.valid @[Queue.scala 17:18]
    io_in_readData_q.io.deq.ready <= io.in.readData.ready @[Queue.scala 17:18]
    inst io_in_writeResponse_q of Queue_44 @[Decoupled.scala 361:21]
    io_in_writeResponse_q.clock <= clock
    io_in_writeResponse_q.reset <= reset
    io_in_writeResponse_q.io.enq.valid <= io.out.writeResponse.valid @[Decoupled.scala 363:22]
    io_in_writeResponse_q.io.enq.bits.resp <= io.out.writeResponse.bits.resp @[Decoupled.scala 364:21]
    io_in_writeResponse_q.io.enq.bits.id <= io.out.writeResponse.bits.id @[Decoupled.scala 364:21]
    io.out.writeResponse.ready <= io_in_writeResponse_q.io.enq.ready @[Decoupled.scala 365:17]
    io.in.writeResponse.bits <= io_in_writeResponse_q.io.deq.bits @[Queue.scala 18:23]
    io.in.writeResponse.valid <= io_in_writeResponse_q.io.deq.valid @[Queue.scala 18:23]
    io_in_writeResponse_q.io.deq.ready <= io.in.writeResponse.ready @[Queue.scala 18:23]

  module Queue_46 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>}}, count : UInt<2>}

    cmem ram : { write : UInt<1>, address : UInt<20>, size : UInt<20>} [2] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module RequestSplitter_1 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>}}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>}}}

    wire _sizeCounter_WIRE : UInt<20> @[package.scala 72:41]
    _sizeCounter_WIRE <= UInt<1>("h0") @[package.scala 72:41]
    reg sizeCounter : UInt, clock with :
      reset => (reset, _sizeCounter_WIRE) @[RequestSplitter.scala 21:33]
    reg sizeCounterValid : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[RequestSplitter.scala 22:33]
    wire _addressOffset_WIRE : UInt<20> @[package.scala 72:41]
    _addressOffset_WIRE <= UInt<1>("h0") @[package.scala 72:41]
    reg addressOffset : UInt, clock with :
      reset => (reset, _addressOffset_WIRE) @[RequestSplitter.scala 23:33]
    node _address_T = add(io.in.bits.address, addressOffset) @[RequestSplitter.scala 24:42]
    node address = tail(_address_T, 1) @[RequestSplitter.scala 24:42]
    node _T = lt(io.in.bits.size, UInt<8>("h80")) @[RequestSplitter.scala 26:21]
    when _T : @[RequestSplitter.scala 26:34]
      io.out <= io.in @[RequestSplitter.scala 27:12]
    else :
      node _T_1 = lt(sizeCounter, UInt<8>("h80")) @[RequestSplitter.scala 29:42]
      node _T_2 = and(sizeCounterValid, _T_1) @[RequestSplitter.scala 29:27]
      when _T_2 : @[RequestSplitter.scala 29:55]
        wire io_out_bits_w : { write : UInt<1>, address : UInt<20>, size : UInt<20>} @[MemControl.scala 98:19]
        io_out_bits_w.address <= address @[MemControl.scala 99:17]
        io_out_bits_w.write <= io.in.bits.write @[MemControl.scala 100:15]
        io_out_bits_w.size <= sizeCounter @[MemControl.scala 101:14]
        io.out.bits <= io_out_bits_w @[RequestSplitter.scala 30:19]
        io.out.valid <= io.in.valid @[RequestSplitter.scala 36:20]
        io.in.ready <= io.out.ready @[RequestSplitter.scala 37:16]
        node _T_3 = and(io.in.valid, io.out.ready) @[RequestSplitter.scala 38:21]
        when _T_3 : @[RequestSplitter.scala 38:38]
          sizeCounterValid <= UInt<1>("h0") @[RequestSplitter.scala 39:26]
          addressOffset <= UInt<1>("h0") @[RequestSplitter.scala 40:23]
      else :
        wire io_out_bits_w_1 : { write : UInt<1>, address : UInt<20>, size : UInt<20>} @[MemControl.scala 98:19]
        io_out_bits_w_1.address <= address @[MemControl.scala 99:17]
        io_out_bits_w_1.write <= io.in.bits.write @[MemControl.scala 100:15]
        io_out_bits_w_1.size <= UInt<7>("h7f") @[MemControl.scala 101:14]
        io.out.bits <= io_out_bits_w_1 @[RequestSplitter.scala 43:19]
        io.out.valid <= io.in.valid @[RequestSplitter.scala 49:20]
        io.in.ready <= UInt<1>("h0") @[RequestSplitter.scala 50:16]
        node _T_4 = and(io.in.valid, io.out.ready) @[RequestSplitter.scala 51:21]
        when _T_4 : @[RequestSplitter.scala 51:38]
          when sizeCounterValid : @[RequestSplitter.scala 52:32]
            node _sizeCounter_T = sub(sizeCounter, UInt<8>("h80")) @[RequestSplitter.scala 53:38]
            node _sizeCounter_T_1 = tail(_sizeCounter_T, 1) @[RequestSplitter.scala 53:38]
            sizeCounter <= _sizeCounter_T_1 @[RequestSplitter.scala 53:23]
            node _addressOffset_T = add(addressOffset, UInt<8>("h80")) @[RequestSplitter.scala 54:42]
            node _addressOffset_T_1 = tail(_addressOffset_T, 1) @[RequestSplitter.scala 54:42]
            addressOffset <= _addressOffset_T_1 @[RequestSplitter.scala 54:25]
          else :
            node _sizeCounter_T_2 = sub(io.in.bits.size, UInt<8>("h80")) @[RequestSplitter.scala 56:39]
            node _sizeCounter_T_3 = tail(_sizeCounter_T_2, 1) @[RequestSplitter.scala 56:39]
            sizeCounter <= _sizeCounter_T_3 @[RequestSplitter.scala 56:23]
            addressOffset <= UInt<8>("h80") @[RequestSplitter.scala 57:25]
            sizeCounterValid <= UInt<1>("h1") @[RequestSplitter.scala 58:28]

  module Queue_47 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, count : UInt<2>}

    cmem ram : Fixed<16><<8>>[8] [2] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Queue_48 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}, count : UInt<2>}

    cmem ram : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>} [2] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Queue_49 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, resp : UInt<2>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, resp : UInt<2>}}, count : UInt<2>}

    cmem ram : { id : UInt<6>, resp : UInt<2>} [2] @[Decoupled.scala 259:95]
    reg enq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg deq_ptr_value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      enq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      deq_ptr_value <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module VectorSerializer_1 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}}

    wire _bits_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_1 = asFixedPoint(_bits_T, 8) @[package.scala 74:56]
    _bits_WIRE <= _bits_T_1 @[package.scala 74:56]
    wire _bits_WIRE_1 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_2 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_3 = asFixedPoint(_bits_T_2, 8) @[package.scala 74:56]
    _bits_WIRE_1 <= _bits_T_3 @[package.scala 74:56]
    wire _bits_WIRE_2 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_4 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_5 = asFixedPoint(_bits_T_4, 8) @[package.scala 74:56]
    _bits_WIRE_2 <= _bits_T_5 @[package.scala 74:56]
    wire _bits_WIRE_3 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_6 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_7 = asFixedPoint(_bits_T_6, 8) @[package.scala 74:56]
    _bits_WIRE_3 <= _bits_T_7 @[package.scala 74:56]
    wire _bits_WIRE_4 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_8 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_9 = asFixedPoint(_bits_T_8, 8) @[package.scala 74:56]
    _bits_WIRE_4 <= _bits_T_9 @[package.scala 74:56]
    wire _bits_WIRE_5 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_10 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_11 = asFixedPoint(_bits_T_10, 8) @[package.scala 74:56]
    _bits_WIRE_5 <= _bits_T_11 @[package.scala 74:56]
    wire _bits_WIRE_6 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_12 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_13 = asFixedPoint(_bits_T_12, 8) @[package.scala 74:56]
    _bits_WIRE_6 <= _bits_T_13 @[package.scala 74:56]
    wire _bits_WIRE_7 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_14 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_15 = asFixedPoint(_bits_T_14, 8) @[package.scala 74:56]
    _bits_WIRE_7 <= _bits_T_15 @[package.scala 74:56]
    wire _bits_WIRE_8 : Fixed<16><<8>>[8] @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[0] <= _bits_WIRE @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[1] <= _bits_WIRE_1 @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[2] <= _bits_WIRE_2 @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[3] <= _bits_WIRE_3 @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[4] <= _bits_WIRE_4 @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[5] <= _bits_WIRE_5 @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[6] <= _bits_WIRE_6 @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[7] <= _bits_WIRE_7 @[VectorSerializer.scala 37:30]
    reg bits : Fixed<16><<8>>[8], clock with :
      reset => (reset, _bits_WIRE_8) @[VectorSerializer.scala 37:22]
    reg valid : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[VectorSerializer.scala 38:22]
    node _T = and(valid, io.out.ready) @[VectorSerializer.scala 40:48]
    reg ctr : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    wire wrap : UInt<1>
    wrap <= UInt<1>("h0")
    when _T : @[Counter.scala 120:16]
      node wrap_wrap = eq(ctr, UInt<1>("h1")) @[Counter.scala 74:24]
      node _wrap_value_T = add(ctr, UInt<1>("h1")) @[Counter.scala 78:24]
      node _wrap_value_T_1 = tail(_wrap_value_T, 1) @[Counter.scala 78:24]
      ctr <= _wrap_value_T_1 @[Counter.scala 78:15]
      wrap <= wrap_wrap @[Counter.scala 120:23]
    node _out_T = mul(ctr, UInt<3>("h4")) @[VectorSerializer.scala 46:18]
    node _out_T_1 = add(_out_T, UInt<1>("h0")) @[VectorSerializer.scala 46:40]
    node _out_T_2 = tail(_out_T_1, 1) @[VectorSerializer.scala 46:40]
    node _out_T_3 = bits(_out_T_2, 2, 0)
    node _out_T_4 = asUInt(bits[_out_T_3]) @[VectorSerializer.scala 46:47]
    wire out_0 : UInt<16> @[Extend.scala 40:17]
    out_0 <= _out_T_4 @[Extend.scala 41:7]
    node _out_T_5 = mul(ctr, UInt<3>("h4")) @[VectorSerializer.scala 46:18]
    node _out_T_6 = add(_out_T_5, UInt<1>("h1")) @[VectorSerializer.scala 46:40]
    node _out_T_7 = tail(_out_T_6, 1) @[VectorSerializer.scala 46:40]
    node _out_T_8 = bits(_out_T_7, 2, 0)
    node _out_T_9 = asUInt(bits[_out_T_8]) @[VectorSerializer.scala 46:47]
    wire out_1 : UInt<16> @[Extend.scala 40:17]
    out_1 <= _out_T_9 @[Extend.scala 41:7]
    node _out_T_10 = mul(ctr, UInt<3>("h4")) @[VectorSerializer.scala 46:18]
    node _out_T_11 = add(_out_T_10, UInt<2>("h2")) @[VectorSerializer.scala 46:40]
    node _out_T_12 = tail(_out_T_11, 1) @[VectorSerializer.scala 46:40]
    node _out_T_13 = bits(_out_T_12, 2, 0)
    node _out_T_14 = asUInt(bits[_out_T_13]) @[VectorSerializer.scala 46:47]
    wire out_2 : UInt<16> @[Extend.scala 40:17]
    out_2 <= _out_T_14 @[Extend.scala 41:7]
    node _out_T_15 = mul(ctr, UInt<3>("h4")) @[VectorSerializer.scala 46:18]
    node _out_T_16 = add(_out_T_15, UInt<2>("h3")) @[VectorSerializer.scala 46:40]
    node _out_T_17 = tail(_out_T_16, 1) @[VectorSerializer.scala 46:40]
    node _out_T_18 = bits(_out_T_17, 2, 0)
    node _out_T_19 = asUInt(bits[_out_T_18]) @[VectorSerializer.scala 46:47]
    wire out_3 : UInt<16> @[Extend.scala 40:17]
    out_3 <= _out_T_19 @[Extend.scala 41:7]
    io.out.valid <= valid @[VectorSerializer.scala 50:16]
    node io_out_bits_lo = cat(out_1, out_0) @[Cat.scala 31:58]
    node io_out_bits_hi = cat(out_3, out_2) @[Cat.scala 31:58]
    node _io_out_bits_T = cat(io_out_bits_hi, io_out_bits_lo) @[Cat.scala 31:58]
    wire _io_out_bits_WIRE : UInt<64> @[VectorSerializer.scala 51:43]
    _io_out_bits_WIRE <= _io_out_bits_T @[VectorSerializer.scala 51:43]
    io.out.bits <= _io_out_bits_WIRE @[VectorSerializer.scala 51:15]
    node _io_in_ready_T = eq(valid, UInt<1>("h0")) @[VectorSerializer.scala 52:18]
    node _io_in_ready_T_1 = or(_io_in_ready_T, wrap) @[VectorSerializer.scala 52:25]
    io.in.ready <= _io_in_ready_T_1 @[VectorSerializer.scala 52:15]
    when io.in.ready : @[VectorSerializer.scala 54:21]
      when io.in.valid : @[VectorSerializer.scala 55:23]
        wire _WIRE : Fixed<16><<8>>[8] @[VectorSerializer.scala 56:34]
        node _T_1 = asUInt(io.in.bits[0]) @[VectorSerializer.scala 56:34]
        node _T_2 = asUInt(io.in.bits[1]) @[VectorSerializer.scala 56:34]
        node _T_3 = asUInt(io.in.bits[2]) @[VectorSerializer.scala 56:34]
        node _T_4 = asUInt(io.in.bits[3]) @[VectorSerializer.scala 56:34]
        node _T_5 = asUInt(io.in.bits[4]) @[VectorSerializer.scala 56:34]
        node _T_6 = asUInt(io.in.bits[5]) @[VectorSerializer.scala 56:34]
        node _T_7 = asUInt(io.in.bits[6]) @[VectorSerializer.scala 56:34]
        node _T_8 = asUInt(io.in.bits[7]) @[VectorSerializer.scala 56:34]
        node lo_lo = cat(_T_2, _T_1) @[VectorSerializer.scala 56:34]
        node lo_hi = cat(_T_4, _T_3) @[VectorSerializer.scala 56:34]
        node lo = cat(lo_hi, lo_lo) @[VectorSerializer.scala 56:34]
        node hi_lo = cat(_T_6, _T_5) @[VectorSerializer.scala 56:34]
        node hi_hi = cat(_T_8, _T_7) @[VectorSerializer.scala 56:34]
        node hi = cat(hi_hi, hi_lo) @[VectorSerializer.scala 56:34]
        node _T_9 = cat(hi, lo) @[VectorSerializer.scala 56:34]
        wire _WIRE_1 : UInt<128>
        _WIRE_1 <= _T_9
        node _T_10 = bits(_WIRE_1, 15, 0) @[VectorSerializer.scala 56:34]
        node _T_11 = asFixedPoint(_T_10, 8) @[VectorSerializer.scala 56:34]
        _WIRE[0] <= _T_11 @[VectorSerializer.scala 56:34]
        node _T_12 = bits(_WIRE_1, 31, 16) @[VectorSerializer.scala 56:34]
        node _T_13 = asFixedPoint(_T_12, 8) @[VectorSerializer.scala 56:34]
        _WIRE[1] <= _T_13 @[VectorSerializer.scala 56:34]
        node _T_14 = bits(_WIRE_1, 47, 32) @[VectorSerializer.scala 56:34]
        node _T_15 = asFixedPoint(_T_14, 8) @[VectorSerializer.scala 56:34]
        _WIRE[2] <= _T_15 @[VectorSerializer.scala 56:34]
        node _T_16 = bits(_WIRE_1, 63, 48) @[VectorSerializer.scala 56:34]
        node _T_17 = asFixedPoint(_T_16, 8) @[VectorSerializer.scala 56:34]
        _WIRE[3] <= _T_17 @[VectorSerializer.scala 56:34]
        node _T_18 = bits(_WIRE_1, 79, 64) @[VectorSerializer.scala 56:34]
        node _T_19 = asFixedPoint(_T_18, 8) @[VectorSerializer.scala 56:34]
        _WIRE[4] <= _T_19 @[VectorSerializer.scala 56:34]
        node _T_20 = bits(_WIRE_1, 95, 80) @[VectorSerializer.scala 56:34]
        node _T_21 = asFixedPoint(_T_20, 8) @[VectorSerializer.scala 56:34]
        _WIRE[5] <= _T_21 @[VectorSerializer.scala 56:34]
        node _T_22 = bits(_WIRE_1, 111, 96) @[VectorSerializer.scala 56:34]
        node _T_23 = asFixedPoint(_T_22, 8) @[VectorSerializer.scala 56:34]
        _WIRE[6] <= _T_23 @[VectorSerializer.scala 56:34]
        node _T_24 = bits(_WIRE_1, 127, 112) @[VectorSerializer.scala 56:34]
        node _T_25 = asFixedPoint(_T_24, 8) @[VectorSerializer.scala 56:34]
        _WIRE[7] <= _T_25 @[VectorSerializer.scala 56:34]
        bits <= _WIRE @[VectorSerializer.scala 56:12]
        valid <= UInt<1>("h1") @[VectorSerializer.scala 57:13]
      else :
        valid <= UInt<1>("h0") @[VectorSerializer.scala 59:13]

  module Counter_15 :
    input clock : Clock
    input reset : Reset
    output io : { value : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, flip resetValue : UInt<1>}

    reg value : UInt<8>, clock with :
      reset => (reset, UInt<8>("h0")) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h0")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<8>("hff")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h0") @[Counter.scala 22:13]
      else :
        node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h0") @[Counter.scala 28:11]

  module DataCounter_1 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}, flip len : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, last : UInt<1>}

    inst counter of Counter_15 @[Counter.scala 34:19]
    counter.clock <= clock
    counter.reset <= reset
    counter.io.resetValue <= UInt<1>("h0") @[Counter.scala 35:21]
    counter.io.value.ready <= UInt<1>("h0") @[Counter.scala 36:22]
    io.out.bits <= io.in.bits @[DataCounter.scala 25:15]
    node _io_out_valid_T = and(io.in.valid, io.len.valid) @[DataCounter.scala 26:28]
    io.out.valid <= _io_out_valid_T @[DataCounter.scala 26:16]
    node _io_in_ready_T = and(io.len.valid, io.out.ready) @[DataCounter.scala 27:25]
    io.in.ready <= _io_in_ready_T @[DataCounter.scala 27:12]
    node _T = eq(counter.io.value.bits, io.len.bits) @[DataCounter.scala 29:30]
    when _T : @[DataCounter.scala 29:44]
      node _io_last_T = and(io.in.valid, io.len.valid) @[DataCounter.scala 30:25]
      io.last <= _io_last_T @[DataCounter.scala 30:13]
      node _io_len_ready_T = and(io.in.valid, io.out.ready) @[DataCounter.scala 31:27]
      io.len.ready <= _io_len_ready_T @[DataCounter.scala 31:15]
      node _counter_io_resetValue_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 50:35]
      counter.io.resetValue <= _counter_io_resetValue_T @[DataCounter.scala 32:27]
    else :
      io.len.ready <= UInt<1>("h0") @[DataCounter.scala 34:15]
      io.last <= UInt<1>("h0") @[DataCounter.scala 35:13]
      node _counter_io_value_ready_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 50:35]
      counter.io.value.ready <= _counter_io_value_ready_T @[DataCounter.scala 36:28]

  module VectorDeserializer_1 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}

    wire _bits_WIRE : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_1 = asFixedPoint(_bits_T, 8) @[package.scala 74:56]
    _bits_WIRE <= _bits_T_1 @[package.scala 74:56]
    wire _bits_WIRE_1 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_2 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_3 = asFixedPoint(_bits_T_2, 8) @[package.scala 74:56]
    _bits_WIRE_1 <= _bits_T_3 @[package.scala 74:56]
    wire _bits_WIRE_2 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_4 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_5 = asFixedPoint(_bits_T_4, 8) @[package.scala 74:56]
    _bits_WIRE_2 <= _bits_T_5 @[package.scala 74:56]
    wire _bits_WIRE_3 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_6 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_7 = asFixedPoint(_bits_T_6, 8) @[package.scala 74:56]
    _bits_WIRE_3 <= _bits_T_7 @[package.scala 74:56]
    wire _bits_WIRE_4 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_8 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_9 = asFixedPoint(_bits_T_8, 8) @[package.scala 74:56]
    _bits_WIRE_4 <= _bits_T_9 @[package.scala 74:56]
    wire _bits_WIRE_5 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_10 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_11 = asFixedPoint(_bits_T_10, 8) @[package.scala 74:56]
    _bits_WIRE_5 <= _bits_T_11 @[package.scala 74:56]
    wire _bits_WIRE_6 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_12 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_13 = asFixedPoint(_bits_T_12, 8) @[package.scala 74:56]
    _bits_WIRE_6 <= _bits_T_13 @[package.scala 74:56]
    wire _bits_WIRE_7 : Fixed<16><<8>> @[package.scala 74:56]
    node _bits_T_14 = asUInt(asFixedPoint(UInt<1>("h0"), 8)) @[package.scala 74:56]
    node _bits_T_15 = asFixedPoint(_bits_T_14, 8) @[package.scala 74:56]
    _bits_WIRE_7 <= _bits_T_15 @[package.scala 74:56]
    wire _bits_WIRE_8 : Fixed<16><<8>>[8] @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[0] <= _bits_WIRE @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[1] <= _bits_WIRE_1 @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[2] <= _bits_WIRE_2 @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[3] <= _bits_WIRE_3 @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[4] <= _bits_WIRE_4 @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[5] <= _bits_WIRE_5 @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[6] <= _bits_WIRE_6 @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[7] <= _bits_WIRE_7 @[VectorDeserializer.scala 41:32]
    reg bits : Fixed<16><<8>>[8], clock with :
      reset => (reset, _bits_WIRE_8) @[VectorDeserializer.scala 41:24]
    reg valid : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[VectorDeserializer.scala 42:24]
    node _T = and(io.in.ready, io.in.valid) @[Decoupled.scala 50:35]
    reg ctr : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    wire wrap : UInt<1>
    wrap <= UInt<1>("h0")
    when _T : @[Counter.scala 120:16]
      node wrap_wrap = eq(ctr, UInt<1>("h1")) @[Counter.scala 74:24]
      node _wrap_value_T = add(ctr, UInt<1>("h1")) @[Counter.scala 78:24]
      node _wrap_value_T_1 = tail(_wrap_value_T, 1) @[Counter.scala 78:24]
      ctr <= _wrap_value_T_1 @[Counter.scala 78:15]
      wrap <= wrap_wrap @[Counter.scala 120:23]
    io.out.valid <= valid @[VectorDeserializer.scala 47:18]
    io.out.bits <= bits @[VectorDeserializer.scala 48:17]
    node _io_in_ready_T = eq(valid, UInt<1>("h0")) @[VectorDeserializer.scala 50:20]
    node _io_in_ready_T_1 = or(_io_in_ready_T, io.out.ready) @[VectorDeserializer.scala 50:27]
    io.in.ready <= _io_in_ready_T_1 @[VectorDeserializer.scala 50:17]
    node _T_1 = and(io.in.ready, io.in.valid) @[Decoupled.scala 50:35]
    when _T_1 : @[VectorDeserializer.scala 52:22]
      node _T_2 = mul(ctr, UInt<3>("h4")) @[VectorDeserializer.scala 54:18]
      node _T_3 = add(_T_2, UInt<1>("h0")) @[VectorDeserializer.scala 54:40]
      node _T_4 = tail(_T_3, 1) @[VectorDeserializer.scala 54:40]
      node _T_5 = bits(_T_4, 2, 0)
      node _bits_T_16 = bits(io.in.bits, 15, 0) @[VectorDeserializer.scala 55:30]
      wire bits_w : UInt<16> @[Extend.scala 40:17]
      bits_w <= _bits_T_16 @[Extend.scala 41:7]
      wire _bits_WIRE_9 : Fixed<16><<8>> @[VectorDeserializer.scala 37:57]
      node _bits_T_17 = asFixedPoint(bits_w, 8) @[VectorDeserializer.scala 37:57]
      _bits_WIRE_9 <= _bits_T_17 @[VectorDeserializer.scala 37:57]
      bits[_T_5] <= _bits_WIRE_9 @[VectorDeserializer.scala 54:47]
      node _T_6 = mul(ctr, UInt<3>("h4")) @[VectorDeserializer.scala 54:18]
      node _T_7 = add(_T_6, UInt<1>("h1")) @[VectorDeserializer.scala 54:40]
      node _T_8 = tail(_T_7, 1) @[VectorDeserializer.scala 54:40]
      node _T_9 = bits(_T_8, 2, 0)
      node _bits_T_18 = bits(io.in.bits, 31, 16) @[VectorDeserializer.scala 55:30]
      wire bits_w_1 : UInt<16> @[Extend.scala 40:17]
      bits_w_1 <= _bits_T_18 @[Extend.scala 41:7]
      wire _bits_WIRE_10 : Fixed<16><<8>> @[VectorDeserializer.scala 37:57]
      node _bits_T_19 = asFixedPoint(bits_w_1, 8) @[VectorDeserializer.scala 37:57]
      _bits_WIRE_10 <= _bits_T_19 @[VectorDeserializer.scala 37:57]
      bits[_T_9] <= _bits_WIRE_10 @[VectorDeserializer.scala 54:47]
      node _T_10 = mul(ctr, UInt<3>("h4")) @[VectorDeserializer.scala 54:18]
      node _T_11 = add(_T_10, UInt<2>("h2")) @[VectorDeserializer.scala 54:40]
      node _T_12 = tail(_T_11, 1) @[VectorDeserializer.scala 54:40]
      node _T_13 = bits(_T_12, 2, 0)
      node _bits_T_20 = bits(io.in.bits, 47, 32) @[VectorDeserializer.scala 55:30]
      wire bits_w_2 : UInt<16> @[Extend.scala 40:17]
      bits_w_2 <= _bits_T_20 @[Extend.scala 41:7]
      wire _bits_WIRE_11 : Fixed<16><<8>> @[VectorDeserializer.scala 37:57]
      node _bits_T_21 = asFixedPoint(bits_w_2, 8) @[VectorDeserializer.scala 37:57]
      _bits_WIRE_11 <= _bits_T_21 @[VectorDeserializer.scala 37:57]
      bits[_T_13] <= _bits_WIRE_11 @[VectorDeserializer.scala 54:47]
      node _T_14 = mul(ctr, UInt<3>("h4")) @[VectorDeserializer.scala 54:18]
      node _T_15 = add(_T_14, UInt<2>("h3")) @[VectorDeserializer.scala 54:40]
      node _T_16 = tail(_T_15, 1) @[VectorDeserializer.scala 54:40]
      node _T_17 = bits(_T_16, 2, 0)
      node _bits_T_22 = bits(io.in.bits, 63, 48) @[VectorDeserializer.scala 55:30]
      wire bits_w_3 : UInt<16> @[Extend.scala 40:17]
      bits_w_3 <= _bits_T_22 @[Extend.scala 41:7]
      wire _bits_WIRE_12 : Fixed<16><<8>> @[VectorDeserializer.scala 37:57]
      node _bits_T_23 = asFixedPoint(bits_w_3, 8) @[VectorDeserializer.scala 37:57]
      _bits_WIRE_12 <= _bits_T_23 @[VectorDeserializer.scala 37:57]
      bits[_T_17] <= _bits_WIRE_12 @[VectorDeserializer.scala 54:47]
      valid <= wrap @[VectorDeserializer.scala 61:13]
    node _T_18 = and(io.out.ready, io.out.valid) @[Decoupled.scala 50:35]
    when _T_18 : @[VectorDeserializer.scala 63:23]
      valid <= UInt<1>("h0") @[VectorDeserializer.scala 64:13]

  module MultiEnqueue_22 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>}, out : { flip ready : UInt<1>, valid : UInt<1>}[2]}

    reg enq_0 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node allEnqueued = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T = eq(enq_0, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h0") @[MultiEnqueue.scala 29:14]
    else :
      node _T_1 = eq(enq_1, UInt<1>("h0")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]

  module Converter_1 :
    input clock : Clock
    input reset : Reset
    output io : { mem : { flip control : { flip ready : UInt<1>, valid : UInt<1>, bits : { write : UInt<1>, address : UInt<20>, size : UInt<20>}}, dataIn : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip dataOut : { flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, axi : { writeAddress : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, writeData : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, flip writeResponse : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, resp : UInt<2>}}, readAddress : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, flip readData : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}, flip addressOffset : UInt<32>, flip cacheBehavior : UInt<4>, flip timeout : UInt<1>, flip tracepoint : UInt<1>, flip programCounter : UInt<32>}

    inst control_q of Queue_46 @[Converter.scala 65:25]
    control_q.clock <= clock
    control_q.reset <= reset
    control_q.io.enq <= io.mem.control @[Converter.scala 65:25]
    inst control_splitter of RequestSplitter_1 @[RequestSplitter.scala 69:26]
    control_splitter.clock <= clock
    control_splitter.reset <= reset
    control_splitter.io.in <= control_q.io.deq @[RequestSplitter.scala 70:20]
    inst dataOut of Queue_47 @[Converter.scala 67:41]
    dataOut.clock <= clock
    dataOut.reset <= reset
    dataOut.io.enq <= io.mem.dataOut @[Converter.scala 67:41]
    inst readData of Queue_48 @[Converter.scala 68:41]
    readData.clock <= clock
    readData.reset <= reset
    readData.io.enq <= io.axi.readData @[Converter.scala 68:41]
    inst writeResponse of Queue_49 @[Converter.scala 69:41]
    writeResponse.clock <= clock
    writeResponse.reset <= reset
    writeResponse.io.enq <= io.axi.writeResponse @[Converter.scala 69:41]
    node address = mul(control_splitter.io.out.bits.address, UInt<5>("h10")) @[Converter.scala 78:26]
    node _size_T = add(control_splitter.io.out.bits.size, UInt<1>("h1")) @[Converter.scala 81:24]
    node _size_T_1 = tail(_size_T, 1) @[Converter.scala 81:24]
    node _size_T_2 = mul(_size_T_1, UInt<2>("h2")) @[Converter.scala 81:31]
    node _size_T_3 = sub(_size_T_2, UInt<1>("h1")) @[Converter.scala 81:68]
    node size = tail(_size_T_3, 1) @[Converter.scala 81:68]
    inst ser of VectorSerializer_1 @[Converter.scala 89:19]
    ser.clock <= clock
    ser.reset <= reset
    ser.io.in <= dataOut.io.deq @[Converter.scala 97:13]
    inst serCounter of DataCounter_1 @[Converter.scala 99:26]
    serCounter.clock <= clock
    serCounter.reset <= reset
    serCounter.io.in <= ser.io.out @[Converter.scala 102:20]
    serCounter.io.len.bits <= size @[Converter.scala 103:26]
    serCounter.io.len.valid <= UInt<1>("h0") @[Converter.scala 104:27]
    inst des of VectorDeserializer_1 @[Converter.scala 108:19]
    des.clock <= clock
    des.reset <= reset
    io.mem.dataIn.bits <= des.io.out.bits @[Converter.scala 116:17]
    io.mem.dataIn.valid <= des.io.out.valid @[Converter.scala 116:17]
    des.io.out.ready <= io.mem.dataIn.ready @[Converter.scala 116:17]
    reg writeResponseCount : UInt<8>, clock with :
      reset => (reset, UInt<8>("h0")) @[Converter.scala 123:35]
    reg readResponseCount : UInt<8>, clock with :
      reset => (reset, UInt<8>("h0")) @[Converter.scala 124:35]
    node _canWrite_T = eq(readResponseCount, UInt<1>("h0")) @[Converter.scala 126:24]
    node _canWrite_T_1 = lt(writeResponseCount, UInt<8>("hff")) @[Converter.scala 126:56]
    node canWrite = and(_canWrite_T, _canWrite_T_1) @[Converter.scala 126:33]
    node _canRead_T = eq(writeResponseCount, UInt<1>("h0")) @[Converter.scala 128:25]
    node _canRead_T_1 = lt(readResponseCount, UInt<8>("hff")) @[Converter.scala 128:56]
    node canRead = and(_canRead_T, _canRead_T_1) @[Converter.scala 128:34]
    node writeRequested = and(io.axi.writeAddress.ready, io.axi.writeAddress.valid) @[Converter.scala 129:50]
    node writeResponded = and(writeResponse.io.deq.ready, writeResponse.io.deq.valid) @[Converter.scala 130:44]
    node readRequested = and(io.axi.readAddress.ready, io.axi.readAddress.valid) @[Converter.scala 131:49]
    node _readResponded_T = and(readData.io.deq.ready, readData.io.deq.valid) @[Converter.scala 132:39]
    node readResponded = and(_readResponded_T, readData.io.deq.bits.last) @[Converter.scala 132:57]
    when writeRequested : @[Converter.scala 133:24]
      when writeResponded : @[Converter.scala 134:26]
        skip
      else :
        node _T = lt(writeResponseCount, UInt<8>("hff")) @[Converter.scala 137:31]
        when _T : @[Converter.scala 137:62]
          node _writeResponseCount_T = add(writeResponseCount, UInt<1>("h1")) @[Converter.scala 138:50]
          node _writeResponseCount_T_1 = tail(_writeResponseCount_T, 1) @[Converter.scala 138:50]
          writeResponseCount <= _writeResponseCount_T_1 @[Converter.scala 138:28]
    else :
      node _T_1 = gt(writeResponseCount, UInt<1>("h0")) @[Converter.scala 142:47]
      node _T_2 = and(writeResponded, _T_1) @[Converter.scala 142:25]
      when _T_2 : @[Converter.scala 142:54]
        node _writeResponseCount_T_2 = sub(writeResponseCount, UInt<1>("h1")) @[Converter.scala 143:48]
        node _writeResponseCount_T_3 = tail(_writeResponseCount_T_2, 1) @[Converter.scala 143:48]
        writeResponseCount <= _writeResponseCount_T_3 @[Converter.scala 143:26]
      else :
        skip
    when readRequested : @[Converter.scala 148:23]
      when readResponded : @[Converter.scala 149:25]
        skip
      else :
        node _T_3 = lt(readResponseCount, UInt<8>("hff")) @[Converter.scala 152:30]
        when _T_3 : @[Converter.scala 152:61]
          node _readResponseCount_T = add(readResponseCount, UInt<1>("h1")) @[Converter.scala 153:48]
          node _readResponseCount_T_1 = tail(_readResponseCount_T, 1) @[Converter.scala 153:48]
          readResponseCount <= _readResponseCount_T_1 @[Converter.scala 153:27]
    else :
      node _T_4 = gt(readResponseCount, UInt<1>("h0")) @[Converter.scala 157:45]
      node _T_5 = and(readResponded, _T_4) @[Converter.scala 157:24]
      when _T_5 : @[Converter.scala 157:52]
        node _readResponseCount_T_2 = sub(readResponseCount, UInt<1>("h1")) @[Converter.scala 158:46]
        node _readResponseCount_T_3 = tail(_readResponseCount_T_2, 1) @[Converter.scala 158:46]
        readResponseCount <= _readResponseCount_T_3 @[Converter.scala 158:25]
      else :
        skip
    io.axi.writeAddress.bits.id <= UInt<1>("h0") @[Address.scala 43:8]
    io.axi.writeAddress.bits.size <= UInt<2>("h3") @[Address.scala 47:10]
    io.axi.writeAddress.bits.burst <= UInt<1>("h1") @[Address.scala 51:11]
    io.axi.writeAddress.bits.lock <= UInt<1>("h0") @[Address.scala 55:10]
    io.axi.writeAddress.bits.cache <= UInt<1>("h0") @[Address.scala 56:11]
    io.axi.writeAddress.bits.prot <= UInt<1>("h0") @[Address.scala 57:10]
    io.axi.writeAddress.bits.qos <= UInt<1>("h0") @[Address.scala 58:9]
    node _T_6 = add(address, io.addressOffset) @[Converter.scala 168:15]
    node _T_7 = tail(_T_6, 1) @[Converter.scala 168:15]
    io.axi.writeAddress.bits.addr <= _T_7 @[Address.scala 27:10]
    io.axi.writeAddress.bits.len <= size @[Address.scala 28:9]
    io.axi.writeAddress.bits.cache <= io.cacheBehavior @[Address.scala 30:34]
    io.axi.writeAddress.valid <= UInt<1>("h0") @[Converter.scala 172:29]
    io.axi.writeData.bits.id <= UInt<1>("h0") @[WriteData.scala 31:8]
    io.axi.writeData.bits.strb <= UInt<8>("hff") @[WriteData.scala 39:14]
    io.axi.writeData.bits.data <= serCounter.io.out.bits @[WriteData.scala 20:15]
    io.axi.writeData.bits.last <= serCounter.io.last @[WriteData.scala 21:15]
    io.axi.writeData.valid <= UInt<1>("h0") @[Converter.scala 178:26]
    io.axi.writeData.valid <= serCounter.io.out.valid @[Converter.scala 179:26]
    serCounter.io.out.ready <= io.axi.writeData.ready @[Converter.scala 180:16]
    writeResponse.io.deq.ready <= UInt<1>("h1") @[Converter.scala 184:23]
    io.axi.readAddress.bits.id <= UInt<1>("h0") @[Address.scala 43:8]
    io.axi.readAddress.bits.size <= UInt<2>("h3") @[Address.scala 47:10]
    io.axi.readAddress.bits.burst <= UInt<1>("h1") @[Address.scala 51:11]
    io.axi.readAddress.bits.lock <= UInt<1>("h0") @[Address.scala 55:10]
    io.axi.readAddress.bits.cache <= UInt<1>("h0") @[Address.scala 56:11]
    io.axi.readAddress.bits.prot <= UInt<1>("h0") @[Address.scala 57:10]
    io.axi.readAddress.bits.qos <= UInt<1>("h0") @[Address.scala 58:9]
    node _T_8 = add(address, io.addressOffset) @[Converter.scala 190:15]
    node _T_9 = tail(_T_8, 1) @[Converter.scala 190:15]
    io.axi.readAddress.bits.addr <= _T_9 @[Address.scala 27:10]
    io.axi.readAddress.bits.len <= size @[Address.scala 28:9]
    io.axi.readAddress.bits.cache <= io.cacheBehavior @[Address.scala 30:34]
    io.axi.readAddress.valid <= UInt<1>("h0") @[Converter.scala 194:28]
    des.io.in.bits <= readData.io.deq.bits.data @[Converter.scala 199:18]
    des.io.in.valid <= readData.io.deq.valid @[Converter.scala 200:19]
    readData.io.deq.ready <= des.io.in.ready @[Converter.scala 201:18]
    inst writeEnqueue of MultiEnqueue_22 @[MultiEnqueue.scala 182:43]
    writeEnqueue.clock <= clock
    writeEnqueue.reset <= reset
    writeEnqueue.io.in.valid <= UInt<1>("h0") @[MultiEnqueue.scala 40:17]
    writeEnqueue.io.out[0].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    writeEnqueue.io.out[1].ready <= UInt<1>("h0") @[MultiEnqueue.scala 42:18]
    when control_splitter.io.out.bits.write : @[Converter.scala 207:28]
      node _writeEnqueue_io_in_valid_T = and(control_splitter.io.out.valid, canWrite) @[Converter.scala 208:47]
      writeEnqueue.io.in.valid <= _writeEnqueue_io_in_valid_T @[Converter.scala 208:30]
      control_splitter.io.out.ready <= writeEnqueue.io.in.ready @[Converter.scala 209:19]
      writeEnqueue.io.out[0].ready <= io.axi.writeAddress.ready @[Converter.scala 211:34]
      io.axi.writeAddress.valid <= writeEnqueue.io.out[0].valid @[Converter.scala 212:31]
      writeEnqueue.io.out[1].ready <= serCounter.io.len.ready @[Converter.scala 213:34]
      serCounter.io.len.valid <= writeEnqueue.io.out[1].valid @[Converter.scala 214:29]
    else :
      node _io_axi_readAddress_valid_T = and(control_splitter.io.out.valid, canRead) @[Converter.scala 216:47]
      io.axi.readAddress.valid <= _io_axi_readAddress_valid_T @[Converter.scala 216:30]
      node _splitter_io_out_ready_T = and(io.axi.readAddress.ready, canRead) @[Converter.scala 217:47]
      control_splitter.io.out.ready <= _splitter_io_out_ready_T @[Converter.scala 217:19]

  module Queue_50 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, count : UInt<2>}

    cmem ram : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>} [2] @[Decoupled.scala 259:95]
    reg value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg value_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(value_1, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(value_1, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      value_1 <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      value <= UInt<1>("h0") @[Counter.scala 99:11]
      value_1 <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Queue_51 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, count : UInt<2>}

    cmem ram : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>} [2] @[Decoupled.scala 259:95]
    reg value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg value_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(value_1, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(value_1, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      value_1 <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      value <= UInt<1>("h0") @[Counter.scala 99:11]
      value_1 <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Queue_52 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, count : UInt<2>}

    cmem ram : { id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>} [2] @[Decoupled.scala 259:95]
    reg value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg value_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(value_1, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(value_1, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      value_1 <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      value <= UInt<1>("h0") @[Counter.scala 99:11]
      value_1 <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Queue_53 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}, count : UInt<2>}

    cmem ram : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>} [2] @[Decoupled.scala 259:95]
    reg value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg value_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(value_1, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(value_1, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      value_1 <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      value <= UInt<1>("h0") @[Counter.scala 99:11]
      value_1 <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Queue_54 :
    input clock : Clock
    input reset : Reset
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, resp : UInt<2>}}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, resp : UInt<2>}}, count : UInt<2>}

    cmem ram : { id : UInt<6>, resp : UInt<2>} [2] @[Decoupled.scala 259:95]
    reg value : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg value_1 : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Counter.scala 62:40]
    reg maybe_full : UInt<1>, clock with :
      reset => (reset, UInt<1>("h0")) @[Decoupled.scala 262:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 263:33]
    node _empty_T = eq(maybe_full, UInt<1>("h0")) @[Decoupled.scala 264:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 264:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 265:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 50:35]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 50:35]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 272:16]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 273:8]
      MPORT <= io.enq.bits @[Decoupled.scala 273:24]
      node wrap = eq(value, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T = add(value, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 78:24]
      value <= _value_T_1 @[Counter.scala 78:15]
    when do_deq : @[Decoupled.scala 276:16]
      node wrap_1 = eq(value_1, UInt<1>("h1")) @[Counter.scala 74:24]
      node _value_T_2 = add(value_1, UInt<1>("h1")) @[Counter.scala 78:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 78:24]
      value_1 <= _value_T_3 @[Counter.scala 78:15]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 279:15]
    when _T : @[Decoupled.scala 279:27]
      maybe_full <= do_enq @[Decoupled.scala 280:16]
    when UInt<1>("h0") : @[Decoupled.scala 282:15]
      value <= UInt<1>("h0") @[Counter.scala 99:11]
      value_1 <= UInt<1>("h0") @[Counter.scala 99:11]
      maybe_full <= UInt<1>("h0") @[Decoupled.scala 285:16]
    node _io_deq_valid_T = eq(empty, UInt<1>("h0")) @[Decoupled.scala 288:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 288:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h0")) @[Decoupled.scala 289:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 289:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 296:23]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 296:17]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 312:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 312:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 315:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h2"), UInt<1>("h0")) @[Decoupled.scala 315:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 315:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 315:14]

  module Queue_55 :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { writeAddress : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, writeData : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, flip writeResponse : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, resp : UInt<2>}}, readAddress : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, flip readData : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}, out : { writeAddress : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, writeData : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, flip writeResponse : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, resp : UInt<2>}}, readAddress : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, flip readData : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}}

    inst io_out_readAddress_q of Queue_50 @[Decoupled.scala 361:21]
    io_out_readAddress_q.clock <= clock
    io_out_readAddress_q.reset <= reset
    io_out_readAddress_q.io.enq.valid <= io.in.readAddress.valid @[Decoupled.scala 363:22]
    io_out_readAddress_q.io.enq.bits.qos <= io.in.readAddress.bits.qos @[Decoupled.scala 364:21]
    io_out_readAddress_q.io.enq.bits.prot <= io.in.readAddress.bits.prot @[Decoupled.scala 364:21]
    io_out_readAddress_q.io.enq.bits.cache <= io.in.readAddress.bits.cache @[Decoupled.scala 364:21]
    io_out_readAddress_q.io.enq.bits.lock <= io.in.readAddress.bits.lock @[Decoupled.scala 364:21]
    io_out_readAddress_q.io.enq.bits.burst <= io.in.readAddress.bits.burst @[Decoupled.scala 364:21]
    io_out_readAddress_q.io.enq.bits.size <= io.in.readAddress.bits.size @[Decoupled.scala 364:21]
    io_out_readAddress_q.io.enq.bits.len <= io.in.readAddress.bits.len @[Decoupled.scala 364:21]
    io_out_readAddress_q.io.enq.bits.addr <= io.in.readAddress.bits.addr @[Decoupled.scala 364:21]
    io_out_readAddress_q.io.enq.bits.id <= io.in.readAddress.bits.id @[Decoupled.scala 364:21]
    io.in.readAddress.ready <= io_out_readAddress_q.io.enq.ready @[Decoupled.scala 365:17]
    io.out.readAddress.bits <= io_out_readAddress_q.io.deq.bits @[Queue.scala 14:22]
    io.out.readAddress.valid <= io_out_readAddress_q.io.deq.valid @[Queue.scala 14:22]
    io_out_readAddress_q.io.deq.ready <= io.out.readAddress.ready @[Queue.scala 14:22]
    inst io_out_writeAddress_q of Queue_51 @[Decoupled.scala 361:21]
    io_out_writeAddress_q.clock <= clock
    io_out_writeAddress_q.reset <= reset
    io_out_writeAddress_q.io.enq.valid <= io.in.writeAddress.valid @[Decoupled.scala 363:22]
    io_out_writeAddress_q.io.enq.bits.qos <= io.in.writeAddress.bits.qos @[Decoupled.scala 364:21]
    io_out_writeAddress_q.io.enq.bits.prot <= io.in.writeAddress.bits.prot @[Decoupled.scala 364:21]
    io_out_writeAddress_q.io.enq.bits.cache <= io.in.writeAddress.bits.cache @[Decoupled.scala 364:21]
    io_out_writeAddress_q.io.enq.bits.lock <= io.in.writeAddress.bits.lock @[Decoupled.scala 364:21]
    io_out_writeAddress_q.io.enq.bits.burst <= io.in.writeAddress.bits.burst @[Decoupled.scala 364:21]
    io_out_writeAddress_q.io.enq.bits.size <= io.in.writeAddress.bits.size @[Decoupled.scala 364:21]
    io_out_writeAddress_q.io.enq.bits.len <= io.in.writeAddress.bits.len @[Decoupled.scala 364:21]
    io_out_writeAddress_q.io.enq.bits.addr <= io.in.writeAddress.bits.addr @[Decoupled.scala 364:21]
    io_out_writeAddress_q.io.enq.bits.id <= io.in.writeAddress.bits.id @[Decoupled.scala 364:21]
    io.in.writeAddress.ready <= io_out_writeAddress_q.io.enq.ready @[Decoupled.scala 365:17]
    io.out.writeAddress.bits <= io_out_writeAddress_q.io.deq.bits @[Queue.scala 15:23]
    io.out.writeAddress.valid <= io_out_writeAddress_q.io.deq.valid @[Queue.scala 15:23]
    io_out_writeAddress_q.io.deq.ready <= io.out.writeAddress.ready @[Queue.scala 15:23]
    inst io_out_writeData_q of Queue_52 @[Decoupled.scala 361:21]
    io_out_writeData_q.clock <= clock
    io_out_writeData_q.reset <= reset
    io_out_writeData_q.io.enq.valid <= io.in.writeData.valid @[Decoupled.scala 363:22]
    io_out_writeData_q.io.enq.bits.last <= io.in.writeData.bits.last @[Decoupled.scala 364:21]
    io_out_writeData_q.io.enq.bits.strb <= io.in.writeData.bits.strb @[Decoupled.scala 364:21]
    io_out_writeData_q.io.enq.bits.data <= io.in.writeData.bits.data @[Decoupled.scala 364:21]
    io_out_writeData_q.io.enq.bits.id <= io.in.writeData.bits.id @[Decoupled.scala 364:21]
    io.in.writeData.ready <= io_out_writeData_q.io.enq.ready @[Decoupled.scala 365:17]
    io.out.writeData.bits <= io_out_writeData_q.io.deq.bits @[Queue.scala 16:20]
    io.out.writeData.valid <= io_out_writeData_q.io.deq.valid @[Queue.scala 16:20]
    io_out_writeData_q.io.deq.ready <= io.out.writeData.ready @[Queue.scala 16:20]
    inst io_in_readData_q of Queue_53 @[Decoupled.scala 361:21]
    io_in_readData_q.clock <= clock
    io_in_readData_q.reset <= reset
    io_in_readData_q.io.enq.valid <= io.out.readData.valid @[Decoupled.scala 363:22]
    io_in_readData_q.io.enq.bits.last <= io.out.readData.bits.last @[Decoupled.scala 364:21]
    io_in_readData_q.io.enq.bits.resp <= io.out.readData.bits.resp @[Decoupled.scala 364:21]
    io_in_readData_q.io.enq.bits.data <= io.out.readData.bits.data @[Decoupled.scala 364:21]
    io_in_readData_q.io.enq.bits.id <= io.out.readData.bits.id @[Decoupled.scala 364:21]
    io.out.readData.ready <= io_in_readData_q.io.enq.ready @[Decoupled.scala 365:17]
    io.in.readData.bits <= io_in_readData_q.io.deq.bits @[Queue.scala 17:18]
    io.in.readData.valid <= io_in_readData_q.io.deq.valid @[Queue.scala 17:18]
    io_in_readData_q.io.deq.ready <= io.in.readData.ready @[Queue.scala 17:18]
    inst io_in_writeResponse_q of Queue_54 @[Decoupled.scala 361:21]
    io_in_writeResponse_q.clock <= clock
    io_in_writeResponse_q.reset <= reset
    io_in_writeResponse_q.io.enq.valid <= io.out.writeResponse.valid @[Decoupled.scala 363:22]
    io_in_writeResponse_q.io.enq.bits.resp <= io.out.writeResponse.bits.resp @[Decoupled.scala 364:21]
    io_in_writeResponse_q.io.enq.bits.id <= io.out.writeResponse.bits.id @[Decoupled.scala 364:21]
    io.out.writeResponse.ready <= io_in_writeResponse_q.io.enq.ready @[Decoupled.scala 365:17]
    io.in.writeResponse.bits <= io_in_writeResponse_q.io.deq.bits @[Queue.scala 18:23]
    io.in.writeResponse.valid <= io_in_writeResponse_q.io.deq.valid @[Queue.scala 18:23]
    io_in_writeResponse_q.io.deq.ready <= io.in.writeResponse.ready @[Queue.scala 18:23]

  module AXIWrapperTCU :
    input clock : Clock
    input reset : Reset
    input instruction : { flip ready : UInt<1>, valid : UInt<1>, bits : { opcode : UInt<4>, flags : UInt<4>, arguments : UInt<56>}}
    output status : { flip ready : UInt<1>, valid : UInt<1>, bits : { last : UInt<1>, bits : { opcode : UInt<4>, flags : UInt<4>, arguments : UInt<56>}}}
    output dram0 : { writeAddress : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, writeData : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, flip writeResponse : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, resp : UInt<2>}}, readAddress : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, flip readData : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}
    output dram1 : { writeAddress : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, writeData : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, flip writeResponse : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, resp : UInt<2>}}, readAddress : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, flip readData : { flip ready : UInt<1>, valid : UInt<1>, bits : { id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}
    output error : UInt<1>
    output sample : { flip ready : UInt<1>, valid : UInt<1>, bits : { last : UInt<1>, bits : { flags : { instruction : { ready : UInt<1>, valid : UInt<1>}, memPortA : { ready : UInt<1>, valid : UInt<1>}, memPortB : { ready : UInt<1>, valid : UInt<1>}, dram0 : { ready : UInt<1>, valid : UInt<1>}, dram1 : { ready : UInt<1>, valid : UInt<1>}, dataflow : { ready : UInt<1>, valid : UInt<1>}, acc : { ready : UInt<1>, valid : UInt<1>}, array : { ready : UInt<1>, valid : UInt<1>}}, programCounter : UInt<32>}}}

    inst tcu of TCU @[AXIWrapperTCU.scala 32:19]
    tcu.clock <= clock
    tcu.reset <= reset
    tcu.io.instruction <= instruction @[AXIWrapperTCU.scala 47:22]
    status.bits <= tcu.io.status.bits @[AXIWrapperTCU.scala 48:10]
    status.valid <= tcu.io.status.valid @[AXIWrapperTCU.scala 48:10]
    tcu.io.status.ready <= status.ready @[AXIWrapperTCU.scala 48:10]
    error <= tcu.io.error @[AXIWrapperTCU.scala 49:9]
    sample.bits <= tcu.io.sample.bits @[AXIWrapperTCU.scala 50:10]
    sample.valid <= tcu.io.sample.valid @[AXIWrapperTCU.scala 50:10]
    tcu.io.sample.ready <= sample.ready @[AXIWrapperTCU.scala 50:10]
    inst dram0BoundarySplitter of MemBoundarySplitter @[AXIWrapperTCU.scala 56:37]
    dram0BoundarySplitter.clock <= clock
    dram0BoundarySplitter.reset <= reset
    dram0BoundarySplitter.io.out.readData <= dram0.readData @[AXIWrapperTCU.scala 59:9]
    dram0.readAddress.bits <= dram0BoundarySplitter.io.out.readAddress.bits @[AXIWrapperTCU.scala 59:9]
    dram0.readAddress.valid <= dram0BoundarySplitter.io.out.readAddress.valid @[AXIWrapperTCU.scala 59:9]
    dram0BoundarySplitter.io.out.readAddress.ready <= dram0.readAddress.ready @[AXIWrapperTCU.scala 59:9]
    dram0BoundarySplitter.io.out.writeResponse <= dram0.writeResponse @[AXIWrapperTCU.scala 59:9]
    dram0.writeData.bits <= dram0BoundarySplitter.io.out.writeData.bits @[AXIWrapperTCU.scala 59:9]
    dram0.writeData.valid <= dram0BoundarySplitter.io.out.writeData.valid @[AXIWrapperTCU.scala 59:9]
    dram0BoundarySplitter.io.out.writeData.ready <= dram0.writeData.ready @[AXIWrapperTCU.scala 59:9]
    dram0.writeAddress.bits <= dram0BoundarySplitter.io.out.writeAddress.bits @[AXIWrapperTCU.scala 59:9]
    dram0.writeAddress.valid <= dram0BoundarySplitter.io.out.writeAddress.valid @[AXIWrapperTCU.scala 59:9]
    dram0BoundarySplitter.io.out.writeAddress.ready <= dram0.writeAddress.ready @[AXIWrapperTCU.scala 59:9]
    inst dram1BoundarySplitter of MemBoundarySplitter_1 @[AXIWrapperTCU.scala 60:37]
    dram1BoundarySplitter.clock <= clock
    dram1BoundarySplitter.reset <= reset
    dram1BoundarySplitter.io.out.readData <= dram1.readData @[AXIWrapperTCU.scala 63:9]
    dram1.readAddress.bits <= dram1BoundarySplitter.io.out.readAddress.bits @[AXIWrapperTCU.scala 63:9]
    dram1.readAddress.valid <= dram1BoundarySplitter.io.out.readAddress.valid @[AXIWrapperTCU.scala 63:9]
    dram1BoundarySplitter.io.out.readAddress.ready <= dram1.readAddress.ready @[AXIWrapperTCU.scala 63:9]
    dram1BoundarySplitter.io.out.writeResponse <= dram1.writeResponse @[AXIWrapperTCU.scala 63:9]
    dram1.writeData.bits <= dram1BoundarySplitter.io.out.writeData.bits @[AXIWrapperTCU.scala 63:9]
    dram1.writeData.valid <= dram1BoundarySplitter.io.out.writeData.valid @[AXIWrapperTCU.scala 63:9]
    dram1BoundarySplitter.io.out.writeData.ready <= dram1.writeData.ready @[AXIWrapperTCU.scala 63:9]
    dram1.writeAddress.bits <= dram1BoundarySplitter.io.out.writeAddress.bits @[AXIWrapperTCU.scala 63:9]
    dram1.writeAddress.valid <= dram1BoundarySplitter.io.out.writeAddress.valid @[AXIWrapperTCU.scala 63:9]
    dram1BoundarySplitter.io.out.writeAddress.ready <= dram1.writeAddress.ready @[AXIWrapperTCU.scala 63:9]
    inst dram0Converter of Converter @[AXIWrapperTCU.scala 65:30]
    dram0Converter.clock <= clock
    dram0Converter.reset <= reset
    inst dram0BoundarySplitter_io_in_q of Queue_45 @[Queue.scala 23:19]
    dram0BoundarySplitter_io_in_q.clock <= clock
    dram0BoundarySplitter_io_in_q.reset <= reset
    dram0BoundarySplitter_io_in_q.io.in <= dram0Converter.io.axi @[Queue.scala 24:13]
    dram0BoundarySplitter.io.in <= dram0BoundarySplitter_io_in_q.io.out @[AXIWrapperTCU.scala 74:31]
    dram0Converter.io.mem.dataOut <= tcu.io.dram0.dataOut @[AXIWrapperTCU.scala 75:25]
    tcu.io.dram0.dataIn <= dram0Converter.io.mem.dataIn @[AXIWrapperTCU.scala 75:25]
    dram0Converter.io.mem.control <= tcu.io.dram0.control @[AXIWrapperTCU.scala 75:25]
    dram0Converter.io.addressOffset <= tcu.io.config.dram0AddressOffset @[AXIWrapperTCU.scala 76:35]
    dram0Converter.io.cacheBehavior <= tcu.io.config.dram0CacheBehaviour @[AXIWrapperTCU.scala 77:35]
    dram0Converter.io.timeout <= tcu.io.timeout @[AXIWrapperTCU.scala 78:29]
    dram0Converter.io.tracepoint <= tcu.io.tracepoint @[AXIWrapperTCU.scala 79:32]
    dram0Converter.io.programCounter <= tcu.io.programCounter @[AXIWrapperTCU.scala 80:36]
    inst dram1Converter of Converter_1 @[AXIWrapperTCU.scala 82:30]
    dram1Converter.clock <= clock
    dram1Converter.reset <= reset
    inst dram1BoundarySplitter_io_in_q of Queue_55 @[Queue.scala 23:19]
    dram1BoundarySplitter_io_in_q.clock <= clock
    dram1BoundarySplitter_io_in_q.reset <= reset
    dram1BoundarySplitter_io_in_q.io.in <= dram1Converter.io.axi @[Queue.scala 24:13]
    dram1BoundarySplitter.io.in <= dram1BoundarySplitter_io_in_q.io.out @[AXIWrapperTCU.scala 91:31]
    dram1Converter.io.mem.dataOut <= tcu.io.dram1.dataOut @[AXIWrapperTCU.scala 92:25]
    tcu.io.dram1.dataIn <= dram1Converter.io.mem.dataIn @[AXIWrapperTCU.scala 92:25]
    dram1Converter.io.mem.control <= tcu.io.dram1.control @[AXIWrapperTCU.scala 92:25]
    dram1Converter.io.addressOffset <= tcu.io.config.dram1AddressOffset @[AXIWrapperTCU.scala 93:35]
    dram1Converter.io.cacheBehavior <= tcu.io.config.dram1CacheBehaviour @[AXIWrapperTCU.scala 94:35]
    dram1Converter.io.timeout <= tcu.io.timeout @[AXIWrapperTCU.scala 95:29]
    dram1Converter.io.tracepoint <= tcu.io.tracepoint @[AXIWrapperTCU.scala 96:32]
    dram1Converter.io.programCounter <= tcu.io.programCounter @[AXIWrapperTCU.scala 97:36]

  module StrictDecoupledTransmission :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}, flip error : UInt<1>}

    io.out <= io.in @[Transmission.scala 46:12]

  module Transmission :
    input clock : Clock
    input reset : Reset
    output io : { flip in : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}, out : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}, flip error : UInt<1>}

    inst dt of StrictDecoupledTransmission @[Transmission.scala 23:20]
    dt.clock <= clock
    dt.reset <= reset
    dt.io.in <= io.in @[Transmission.scala 24:14]
    io.out.bits <= dt.io.out.bits @[Transmission.scala 25:12]
    io.out.valid <= dt.io.out.valid @[Transmission.scala 25:12]
    dt.io.out.ready <= io.out.ready @[Transmission.scala 25:12]
    dt.io.error <= io.error @[Transmission.scala 26:17]

  module top_sd_blk :
    input clock : Clock
    input reset : UInt<1>
    input instruction : { tdata : UInt<64>, tvalid : UInt<1>, flip tready : UInt<1>, tlast : UInt<1>}
    output m_axi_dram0 : { flip awready : UInt<1>, awvalid : UInt<1>, awid : UInt<6>, awaddr : UInt<32>, awlen : UInt<8>, awsize : UInt<3>, awburst : UInt<2>, awlock : UInt<2>, awcache : UInt<4>, awprot : UInt<3>, awqos : UInt<4>, flip wready : UInt<1>, wvalid : UInt<1>, wid : UInt<6>, wdata : UInt<64>, wstrb : UInt<8>, wlast : UInt<1>, bready : UInt<1>, flip bvalid : UInt<1>, flip bid : UInt<6>, flip bresp : UInt<2>, flip arready : UInt<1>, arvalid : UInt<1>, arid : UInt<6>, araddr : UInt<32>, arlen : UInt<8>, arsize : UInt<3>, arburst : UInt<2>, arlock : UInt<2>, arcache : UInt<4>, arprot : UInt<3>, arqos : UInt<4>, rready : UInt<1>, flip rvalid : UInt<1>, flip rid : UInt<6>, flip rdata : UInt<64>, flip rresp : UInt<2>, flip rlast : UInt<1>}
    output m_axi_dram1 : { flip awready : UInt<1>, awvalid : UInt<1>, awid : UInt<6>, awaddr : UInt<32>, awlen : UInt<8>, awsize : UInt<3>, awburst : UInt<2>, awlock : UInt<2>, awcache : UInt<4>, awprot : UInt<3>, awqos : UInt<4>, flip wready : UInt<1>, wvalid : UInt<1>, wid : UInt<6>, wdata : UInt<64>, wstrb : UInt<8>, wlast : UInt<1>, bready : UInt<1>, flip bvalid : UInt<1>, flip bid : UInt<6>, flip bresp : UInt<2>, flip arready : UInt<1>, arvalid : UInt<1>, arid : UInt<6>, araddr : UInt<32>, arlen : UInt<8>, arsize : UInt<3>, arburst : UInt<2>, arlock : UInt<2>, arcache : UInt<4>, arprot : UInt<3>, arqos : UInt<4>, rready : UInt<1>, flip rvalid : UInt<1>, flip rid : UInt<6>, flip rdata : UInt<64>, flip rresp : UInt<2>, flip rlast : UInt<1>}

    node _T = eq(reset, UInt<1>("h0")) @[Top.scala 75:56]
    inst tcu of AXIWrapperTCU @[Top.scala 76:21]
    tcu.clock <= clock
    tcu.reset <= _T
    inst transmission of Transmission @[package.scala 27:30]
    transmission.clock <= clock
    transmission.reset <= _T
    wire transmission_io_in_w : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>} @[AXI4Stream.scala 16:17]
    transmission_io_in_w.bits <= instruction.tdata @[AXI4Stream.scala 17:12]
    transmission_io_in_w.valid <= instruction.tvalid @[AXI4Stream.scala 18:13]
    instruction.tready <= transmission_io_in_w.ready @[AXI4Stream.scala 19:12]
    transmission.io.in <= transmission_io_in_w @[package.scala 29:24]
    tcu.instruction.valid <= transmission.io.out.valid @[package.scala 30:15]
    transmission.io.out.ready <= tcu.instruction.ready @[package.scala 31:31]
    wire _tcu_instruction_bits_WIRE : { opcode : UInt<4>, flags : UInt<4>, arguments : UInt<56>} @[package.scala 32:50]
    wire _tcu_instruction_bits_WIRE_1 : UInt<64>
    _tcu_instruction_bits_WIRE_1 <= transmission.io.out.bits
    node _tcu_instruction_bits_T = bits(_tcu_instruction_bits_WIRE_1, 55, 0) @[package.scala 32:50]
    _tcu_instruction_bits_WIRE.arguments <= _tcu_instruction_bits_T @[package.scala 32:50]
    node _tcu_instruction_bits_T_1 = bits(_tcu_instruction_bits_WIRE_1, 59, 56) @[package.scala 32:50]
    _tcu_instruction_bits_WIRE.flags <= _tcu_instruction_bits_T_1 @[package.scala 32:50]
    node _tcu_instruction_bits_T_2 = bits(_tcu_instruction_bits_WIRE_1, 63, 60) @[package.scala 32:50]
    _tcu_instruction_bits_WIRE.opcode <= _tcu_instruction_bits_T_2 @[package.scala 32:50]
    tcu.instruction.bits.arguments <= _tcu_instruction_bits_WIRE.arguments @[package.scala 32:14]
    tcu.instruction.bits.flags <= _tcu_instruction_bits_WIRE.flags @[package.scala 32:14]
    tcu.instruction.bits.opcode <= _tcu_instruction_bits_WIRE.opcode @[package.scala 32:14]
    transmission.io.error <= tcu.error @[package.scala 33:27]
    tcu.status.ready <= UInt<1>("h0") @[package.scala 409:15]
    tcu.sample.ready <= UInt<1>("h0") @[package.scala 409:15]
    m_axi_dram0.awvalid <= tcu.dram0.writeAddress.valid @[ExternalMaster.scala 68:33]
    tcu.dram0.writeAddress.ready <= m_axi_dram0.awready @[ExternalMaster.scala 69:33]
    m_axi_dram0.awqos <= tcu.dram0.writeAddress.bits.qos @[ExternalMaster.scala 72:26]
    m_axi_dram0.awprot <= tcu.dram0.writeAddress.bits.prot @[ExternalMaster.scala 72:26]
    m_axi_dram0.awcache <= tcu.dram0.writeAddress.bits.cache @[ExternalMaster.scala 72:26]
    m_axi_dram0.awlock <= tcu.dram0.writeAddress.bits.lock @[ExternalMaster.scala 72:26]
    m_axi_dram0.awburst <= tcu.dram0.writeAddress.bits.burst @[ExternalMaster.scala 72:26]
    m_axi_dram0.awsize <= tcu.dram0.writeAddress.bits.size @[ExternalMaster.scala 72:26]
    m_axi_dram0.awlen <= tcu.dram0.writeAddress.bits.len @[ExternalMaster.scala 72:26]
    m_axi_dram0.awaddr <= tcu.dram0.writeAddress.bits.addr @[ExternalMaster.scala 72:26]
    m_axi_dram0.awid <= tcu.dram0.writeAddress.bits.id @[ExternalMaster.scala 72:26]
    m_axi_dram0.wvalid <= tcu.dram0.writeData.valid @[ExternalMaster.scala 68:33]
    tcu.dram0.writeData.ready <= m_axi_dram0.wready @[ExternalMaster.scala 69:33]
    m_axi_dram0.wlast <= tcu.dram0.writeData.bits.last @[ExternalMaster.scala 72:26]
    m_axi_dram0.wstrb <= tcu.dram0.writeData.bits.strb @[ExternalMaster.scala 72:26]
    m_axi_dram0.wdata <= tcu.dram0.writeData.bits.data @[ExternalMaster.scala 72:26]
    m_axi_dram0.wid <= tcu.dram0.writeData.bits.id @[ExternalMaster.scala 72:26]
    tcu.dram0.writeResponse.valid <= m_axi_dram0.bvalid @[ExternalMaster.scala 68:33]
    m_axi_dram0.bready <= tcu.dram0.writeResponse.ready @[ExternalMaster.scala 69:33]
    tcu.dram0.writeResponse.bits.resp <= m_axi_dram0.bresp @[ExternalMaster.scala 72:26]
    tcu.dram0.writeResponse.bits.id <= m_axi_dram0.bid @[ExternalMaster.scala 72:26]
    m_axi_dram0.arvalid <= tcu.dram0.readAddress.valid @[ExternalMaster.scala 68:33]
    tcu.dram0.readAddress.ready <= m_axi_dram0.arready @[ExternalMaster.scala 69:33]
    m_axi_dram0.arqos <= tcu.dram0.readAddress.bits.qos @[ExternalMaster.scala 72:26]
    m_axi_dram0.arprot <= tcu.dram0.readAddress.bits.prot @[ExternalMaster.scala 72:26]
    m_axi_dram0.arcache <= tcu.dram0.readAddress.bits.cache @[ExternalMaster.scala 72:26]
    m_axi_dram0.arlock <= tcu.dram0.readAddress.bits.lock @[ExternalMaster.scala 72:26]
    m_axi_dram0.arburst <= tcu.dram0.readAddress.bits.burst @[ExternalMaster.scala 72:26]
    m_axi_dram0.arsize <= tcu.dram0.readAddress.bits.size @[ExternalMaster.scala 72:26]
    m_axi_dram0.arlen <= tcu.dram0.readAddress.bits.len @[ExternalMaster.scala 72:26]
    m_axi_dram0.araddr <= tcu.dram0.readAddress.bits.addr @[ExternalMaster.scala 72:26]
    m_axi_dram0.arid <= tcu.dram0.readAddress.bits.id @[ExternalMaster.scala 72:26]
    tcu.dram0.readData.valid <= m_axi_dram0.rvalid @[ExternalMaster.scala 68:33]
    m_axi_dram0.rready <= tcu.dram0.readData.ready @[ExternalMaster.scala 69:33]
    tcu.dram0.readData.bits.last <= m_axi_dram0.rlast @[ExternalMaster.scala 72:26]
    tcu.dram0.readData.bits.resp <= m_axi_dram0.rresp @[ExternalMaster.scala 72:26]
    tcu.dram0.readData.bits.data <= m_axi_dram0.rdata @[ExternalMaster.scala 72:26]
    tcu.dram0.readData.bits.id <= m_axi_dram0.rid @[ExternalMaster.scala 72:26]
    m_axi_dram1.awvalid <= tcu.dram1.writeAddress.valid @[ExternalMaster.scala 68:33]
    tcu.dram1.writeAddress.ready <= m_axi_dram1.awready @[ExternalMaster.scala 69:33]
    m_axi_dram1.awqos <= tcu.dram1.writeAddress.bits.qos @[ExternalMaster.scala 72:26]
    m_axi_dram1.awprot <= tcu.dram1.writeAddress.bits.prot @[ExternalMaster.scala 72:26]
    m_axi_dram1.awcache <= tcu.dram1.writeAddress.bits.cache @[ExternalMaster.scala 72:26]
    m_axi_dram1.awlock <= tcu.dram1.writeAddress.bits.lock @[ExternalMaster.scala 72:26]
    m_axi_dram1.awburst <= tcu.dram1.writeAddress.bits.burst @[ExternalMaster.scala 72:26]
    m_axi_dram1.awsize <= tcu.dram1.writeAddress.bits.size @[ExternalMaster.scala 72:26]
    m_axi_dram1.awlen <= tcu.dram1.writeAddress.bits.len @[ExternalMaster.scala 72:26]
    m_axi_dram1.awaddr <= tcu.dram1.writeAddress.bits.addr @[ExternalMaster.scala 72:26]
    m_axi_dram1.awid <= tcu.dram1.writeAddress.bits.id @[ExternalMaster.scala 72:26]
    m_axi_dram1.wvalid <= tcu.dram1.writeData.valid @[ExternalMaster.scala 68:33]
    tcu.dram1.writeData.ready <= m_axi_dram1.wready @[ExternalMaster.scala 69:33]
    m_axi_dram1.wlast <= tcu.dram1.writeData.bits.last @[ExternalMaster.scala 72:26]
    m_axi_dram1.wstrb <= tcu.dram1.writeData.bits.strb @[ExternalMaster.scala 72:26]
    m_axi_dram1.wdata <= tcu.dram1.writeData.bits.data @[ExternalMaster.scala 72:26]
    m_axi_dram1.wid <= tcu.dram1.writeData.bits.id @[ExternalMaster.scala 72:26]
    tcu.dram1.writeResponse.valid <= m_axi_dram1.bvalid @[ExternalMaster.scala 68:33]
    m_axi_dram1.bready <= tcu.dram1.writeResponse.ready @[ExternalMaster.scala 69:33]
    tcu.dram1.writeResponse.bits.resp <= m_axi_dram1.bresp @[ExternalMaster.scala 72:26]
    tcu.dram1.writeResponse.bits.id <= m_axi_dram1.bid @[ExternalMaster.scala 72:26]
    m_axi_dram1.arvalid <= tcu.dram1.readAddress.valid @[ExternalMaster.scala 68:33]
    tcu.dram1.readAddress.ready <= m_axi_dram1.arready @[ExternalMaster.scala 69:33]
    m_axi_dram1.arqos <= tcu.dram1.readAddress.bits.qos @[ExternalMaster.scala 72:26]
    m_axi_dram1.arprot <= tcu.dram1.readAddress.bits.prot @[ExternalMaster.scala 72:26]
    m_axi_dram1.arcache <= tcu.dram1.readAddress.bits.cache @[ExternalMaster.scala 72:26]
    m_axi_dram1.arlock <= tcu.dram1.readAddress.bits.lock @[ExternalMaster.scala 72:26]
    m_axi_dram1.arburst <= tcu.dram1.readAddress.bits.burst @[ExternalMaster.scala 72:26]
    m_axi_dram1.arsize <= tcu.dram1.readAddress.bits.size @[ExternalMaster.scala 72:26]
    m_axi_dram1.arlen <= tcu.dram1.readAddress.bits.len @[ExternalMaster.scala 72:26]
    m_axi_dram1.araddr <= tcu.dram1.readAddress.bits.addr @[ExternalMaster.scala 72:26]
    m_axi_dram1.arid <= tcu.dram1.readAddress.bits.id @[ExternalMaster.scala 72:26]
    tcu.dram1.readData.valid <= m_axi_dram1.rvalid @[ExternalMaster.scala 68:33]
    m_axi_dram1.rready <= tcu.dram1.readData.ready @[ExternalMaster.scala 69:33]
    tcu.dram1.readData.bits.last <= m_axi_dram1.rlast @[ExternalMaster.scala 72:26]
    tcu.dram1.readData.bits.resp <= m_axi_dram1.rresp @[ExternalMaster.scala 72:26]
    tcu.dram1.readData.bits.data <= m_axi_dram1.rdata @[ExternalMaster.scala 72:26]
    tcu.dram1.readData.bits.id <= m_axi_dram1.rid @[ExternalMaster.scala 72:26]

